<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>排序代码 快排 冒泡 折半</title>
      <link href="2022/07/11/%E6%8E%92%E5%BA%8F%E4%BB%A3%E7%A0%81/"/>
      <url>2022/07/11/%E6%8E%92%E5%BA%8F%E4%BB%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="排序代码"><a href="#排序代码" class="headerlink" title="排序代码"></a>排序代码</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">      <span class="keyword">const</span> num = [<span class="number">0</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">99</span>];</span><br><span class="line">      <span class="comment">//   num.splice(2, 3);</span></span><br><span class="line">      <span class="comment">//   console.log(num);</span></span><br><span class="line">      <span class="comment">// 冒泡排序</span></span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">numSort</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> n = num.length;</span><br><span class="line">        <span class="built_in">console</span>.log(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">          <span class="keyword">let</span> flag = <span class="literal">false</span>;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num[j] &gt; num[j + <span class="number">1</span>]) &#123;</span><br><span class="line">              <span class="keyword">let</span> temp = num[j];</span><br><span class="line">              num[j] = num[j + <span class="number">1</span>];</span><br><span class="line">              num[j + <span class="number">1</span>] = temp;</span><br><span class="line">              flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (flag === <span class="literal">false</span>) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(num);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(num);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//  numSort(num);</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//快速排序</span></span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">QuickSort</span>(<span class="params">num, low, high</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">          <span class="comment">//中轴</span></span><br><span class="line">          <span class="keyword">let</span> pivot = partion(num, low, high);</span><br><span class="line">          QuickSort(num, low, pivot - <span class="number">1</span>);</span><br><span class="line">          QuickSort(num, pivot + <span class="number">1</span>, high);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">partion</span>(<span class="params">num, low, high</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//区最低位为基点</span></span><br><span class="line">        <span class="keyword">let</span> pivot = num[low];</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">          <span class="comment">// low小于high 大于就不成立了</span></span><br><span class="line">          <span class="keyword">while</span> (low &lt; high &amp;&amp; num[high] &gt;= pivot) &#123;</span><br><span class="line">            high--;</span><br><span class="line">          &#125;</span><br><span class="line">          num[low] = num[high];</span><br><span class="line">          <span class="keyword">while</span> (low &lt; high &amp;&amp; num[low] &lt;= pivot) &#123;</span><br><span class="line">            low++;</span><br><span class="line">          &#125;</span><br><span class="line">          num[high] = num[low];</span><br><span class="line">        &#125;</span><br><span class="line">        num[low] = pivot;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">      &#125;</span><br><span class="line">      QuickSort(num, <span class="number">0</span>, num.length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//折半查找</span></span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">HaltSort</span>(<span class="params">num, key</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(num);</span><br><span class="line">        <span class="built_in">console</span>.log(key);</span><br><span class="line">        <span class="keyword">let</span> n = num.length;</span><br><span class="line">        <span class="keyword">let</span> low = <span class="number">0</span>,</span><br><span class="line">          high = n - <span class="number">1</span>,</span><br><span class="line">          mid;</span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">          <span class="comment">// 想下取整</span></span><br><span class="line">          mid = <span class="built_in">Math</span>.floor((low + high) / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (num[mid] === key) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num[mid] &gt; key) &#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">let</span> point = HaltSort(num, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">console</span>.log(point);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//折半插入排序</span></span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">halfSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">          <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">          <span class="comment">// 是在第 i 项的左面查找出合适的位置将 第 i 项插入进去，所以查找范围是 第 i 项的左侧</span></span><br><span class="line">          <span class="comment">// 所以 right 为 i-1</span></span><br><span class="line">          <span class="keyword">let</span> right = i - <span class="number">1</span>;</span><br><span class="line">          <span class="comment">// 因为插入元素要移动插入位置之后的数组元素，所以先保存要插入的元素，防止被覆盖掉</span></span><br><span class="line">          <span class="comment">// arr[i] 是要插入到前面的元素</span></span><br><span class="line">          <span class="keyword">const</span> temp = arr[i];</span><br><span class="line">          <span class="comment">// 二分查找算法</span></span><br><span class="line">          <span class="comment">// 可以自己在纸上写一下，会发现查找结束后，left的值就是要插入的下标位置</span></span><br><span class="line">          <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">let</span> mid = <span class="built_in">Math</span>.floor((left + right) / <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span> (arr[mid] &gt; arr[i]) &#123;</span><br><span class="line">              right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="built_in">console</span>.log(left);</span><br><span class="line">          <span class="comment">// 从二分查找的那部分数组的末尾，到要插入的位置全部向后移动一位</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">let</span> j = i - <span class="number">1</span>; j &gt;= left; j--) &#123;</span><br><span class="line">            arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 插入</span></span><br><span class="line">          arr[left] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> arr = [<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line">      halfSort(num);</span><br><span class="line">      <span class="built_in">console</span>.log(num);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;---------------------------------&quot;</span>);</span><br><span class="line">      <span class="comment">// 调用函数</span></span><br><span class="line">      foo(); <span class="comment">//函数已经预解析了</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 声明函数</span></span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;声明之前即被调用...&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 求生函数，计算所有参数的和</span></span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// console.log(arguments);</span></span><br><span class="line">        <span class="keyword">let</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 函数内部有一个特殊的对象，arguments</span></span><br><span class="line">        <span class="comment">// arguments用于接受所有的实参</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">          s += <span class="built_in">arguments</span>[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(s);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      sum(<span class="number">5</span>, <span class="number">10</span>); <span class="comment">// 两个参数</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> sss = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">      <span class="keyword">let</span> [a, b, c] = sss;</span><br><span class="line">      <span class="built_in">console</span>.log(a, b, c);</span><br><span class="line">    &lt;/script&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法与数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端面试</title>
      <link href="2022/07/10/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/"/>
      <url>2022/07/10/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="前端面试题整理"><a href="#前端面试题整理" class="headerlink" title="前端面试题整理"></a>前端面试题整理</h1><p>已同步到掘金、CSDN</p><p>掘金地址： <a href="https://juejin.cn/post/7075332630417244173">https://juejin.cn/post/7075332630417244173</a></p><p>CSDN 地址：<a href="https://blog.csdn.net/z1832729975/article/details/123431083">https://blog.csdn.net/z1832729975/article/details/123431083</a></p><p>个人整理了很多网上常见的面试题，希望也能通过这来复习<br>内容有点多，可能 CSDN 上预览效果不好，想要 markdown 文档的可以私信我，推荐使用<code>Typora</code>看</p><p><img src= "/img/loading1.gif" data-lazy-src="https://img-blog.csdnimg.cn/d6ed481d07584df1b1cd8e06084fba9f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAemjpmL_po54=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>比较好的面试题</p><p><a href="https://juejin.cn/post/6989422484722286600">2021 年我的前端面试准备</a><br><a href="https://juejin.cn/post/6844904116339261447">2021 年前端面试必读文章【超三百篇文章/赠复习导图】</a></p><h2 id="CSS、HTML"><a href="#CSS、HTML" class="headerlink" title="CSS、HTML"></a>CSS、HTML</h2><h3 id="浏览器内核"><a href="#浏览器内核" class="headerlink" title="浏览器内核"></a>浏览器内核</h3><blockquote><p>IE: trident 内核<br>Firefox：gecko 内核<br>Safari: webkit 内核<br>Opera: 以前是 presto 内核，Opera 现已改用 GoogleChrome 的 Blink 内核<br>Chrome: Blink(基于 webkit，Google 与 Opera Software 共同开发)</p></blockquote><h3 id="你是怎么理解-HTML-语义化"><a href="#你是怎么理解-HTML-语义化" class="headerlink" title="你是怎么理解 HTML 语义化"></a><strong>你是怎么理解</strong> <strong>HTML</strong> <strong>语义化</strong></h3><p>HTML 语义化简单来说就是 用<strong>正确的标签来做正确的事。</strong><br>比如表示段落用 p 标签、表示标题用 h1-h6 标签、表示文章就用 article 等。</p><h3 id="DOCTYPE-的作用"><a href="#DOCTYPE-的作用" class="headerlink" title="DOCTYPE 的作用"></a>DOCTYPE 的作用</h3><blockquote><p><a href="https://www.cnblogs.com/wuqiutong/p/5986191.htmlhttps://www.cnblogs.com/wuqiutong/p/5986191.html">Doctype 作用？严格模式与混杂模式如何区分？它们有何差异？</a></p></blockquote><ol><li><p><code>&lt;!DOCTYPE&gt;</code> 声明位于文档中的最前面，处于 <code>&lt;html&gt;</code> 标签之前。告知浏览器以何种模式来渲染文档。</p></li><li><p>严格模式的排版和 JS 运作模式是 以该浏览器支持的最高标准运行。</p></li><li><p>在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站 点无法工作。</p></li><li><p>DOCTYPE 不存在或格式不正确会导致文档以混杂模式呈现。复制代码 你知道多少种 Doctype 文档类型？ 该标签可声明三种 DTD 类型，分别表示严格版本、过渡版本以及基于框架的 HTML 文档。 HTML 4.01 规定了三种文档类型：Strict、Transitional 以及 Frameset。 XHTML 1.0 规定了三种 XML 文档类型：Strict、Transitional 以及 Frameset。 Standards （标准）模式（也就是严格呈现模式）用于呈现遵循最新标准的网页，而 Quirks （包容）模式（也就是松散呈现模式或者兼容模式）用于呈现为传统浏览器而设计的网页。</p></li></ol><h3 id="行内元素、块级元素、-空元素有那些？"><a href="#行内元素、块级元素、-空元素有那些？" class="headerlink" title="行内元素、块级元素、 空元素有那些？"></a>行内元素、块级元素、 空元素有那些？</h3><ul><li>行内元素 (不能设置宽高，设置宽高无效) a,span,i,em,strong,label</li><li>行内块元素：img, input</li><li>块元素： div, p, h1-h6, ul,li,ol,dl,table…</li><li>知名的空元素 br, hr,img, input,link,meta</li></ul><p>可以通过 display 修改 <code>inline-block</code>, <code>block</code>, <code>inline</code> 切换成行内元素    </p><p><strong>注意</strong></p><p>只有文字才能组成段落，因此 <code>p</code> 标签里面不能放块级元素，特别是 <code>p</code> 标签不能放 <code>div</code>。同理还有这些标签<code>h1,h2,h3,h4,h5,h6,dt</code> ，他们都是文字类块级标签，里面不能放其他块级元素。</p><h3 id="meta-viewport-是做什么用的，怎么写"><a href="#meta-viewport-是做什么用的，怎么写" class="headerlink" title="meta viewport 是做什么用的，怎么写"></a><strong>meta viewport</strong> <strong>是做什么用的，怎么写</strong></h3><p>使用目的</p><p>告诉浏览器，用户在移动端时如何缩放页面</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta</span><br><span class="line">  name=&quot;viewport&quot;</span><br><span class="line">  content=&quot;width=device-width, </span><br><span class="line">               initial-scale=1, </span><br><span class="line">               maximum-scale-1, minimum-scale=1&quot;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure><p><code>with=device-width</code> 将布局视窗（layout viewport）的宽度设置为设备屏幕分辨率的宽度</p><p><code>initial-scale=1</code> 页面初始缩放比例为屏幕分辨率的宽度</p><p><code>maximum-scale=1</code> 指定用户能够放大的最大比例</p><p><code>minimum-scale=1</code> 指定用户能够缩小的最大比例</p><h3 id="label-标签的作用"><a href="#label-标签的作用" class="headerlink" title="label 标签的作用"></a><strong>label</strong> <strong>标签的作用</strong></h3><p>label 标签来定义表单控制间的关系,当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;Name&quot;</span>&gt;</span>Number:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Name&quot;</span> <span class="attr">id</span>=<span class="string">&quot;Name&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;label</span><br><span class="line">  &gt;Date:</span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;B&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="canvas-在标签上设置宽高-和在-style-中设置宽高有什么-区别"><a href="#canvas-在标签上设置宽高-和在-style-中设置宽高有什么-区别" class="headerlink" title="canvas 在标签上设置宽高 和在 style 中设置宽高有什么 区别"></a><strong>canvas</strong> <strong>在标签上设置宽高 和在</strong> <strong>style</strong> <strong>中设置宽高有什么</strong> <strong>区别</strong></h3><blockquote><p>canvas 标签的 width 和 height 是画布实际宽度和高度，绘制的图形都是在这个上面。<br>而 style 的 width 和 height 是 canvas 在浏览器中被渲染的高度和宽度。<br>如果 canvas 的 width 和 height 没指定或值不正确，就被设置成默认值 。</p></blockquote><h3 id="html5-新特性"><a href="#html5-新特性" class="headerlink" title="html5 新特性"></a>html5 新特性</h3><blockquote><p><a href="https://zhuanlan.zhihu.com/p/77131734">HTML5 新特性</a></p></blockquote><ol><li><p>语义化标签， header, footer, nav, aside,article,section</p></li><li><p>增强型表单</p></li><li><p>视频 video 和音频 audio</p></li><li><p>Canvas 绘图</p></li><li><p><a href="https://so.csdn.net/so/search?q=SVG&spm=1001.2101.3001.7020">SVG</a>绘图</p></li><li><p>地理定位</p></li><li><p>拖放 API</p></li><li><p>WebWorker</p></li><li><p>WebStorage( 本地离线存储 localStorage、sessionStorage )</p><p>localStorage生命周期是永久，这意味着除非用户显示在浏览器提供的UI上清除localStorage信息，否则这些信息将永远存在。</p><p>sessionStorage仅在当前会话下有效，关闭页面或浏览器后被清除。</p></li><li><p>WebSocket</p></li></ol><h3 id="css3-新特性"><a href="#css3-新特性" class="headerlink" title="css3 新特性"></a>css3 新特性</h3><blockquote><p><a href="https://zhuanlan.zhihu.com/p/136700705">CSS3 有哪些新特性？CSS3 新特性详解</a></p></blockquote><p>1、圆角效果；2、图形化边界；3、块阴影与文字阴影；4、使用 RGBA 实现透明效果；5、渐变效果；6、使用“@Font-Face”实现定制字体；7、多背景图；8、文字或图像的变形处理；9、多栏布局；10、媒体查询等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1、颜色：新增RGBA、HSLA模式</span><br><span class="line">2、文字阴影：（text-shadow）</span><br><span class="line">3、边框：圆角（border-radius）边框阴影：box-shadow</span><br><span class="line">4、盒子模型：box-sizing</span><br><span class="line">5、背景：background-size,background-origin background-clip(削弱)</span><br><span class="line">6、渐变：linear-gradient(线性渐变):</span><br><span class="line">eg: background-image: linear-gradient(100deg, #237b9f, #f2febd);</span><br><span class="line">radial-gradient (径向渐变)</span><br><span class="line">7、过渡：transition可实现动画</span><br><span class="line">8、自定义动画： animate@keyfrom</span><br><span class="line">9、媒体查询：多栏布局@media screen and (width:800px)</span><br><span class="line">10、border-image</span><br><span class="line">11、2D转换:transform:translate(x,y) rotate(x,y)旋转 skew(x,y)倾斜 scale(x,y)缩放</span><br><span class="line">12、3D转换</span><br><span class="line">13、字体图标：Font-Face</span><br><span class="line">14、弹性布局：flex</span><br></pre></td></tr></table></figure><h3 id="css-选择器"><a href="#css-选择器" class="headerlink" title="css 选择器"></a>css 选择器</h3><p>id 选择器（ #myid）</p><p>类选择器（.myclassname）</p><p>标签选择器（div, h1, p）相邻选择器（h1 + p）</p><p>子选择器（ul &gt; li）后代选择器（li a）</p><p>属性选择器（a[rel = “external”]）</p><p>伪类选择器（a: hover, li:nth-child）</p><p>通配符选择器（ * ）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    !Important &gt; 行内式 &gt; id &gt; 类&#x2F;伪类&#x2F;属性 &gt; 标签选择器  &gt;  全局</span><br><span class="line">（对应权重：无穷大∞ &gt; 1000&gt; 100 &gt;  10        &gt;  1   &gt;      0）</span><br></pre></td></tr></table></figure><h3 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h3><p>一个盒子，会有 content,padding,border,margin 四部分，</p><p>标准的盒模型的宽高指的是 content 部分</p><p>ie 的盒模型的宽高包括了 content+padding+border</p><p>我们可以通过 box-sizing 修改盒模型，box-sizing <code>border-box</code> <code>content-box</code></p><h3 id="margin-合并"><a href="#margin-合并" class="headerlink" title="margin 合并"></a>margin 合并</h3><p>在垂直方向上的两个盒子，他们的 margin 会发生合并（会取最大的值），比如上边盒子设置<code>margin-bottom:20px</code>，下边盒子设置<code>margin-top:30px;</code>，那么两个盒子间的间距只有<code>30px</code>，不会是<code>50px</code></p><p>解决 margin 合并，我们可以给其中一个盒子套上一个父盒子，给父盒子设置 BFC</p><h3 id="margin-塌陷"><a href="#margin-塌陷" class="headerlink" title="margin 塌陷"></a>margin 塌陷</h3><p>效果： 一个父盒子中有一个子盒子，我们给子盒子设置<code>margin-top:xxpx</code>结果发现会带着父盒子一起移动（就效果和父盒子设置<code>margin-top:xxpx</code>的效果一样）</p><p>解决： 1、给父盒子设置 border，例如设置<code>border:1px solid red;</code> 2、给父盒子设置 BFC</p><h3 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h3><blockquote><p>块级格式化上下文 (block format context)</p></blockquote><p><strong>BFC 的布局规则</strong> *</p><ul><li>内部的 Box 会在垂直方向，一个接一个地放置。</li><li>Box 垂直方向的距离由 margin 决定。属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠。</li><li>每个盒子（块盒与行盒）的 margin box 的左边，与包含块 border box 的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。</li><li>BFC 的区域不会与 float box 重叠。</li><li>BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。</li><li>计算 BFC 的高度时，浮动元素也参与计算。</li></ul><p><strong>触发 BFC 的条件</strong> *</p><ul><li>根元素 html</li><li>float 的值不是 none。</li><li>position 的值 absoute、fixed</li><li>display 的值是 inline-block、table-cell、flex、table-caption 或者 inline-flex</li><li>overflow 的值不是 visible</li></ul><p><strong>解决什么问题</strong></p><ol><li><p>可以用来解决两栏布局<code>BFC 的区域不会与 float box 重叠</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: flet;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>解决 margin 塌陷和 margin 合并问题</p></li><li><p>解决浮动元素无法撑起父元素</p></li></ol><h3 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h3><blockquote><p>设为 Flex 布局以后，子元素的 float、clear 和 vertical-align 属性将失效</p><p>display:flex;</p><p>align-item:center;</p><p>justify-content:center;</p></blockquote><h3 id="什么是-rem、px、em-区别"><a href="#什么是-rem、px、em-区别" class="headerlink" title="什么是 rem、px、em 区别"></a>什么是 rem、px、em 区别</h3><blockquote><p>rem 是一个相对单位，<strong>rem 的是相对于 html 元素的字体大小</strong>，<strong>没有继承性</strong> （浏览器默认的大小） 16px</p><p>将网页等分成10份，html的字号为视窗的1/10  看视口宽度</p><p>@media (width:320px)  {  html { font-size :  32px}}  通过不断调节视窗宽度的 根据不同的视口来去设置不同的font-size</p><p>N*37.5  = 68px -&gt; N = 68/37.5</p><p>em 是一个相对单位，<strong>是相对于父元素字体大小有继承性</strong>  font-size 的大小有关系 如果父元素fs为20px 子元素的2em是40px</p><p>父元素没有的话去找根元素</p><p>px 是一个“绝对单位”，<strong>就是 css 中定义的像素</strong>，利用 px 设置字体大小及元素的宽高等，比较稳定和精确。</p></blockquote><h3 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h3><p><strong>响应式布局有哪些实现方式？什么是响应式设计？响应式设计的基本原理是什么？</strong></p><blockquote><p>1.百分比布局，但是无法对字体，边框等比例缩放</p><p>2.弹性盒子布局 display:flex</p><p>3.rem 布局，1rem=html 的 font-size 值的大小</p><ol start="4"><li>css3 媒体查询 @media screen and(max-width: 750px){}</li></ol><p>5.vw+vh  1vw : viewport width  = *<em>1/100 视口宽度**</em> 1vh：viewport height 1vh=  <strong>1/100视口高度</strong></p><p>.box { width : (68/3.75vw)}  <strong>只能要么都用vw 要么用vh</strong></p><p>6.使用一些框架（bootstrap，vant）</p><p>什么是响应式设计：响应式网站设计是一个网站能够兼容多个终端，智能地根据不同设备环境进行相对应的布局 </p><p>响应式设计的基本原理：基本原理是通过媒体查询检测不同的设备屏幕尺寸设置不同的 css 样式 页面头部必须有 meta 声明的</p></blockquote><h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><ul><li><p>两栏布局,左边定宽，右边自适应</p></li><li><p>三栏布局、圣杯布局、双飞翼布局</p><p>margin-left  = -100%  可以去到最左边  给外部一个padding 100px 用相对布局</p></li></ul><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220709200936520.png" alt="image-20220709200936520"></p><h3 id="水平垂直居中"><a href="#水平垂直居中" class="headerlink" title="水平垂直居中"></a>水平垂直居中</h3><p>方法一：给父元素设置成弹性盒子，子元素横向居中，纵向居中</p><p>方法二：父相子绝后，子部分向上移动本身宽度和高度的一半，也可以用 transfrom:translate(-50%,-50%)（最常用方法）</p><p>位移属性 translatex在x轴方向上进行移动，反之translatey实在y轴方向，而translate括号里的两个参数是先x后y的。</p><p>方法三：父相子绝，子元素所有定位为 0，margin 设置 auto 自适应</p><h3 id="iframe-有哪些缺点？"><a href="#iframe-有哪些缺点？" class="headerlink" title="iframe 有哪些缺点？"></a><strong>iframe</strong> <strong>有哪些缺点？</strong></h3><p>iframe 是一种框架，也是一种很常见的网页嵌入方 </p><p><strong>iframe 的优点：</strong> </p><ol><li>iframe 能够原封不动的把嵌入的网页展现出来。 </li><li>如果有多个网页引用 iframe，那么你只需要修改 iframe 的内容，就可以实现调用的每一个页面内容的更改，方便快捷。 </li><li>网页如果为了统一风格，头部和版本都是一样的，就可以写成一个页面，用 iframe 来嵌套，可以增加代码的可重用。 </li><li>如果遇到加载缓慢的第三方内容如图标和广告，这些问题可以由iframe 来解决。 </li></ol><p><strong>iframe 的缺点：</strong> </p><ol><li>会产生很多页面，不容易管理。 </li><li>iframe 框架结构有时会让人感到迷惑，如果框架个数多的话，可能会出现上下、左右滚动条，会分散访问者的注意力，用户体验度差。 </li><li>代码复杂，无法被一些搜索引擎索引到，这一点很关键，现在的搜索引擎爬虫还不能很好的处理 iframe 中的内容，所以使用 iframe 会不利于搜索引擎优化。 </li><li>很多的移动设备（PDA 手机）无法完全显示框架，设备兼容性差。 </li><li>iframe 框架页面会增加服务器的 http 请求，对于大型网站是不可取的。现在基本上都是用 Ajax 来代替 iframe，所以 iframe 已经渐渐的退出了前端开发。</li></ol><h3 id="link-import-导入-css"><a href="#link-import-导入-css" class="headerlink" title="link @import 导入 css"></a><strong>link @import</strong> <strong>导入</strong> <strong>css</strong></h3><blockquote><p>link 是 XHTML 标签，除了加载 CSS 外，还可以定义 RSS 等其他事务；<br>@import 属于 CSS 范畴，  只能加载 CSS。<br>link 引用 CSS 时，在页面载入时同时加载；@import 需要页面网页完全载入以后加载。link<br>无兼容问题；@import 是在 CSS2.1 提出的，低版本的浏览器不支持。<br>link 支持使用 Javascript 控制 DOM 去改变样式；而@import 不支持。</p></blockquote><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="DOM-事件机制-模型"><a href="#DOM-事件机制-模型" class="headerlink" title="DOM 事件机制/模型"></a>DOM 事件机制/模型</h3><blockquote><p>DOM0 级模型、IE 事件模型、DOM2 级事件模型</p></blockquote><p>就比如用户触发一个点击事件，有一个触发的过程</p><p>事件捕获-阶段（从上大小，从外到内）—&gt;处于目标事件-阶段—-&gt;事件冒泡-阶段（从下到上，从内到外）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(</span><br><span class="line">  <span class="string">&quot;click&quot;</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    event = event || <span class="built_in">window</span>.event <span class="comment">/*ie*/</span>;</span><br><span class="line">    <span class="keyword">const</span> target = event.target || event.srcElement; <span class="comment">/*ie*/</span> <span class="comment">// 拿到事件目标</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻止冒泡</span></span><br><span class="line">    <span class="comment">// event.stopPropagation()</span></span><br><span class="line">    <span class="comment">// event.cancelBubble=true; // ie</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻止默认事件</span></span><br><span class="line">    <span class="comment">// event.preventDefault();</span></span><br><span class="line">    <span class="comment">// event.returnValue=false; // ie</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">/* 是否使用捕获，默认是fasle, */</span> fasle</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/44f3f89d86344aacb901cd841620bbff~tplv-k3u1fbpfcp-watermark.awebp" alt="事件传播.jpeg"></p><h4 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h4><p>简介：事件委托指的是，不在事件的发生地（直接 dom）上设置监听函数，而是</p><p>在其父元素上设置监听函数，通过事件冒泡，父元素可以监听到子元素上事件的</p><p>触发，通过判断事件发生元素 DOM 的类型，来做出不同的响应。</p><p>举例：最经典的就是 ul 和 li 标签的事件监听，比如我们在添加事件时候，采用</p><p>事件委托机制，不会在 li 标签上直接添加，而是在 ul 父元素上添加。</p><p>好处：比较合适动态元素的绑定，新添加的子元素也会有监听函数，也可以有事</p><p>件触发机制</p><h3 id="如果需要手动写动画，你认为最小时间间隔是多久"><a href="#如果需要手动写动画，你认为最小时间间隔是多久" class="headerlink" title="如果需要手动写动画，你认为最小时间间隔是多久"></a>如果需要手动写动画，你认为最小时间间隔是多久</h3><blockquote><p>多数显示器默认频率是 60Hz，即 1 秒刷新 60 次，所以理论上最小间隔为 <code>1/60＊1000ms = 16.7ms </code></p></blockquote><h3 id="before和-after中双冒号和单冒号有什么区别"><a href="#before和-after中双冒号和单冒号有什么区别" class="headerlink" title="::before和:after中双冒号和单冒号有什么区别"></a>::before和:after中双冒号和单冒号有什么区别</h3><p>单冒号(:)用于 CSS3 伪类，双冒号(::)用于 CSS3 伪元素。 ::before 就是以一个子元素的存在，定义在元素主体内容之前的一个伪元素。并不存在于 dom 之中，只存在在页面之中。 :before 和 :after 这两个伪元素，是在 CSS2.1 里新出现的。起初，伪元素的前缀使用的是单 冒号语法，但随着 Web 的进化，在 CSS3 的规范里，伪元素的语法被修改成使用双冒号，成 为::before ::after</p><h3 id="CSS-sprites-精灵图"><a href="#CSS-sprites-精灵图" class="headerlink" title="CSS sprites 精灵图"></a>CSS sprites 精灵图</h3><p>CSS Sprites 其实就是把网页中一些背景图片整合到一张图片文件中，再利用 CSS 的 <code>“background-image”，“ background-repeat ”，“ background-position”</code> 的 组 合 进 行 背 景 定 位 ， background-position 可以用数字能精确的定位出背景图片的位置。这样可以减少很多图片请 求的开销，因为请求耗时比较长；请求虽然可以并发，但是也有限制，一般浏览器都是 6 个</p><h3 id="重排和重绘"><a href="#重排和重绘" class="headerlink" title="重排和重绘"></a>重排和重绘</h3><p>重绘（repaint 或 redraw）：当盒子的位置、大小以及其他属性，例如颜色、字 体大小等都确定下来之后，浏览器便把这些原色都按照各自的特性绘制一遍，将内容呈现在页面上。重绘是指一个元素外观的改变所触发的浏览器行为，浏览器 会根据元素的新属性重新绘制，使元素呈现新的外观。<br>触发重绘的条件：改变元素外观属性。如：color，background-color 等。 注意：table 及其内部元素可能需要多次计算才能确定好其在渲染树中节点的属性值，比同等元素要多花两倍时间，这就是我们尽量避免使用 table 布局页面的 原因之一。<br>重排（重构/回流/reflow）：当渲染树中的一部分(或全部)因为元素的规模尺寸， 布局，隐藏等改变而需要重新构建, 这就称为回流(reflow)。每个页面至少需要 一次回流，就是在页面第一次加载的时候。<br>重绘和重排的关系：在回流的时候，浏览器会使渲染树中受到影响的部分失效， 并重新构造这部分渲染树，完成回流后，浏览器会重新绘制受影响的部分到屏幕 中，该过程称为重绘。所以，重排必定会引发重绘，但重绘不一定会引发重排。</p><h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><h3 id="RegExp"><a href="#RegExp" class="headerlink" title=".RegExp"></a>.RegExp</h3><p>正则表达式，通过正则表达式来进行匹配相对应的字符串</p><h3 id="js-数据类型"><a href="#js-数据类型" class="headerlink" title="js 数据类型"></a>js 数据类型</h3><p>8 中, <code>ES6</code>出的 <code>Symbol BigInt</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">基本类型 Number String Boolean undefined null </span><br><span class="line">引用类型 Object Symbol BigInt</span><br></pre></td></tr></table></figure><h3 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h3><p>ES6引入了一种新的<code>原始数据类型Symbol</code>，表示独一无二的值。</p><p>都是独一无二的，可以保证不会与其他属性名产生冲突。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(s1 === s2)</span><br><span class="line"><span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sym = <span class="built_in">Symbol</span>(<span class="string">&#x27;My symbol&#x27;</span>);</span><br><span class="line"><span class="string">&quot;your symbol is &quot;</span> + sym</span><br><span class="line"><span class="comment">// TypeError: can&#x27;t convert symbol to string</span></span><br><span class="line"><span class="string">`your symbol is <span class="subst">$&#123;sym&#125;</span>`</span></span><br><span class="line"><span class="comment">// TypeError: can&#x27;t convert symbol to string</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Symbol</span>值不能与其它类型的值进行运算，会报错。</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">mySymbol:<span class="string">&quot;name&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line">a[mySymbol] = <span class="string">&#x27;Hello!&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>js 的基本数据类型和复杂数据类型的区别（在堆和栈中，赋值时的不同,一个拷贝值一个拷贝地址）</p><p><strong>基本类型和引用类型在内存上存储的区别</strong></p><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/89b70c934a0f436d90364287d706971a~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p><strong>null 与 undefined 的异同</strong></p><p><strong>相同点：</strong></p><ul><li>Undefined 和 Null 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 undefined 和 null</li></ul><p><strong>不同点：</strong></p><ul><li><p>null 转换成数字是 0, undefined 转换数字是<code>NaN</code></p></li><li><p>undefined 代表的含义是未定义， null 代表的含义是空对象。</p></li><li><p>typeof null 返回’object’，typeof undefined 返回’undefined’</p></li><li><p>```js<br>null == undefined; // true<br>null === undefined; // false</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 其实 null 不是对象，虽然 typeof null 会输出 object，但是这只是 JS 存在的一个悠久 Bug。在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象，然而 null 表示为全零，所以将它错误的判断为 object 。虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来。</span><br><span class="line"></span><br><span class="line">**说说 JavaScript 中判断数据类型的几种方法**</span><br><span class="line"></span><br><span class="line">**typeof**</span><br><span class="line"></span><br><span class="line">- &#96;typeof&#96;一般用来判断基本数据类型，**除了判断 null 会输出&quot;object&quot;，其它都是正确的**</span><br><span class="line">- &#96;typeof&#96;判断引用数据类型时，**除了判断函数会输出&quot;function&quot;,其它都是输出&quot;object&quot;**</span><br><span class="line"></span><br><span class="line">**instanceof**</span><br><span class="line"></span><br><span class="line">&gt; Instanceof 可以准确的判断引用数据类型，它的原理是检测构造函数的&#96;prototype&#96;属性是否在某个实例对象的原型链上， 不能判断基本数据类型</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;js</span><br><span class="line">&#x2F;&#x2F; instanceof 的实现</span><br><span class="line">function instanceofOper(left, right) &#123;</span><br><span class="line">  const prototype &#x3D; right.prototype;</span><br><span class="line">  while (left) &#123;</span><br><span class="line">    if ((left &#x3D; left.__proto__) &#x3D;&#x3D;&#x3D; prototype) &#123;</span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; let obj  &#x3D; &#123;&#125;</span><br><span class="line">&#x2F;&#x2F; Object.getPrototypeOf(obj) &#x3D;&#x3D;&#x3D; obj.__proto__ &#x3D;&#x3D;&gt; true</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现 instanceof 2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myInstanceof</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这里先用typeof来判断基础数据类型，如果是，直接返回false</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> left !== <span class="string">&quot;object&quot;</span> || left === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">// getProtypeOf是Object对象自带的API，能够拿到参数的原型对象</span></span><br><span class="line">  <span class="keyword">let</span> proto = <span class="built_in">Object</span>.getPrototypeOf(left);</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (proto === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (proto === right.prototype) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//找到相同原型对象，返回true</span></span><br><span class="line">    proto = <span class="built_in">Object</span>.getPrototypeof(proto);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>Object.prototype.toString.call()</strong> 返回 <code>[object Xxxx]</code> 都能判断</p><h3 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">b</span>: <span class="string">&quot;xxx&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> arr = [&#123; <span class="attr">a</span>: <span class="string">&quot;ss&quot;</span> &#125;, obj, <span class="number">333</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值</span></span><br><span class="line"><span class="keyword">let</span> arr2 = arr;</span><br><span class="line"><span class="comment">// 浅拷贝-只拷贝了一层，深层次的引用还是存在</span></span><br><span class="line"><span class="comment">// Object.assign(), ...扩展运算符，slice等</span></span><br><span class="line"><span class="keyword">let</span> arr2 = arr.slice();</span><br><span class="line"><span class="keyword">let</span> arr2 = [...arr];</span><br><span class="line">obj.b = <span class="string">&quot;222&quot;</span>; <span class="comment">// arr2[1].b =&gt; 222</span></span><br><span class="line"><span class="comment">// arr[2] = 4444 ==&gt; arr2[2] ===&gt; 333</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 深拷贝</span></span><br><span class="line"><span class="comment">// 1. 最简单的，JSON.stringify，但这个有问题，看下面有说明</span></span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(arr));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 自己封装，要递归处理</span></span><br></pre></td></tr></table></figure><p>实现深拷贝-简单版</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj, map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!obj &amp;&amp; <span class="keyword">typeof</span> obj !== <span class="string">&quot;object&quot;</span>) <span class="keyword">return</span> obj;</span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">Date</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(obj);</span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">RegExp</span>(obj.source, obj.flags);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (map.get(obj)) &#123;</span><br><span class="line">    <span class="comment">//  如果有循环引用、就返回这个对象</span></span><br><span class="line">    <span class="keyword">return</span> map.get(obj);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> cloneObj = obj.constructor(); <span class="comment">// 数组的就是[],对象就是&#123;&#125;</span></span><br><span class="line"></span><br><span class="line">  map.set(obj, cloneObj); <span class="comment">// 缓存对象，用于循环引用的情况</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">      cloneObj[key] = deepClone(obj[key], map);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> cloneObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JSON-stringify-问题"><a href="#JSON-stringify-问题" class="headerlink" title="JSON.stringify 问题"></a><code>JSON.stringify</code> 问题</h3><ol><li><p>如果有循环引用就报错</p><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/c224a6d165a14d969c014170533c13dd.png" alt="img"></p></li><li><p><code>Symbol</code>、<code>function</code>、<code>undefined</code>会丢失</p></li><li><p><code>布尔值</code>、<code>数字</code>、<code>字符串</code>的包装对象会转换成原始值</p></li><li><p><code>NaN</code>、<code>Infinity</code> 变成 <code>null</code></p></li><li><p><code>Date</code>类型的日期会变成字符串</p></li><li><p><code>RegExp</code>、<code>Error</code>被转换成了空对象 <code>&#123;&#125;</code></p></li></ol><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/53927bb12f094d69b84298c445e4d088.png" alt="img"></p><h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><ul><li><p><code>commonjs</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由nodejs实现</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>); <span class="comment">// 引入</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;&#125;;</span><br></pre></td></tr></table></figure></li><li><p>ESM</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由es6实现</span></span><br><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">&quot;jquery&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> $;</span><br></pre></td></tr></table></figure></li><li><p>AMD（异步加载模块）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由RequireJS实现</span></span><br><span class="line">define([<span class="string">&quot;juqery&quot;</span>, <span class="string">&quot;vue&quot;</span>], <span class="function"><span class="keyword">function</span> (<span class="params">$, Vue</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 依赖必须一开始就写好</span></span><br><span class="line">  $(<span class="string">&quot;#app&quot;</span>);</span><br><span class="line">  <span class="keyword">new</span> Vue(&#123;&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>CMD</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由SeaJS 实现</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">&quot;./a&quot;</span>);</span><br><span class="line">  a.doSomething();</span><br><span class="line">  <span class="comment">// ....</span></span><br><span class="line">  <span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">&quot;./b&quot;</span>); <span class="comment">// 依赖可以就近书写</span></span><br><span class="line">  b.doSomething();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>UMD (通用加载模块)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">global</span>, factory</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">typeof</span> <span class="built_in">exports</span> === <span class="string">&#x27;object&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">module</span> !== <span class="string">&#x27;undefined&#x27;</span> ? <span class="built_in">module</span>.exports = factory() :</span><br><span class="line">  <span class="keyword">typeof</span> define === <span class="string">&#x27;function&#x27;</span> &amp;&amp; define.amd ? define(factory) :</span><br><span class="line">  (<span class="built_in">global</span> = <span class="built_in">global</span> || self, <span class="built_in">global</span>.Vue = factory());</span><br><span class="line">&#125;(<span class="built_in">this</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="string">&#x27;use strict&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="AMD-异步模块定义-和-CMD-通用模块定义-的区别有哪些"><a href="#AMD-异步模块定义-和-CMD-通用模块定义-的区别有哪些" class="headerlink" title="AMD 异步模块定义  和 CMD 通用模块定义 的区别有哪些"></a>AMD 异步模块定义  和 CMD 通用模块定义 的区别有哪些</h4></li></ul><blockquote><p><a href="https://blog.csdn.net/qq_38912819/article/details/80597101">https://blog.csdn.net/qq_38912819/article/details/80597101</a></p></blockquote><ol><li>对于依赖的模块，AMD 是<strong>提前执行</strong>，CMD 是<strong>延迟执行</strong>。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）</li><li>CMD 推崇<strong>依赖就近</strong>，AMD 推崇<strong>依赖前置</strong></li></ol><h4 id="CommonJS-与-ES6-Module-的差异"><a href="#CommonJS-与-ES6-Module-的差异" class="headerlink" title="CommonJS 与 ES6 Module 的差异"></a>CommonJS 与 ES6 Module 的差异</h4><p><strong>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</strong></p><ul><li>CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。</li><li>ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令<code>import</code>，就会生成一个只读<strong>引用</strong>。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的<code>import</code>有点像 Unix 系统的“符号连接”，原始值变了，<code>import</code>加载的值也会跟着变。因此，ES6 模块是<strong>动态引用</strong>，并且不会<strong>缓存值</strong>，模块里面的变量绑定其所在的模块。</li></ul><p><strong>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</strong></p><ul><li>运行时加载: CommonJS 模块就是对象；即在输入时是先<strong>加载整个模块</strong>，<strong>生成一个对象</strong>，然后再从这个对象上面读取方法，这种加载称为“<strong>运行时加载</strong>”。</li><li>编译时加载: ES6 模块不是对象，而是通过 <code>export</code> 命令显式指定输出的代码，<code>import</code>时采用静态命令的形式。即在<code>import</code>时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。</li></ul><p><strong>CommonJS 加载的是一个对象（即 module.exports 属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</strong></p><h3 id="JS-延迟加载的方式"><a href="#JS-延迟加载的方式" class="headerlink" title="JS 延迟加载的方式"></a>JS 延迟加载的方式</h3><p>JavaScript 会阻塞 DOM 的解析，因此也就会阻塞 DOM 的加载。所以有时候我们希望延迟 JS 的加载来提高页面的加载速度。</p><ul><li>把 JS 放在页面的最底部</li><li>script 标签的 defer 属性：脚本会立即下载但延迟到整个页面加载完毕再执行。该属性对于内联脚本无作用 (即没有 <strong>「src」</strong> 属性的脚本）。</li><li>Async 是在外部 JS 加载完成后，浏览器空闲时，Load 事件触发前执行，标记为 async 的脚本并不保证按照指定他们的先后顺序执行，该属性对于内联脚本无作用 (即没有 <strong>「src」</strong> 属性的脚本）。</li><li>动态创建 script 标签，监听 dom 加载完毕再引入 js 文件</li></ul><h3 id="call、apply-、bind"><a href="#call、apply-、bind" class="headerlink" title="call、apply 、bind"></a>call、apply 、bind</h3><blockquote><p>call，apply, bind 都是改变 this 指向，bind 不会立即执行，会返回的是一个绑定 this 的新函数</p><p><a href="https://juejin.cn/post/6844903728147857415">面试官问：能否模拟实现 JS 的 call 和 apply 方法</a></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">obj.call(<span class="built_in">this</span>指向, 参数<span class="number">1</span>， 参数<span class="number">2</span>)</span><br><span class="line">obj.apply(<span class="built_in">this</span>指向, [参数<span class="number">1</span>， 参数<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>, age)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj = &#123;<span class="attr">name</span>:<span class="string">&#x27;&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">const</span> result = fn.bind(obj) <span class="comment">// bind会返回一个新的函数</span></span><br><span class="line">result(<span class="number">20</span>)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现一个 apply</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">  context = context || <span class="built_in">window</span>;</span><br><span class="line">  <span class="keyword">const</span> fn = <span class="built_in">Symbol</span>();</span><br><span class="line">  context[fn] = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">var</span> res = context[fn](...arguments[<span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">delete</span> context[fn];</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>实现一个 bind</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最终版 删除注释 详细注释版请看上文</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.bind =</span><br><span class="line">  <span class="built_in">Function</span>.prototype.bind ||</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bind</span>(<span class="params">thisArg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="built_in">this</span> + <span class="string">&quot; must be a function&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">var</span> bound = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> boundArgs = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">      <span class="keyword">var</span> finalArgs = args.concat(boundArgs);</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span> <span class="keyword">instanceof</span> bound) &#123;</span><br><span class="line">        <span class="keyword">if</span> (self.prototype) &#123;</span><br><span class="line">          <span class="function"><span class="keyword">function</span> <span class="title">Empty</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">          Empty.prototype = self.prototype;</span><br><span class="line">          bound.prototype = <span class="keyword">new</span> Empty();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> result = self.apply(<span class="built_in">this</span>, finalArgs);</span><br><span class="line">        <span class="keyword">var</span> isObject = <span class="keyword">typeof</span> result === <span class="string">&quot;object&quot;</span> &amp;&amp; result !== <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">var</span> isFunction = <span class="keyword">typeof</span> result === <span class="string">&quot;function&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (isObject || isFunction) &#123;</span><br><span class="line">          <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> self.apply(thisArg, finalArgs);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> bound;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><h3 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a><a name="debounce">防抖</a></h3><blockquote><p>debounce 所谓防抖，就是指触发<strong>事件后在 n 秒内函数只能执行一次</strong>，<strong>如果在 n 秒内又触发了事件，则会重新计算函数执行时间。</strong></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait, immediate</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timeout;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> context = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">const</span> args = [...arguments];</span><br><span class="line">    <span class="keyword">if</span> (timeout) <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">    <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">      <span class="keyword">const</span> callNow = !timeout;</span><br><span class="line">      timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        timeout = <span class="literal">null</span>;</span><br><span class="line">      &#125;, wait);</span><br><span class="line">      <span class="keyword">if</span> (callNow) func.apply(context, args);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        func.apply(context, args);</span><br><span class="line">      &#125;, wait);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a><a name="throttle">节流</a></h3><blockquote><p>就是指连续触发事件但是在 <strong>n 秒中只执行一次函数</strong></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> pre = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> now = <span class="built_in">Date</span>.now();</span><br><span class="line">    <span class="keyword">if</span> (now - pre &gt;= wait) &#123;</span><br><span class="line">      fn.apply(<span class="built_in">this</span>, args);</span><br><span class="line">      pre = now;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包是指有权访问另一个函数作用域中的变量的函数 ——《JavaScript 高级程序设计》</p><p>当函数可以记住并访问所在的词法作用域时，就产生了闭包，</p><p>即使函数是在当前词法作用域之外执行 ——《你不知道的 JavaScript》</p><ul><li>闭包用途：<ol><li>能够访问函数定义时所在的词法作用域(阻止其被回收)</li><li>私有化变量</li><li>模拟块级作用域</li><li>创建模块</li></ol></li><li>闭包缺点：会导致函数的变量一直保存在内存中，过多的闭包可能会导致内存泄漏</li></ul><h3 id="原型、原型链-高频"><a href="#原型、原型链-高频" class="headerlink" title="原型、原型链(高频)"></a>原型、原型链(高频)</h3><p><strong>原型:</strong> 对象中固有的<code>__proto__</code>属性，该属性指向对象的<code>prototype</code>原型属性。</p><p><strong>原型链:</strong> 当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是<code>Object.prototype</code>所以这就是我们新建的对象为什么能够使用<code>toString()</code>等方法的原因。</p><p><strong>特点:</strong> <code>JavaScript</code>对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。</p><h3 id="this-指向、new-关键字"><a href="#this-指向、new-关键字" class="headerlink" title="this 指向、new 关键字"></a>this 指向、new 关键字</h3><p><code>this</code>对象是是执行上下文中的一个属性，它指向最后一次调用这个方法的对象，在全局函数中，<code>this</code><strong>等于</strong><code>window</code>，而当函数被作为某个对象调用时，this 等于那个对象。 在实际开发中，<code>this </code>的指向可以通过四种调用模式来判断。</p><ol><li>函数调用，当一个函数不是一个对象的属性时，直接作为函数来调用时，<code>this</code>指向全局对象。</li><li>方法调用，如果一个函数作为一个对象的方法来调用时，<code>this</code>指向这个对象。</li><li>构造函数调用，<code>this</code>指向这个用<code>new</code>新创建的对象。</li><li>第四种是 <code>apply 、 call 和 bind </code>调用模式，这三个方法都可以显示的指定调用函数的 this 指向。<code>apply</code>接收参数的是数组，<code>call</code>接受参数列表，`` bind<code>方法通过传入一个对象，返回一个</code>this<code>绑定了传入对象的新函数。这个函数的 </code>this<code>指向除了使用</code>new `时会被改变，其他情况下都不会改变。</li></ol><p><strong>new</strong></p><blockquote><p><a href="https://juejin.cn/post/6844903704663949325">面试官问：能否模拟实现 JS 的 new 操作符</a></p></blockquote><ol><li>首先创建了一个新的空对象</li><li>设置原型，将对象的原型设置为函数的<code>prototype</code>对象。</li><li>让函数的<code>this</code>指向这个对象，执行构造函数的代码（为这个新对象添加属性）</li><li>判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// new 操作符的实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">newOperator</span>(<span class="params">ctor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> ctor !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&quot;newOperator function the first param must be a function&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  newOperator.target = ctor;</span><br><span class="line">  <span class="keyword">var</span> newObj = <span class="built_in">Object</span>.create(ctor.prototype);</span><br><span class="line">  <span class="keyword">var</span> argsArr = [].slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">var</span> ctorReturnResult = ctor.apply(newObj, argsArr);</span><br><span class="line">  <span class="keyword">var</span> isObject =</span><br><span class="line">    <span class="keyword">typeof</span> ctorReturnResult === <span class="string">&quot;object&quot;</span> &amp;&amp; ctorReturnResult !== <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">var</span> isFunction = <span class="keyword">typeof</span> ctorReturnResult === <span class="string">&quot;function&quot;</span>;</span><br><span class="line">  <span class="keyword">if</span> (isObject || isFunction) &#123;</span><br><span class="line">    <span class="keyword">return</span> ctorReturnResult;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="作用域、作用域链、变量提升"><a href="#作用域、作用域链、变量提升" class="headerlink" title="作用域、作用域链、变量提升"></a>作用域、作用域链、变量提升</h3><p><code>作用域</code>负责收集和维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。(全局作用域、函数作用域、块级作用域)。 作用域链就是从当前作用域开始一层一层向上寻找某个变量，直到找到全局作用域还是没找到，就宣布放弃。这种一层一层的关系，就是<code>作用域链</code>。</p><h3 id="继承-含-es6-、多种继承方式"><a href="#继承-含-es6-、多种继承方式" class="headerlink" title="继承(含 es6)、多种继承方式"></a>继承(含 es6)、多种继承方式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 属性</span></span><br><span class="line">  <span class="built_in">this</span>.name = name || <span class="string">&quot;Animal&quot;</span>;</span><br><span class="line">  <span class="comment">// 实例方法</span></span><br><span class="line">  <span class="built_in">this</span>.sleep = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&quot;正在睡觉！&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原型方法</span></span><br><span class="line">Animal.prototype.eat = <span class="function"><span class="keyword">function</span> (<span class="params">food</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&quot;正在吃：&quot;</span> + food);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>（1）第一种是以<code>原型链的方式来实现继承</code>，但是这种实现方式存在的缺点是，在包含有引用类型的数据时，会被所有的实例对象所共享，容易造成修改的混乱。还有就是在创建子类型的时候不能向超类型传递参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原型链继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Cat.prototype = <span class="keyword">new</span> Animal(<span class="string">&quot;小黄&quot;</span>); <span class="comment">// 缺点 无法实现多继承 来自原型对象的所有属性被所有实例共享</span></span><br><span class="line">Cat.prototype.name = <span class="string">&quot;cat&quot;</span>;</span><br></pre></td></tr></table></figure><p>（2）第二种方式是使用<code>借用构造函数</code>的方式，这种方式是通过在子类型的函数中调用超类型的构造函数来实现的，这一种方法解决了不能向超类型传递参数的缺点，但是它存在的一个问题就是无法实现函数方法的复用，并且超类型原型定义的方法子类型也没有办法访问到。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 借用构造函数继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  Animal.call(<span class="built_in">this</span>, <span class="string">&quot;小黄&quot;</span>);</span><br><span class="line">  <span class="comment">// 缺点 只能继承父类实例的属性和方法，不能继承原型上的属性和方法。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）第三种方式是<code>组合继承</code>，组合继承是将原型链和借用构造函数组合起来使用的一种方式。通过借用构造函数的方式来实现类型的属性的继承，通过将子类型的原型设置为超类型的实例来实现方法的继承。这种方式解决了上面的两种模式单独使用时的问题，但是由于我们是以超类型的实例来作为子类型的原型，所以调用了两次超类的构造函数，造成了子类型的原型中多了很多不必要的属性。</p><p>（4）第四种方式是<code>原型式继承</code>，原型式继承的主要思路就是基于已有的对象来创建新的对象，实现的原理是，向函数中传入一个对象，然后返回一个以这个对象为原型的对象。这种继承的思路主要不是为了实现创造一种新的类型，只是对某个对象实现一种简单继承，ES5 中定义的 Object.create() 方法就是原型式继承的实现。缺点与原型链方式相同。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  F.prototype = o;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（5）第五种方式是<code>寄生式继承</code>，寄生式继承的思路是创建一个用于封装继承过程的函数，通过传入一个对象，然后复制一个对象的副本，然后对象进行扩展，最后返回这个对象。这个扩展的过程就可以理解是一种继承。这种继承的优点就是对一个简单对象实现继承，如果这个对象不是我们的自定义类型时。缺点是没有办法实现函数的复用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">original</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> clone = object(original); <span class="comment">//通过调用object函数创建一个新对象</span></span><br><span class="line">  clone.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//以某种方式来增强这个对象</span></span><br><span class="line">    alert(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> clone; <span class="comment">//返回这个对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（6）第六种方式是<code>寄生式组合继承</code>，组合继承的缺点就是使用超类型的实例做为子类型的原型，导致添加了不必要的原型属性。寄生式组合继承的方式是使用超类型的原型的副本来作为子类型的原型，这样就避免了创建不必要的属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">subClass, superClass</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> prototype = object(superClass.prototype); <span class="comment">//创建对象</span></span><br><span class="line">  prototype.constructor = subClass; <span class="comment">//增强对象</span></span><br><span class="line">  subClass.prototype = prototype; <span class="comment">//指定对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>大家都知道 JS 中在使用运算符号或者对比符时，会自带隐式转换，规则如下:</p><p>-、*、/、% ：一律转换成数值后计算</p><p>+：</p><ul><li><p>数字 + 字符串 = 字符串， 运算顺序是从左到右</p></li><li><p>数字 + 对象， 优先调用对象的 valueOf -&gt; toString</p></li><li><p>数字 + boolean/null -&gt; 数字</p></li><li><p>数字 + undefined -&gt; NaN</p></li><li><p>[1].toString() === ‘1’ 内部调用 .join 方法</p></li><li><p>{}.toString() === ‘[object object]’</p></li><li><p>NaN ! == NaN   两个并不相等、+undefined   为 NaN</p></li></ul><h3 id="Object-is-与比较操作符-、-的区别？"><a href="#Object-is-与比较操作符-、-的区别？" class="headerlink" title="Object.is()与比较操作符==、===的区别？"></a>Object.is()与比较操作符<code>==</code>、<code>===</code>的区别？</h3><ul><li><code>==</code>会先进行类型转换再比较</li><li><code>===</code>比较时不会进行类型转换，类型不同则直接返回 false</li><li><code>Object.is()</code>在<code>===</code>基础上特别处理了<code>NaN</code>,<code>-0</code>,<code>+0</code>,保证-0 与+0 不相等，但 NaN 与 NaN 相等</li></ul><h4 id="操作符的强制类型转换规则"><a href="#操作符的强制类型转换规则" class="headerlink" title="==操作符的强制类型转换规则"></a><code>==</code>操作符的强制类型转换规则</h4><ul><li>字符串和数字之间的相等比较，将字符串转换为数字之后再进行比较。</li><li>其他类型和布尔类型之间的相等比较，先将布尔值转换为数字后，再应用其他规则进行比较。</li><li>null 和 undefined 之间的相等比较，结果为真。其他值和它们进行比较都返回假值。</li><li>对象和非对象之间的相等比较，对象先调用 ToPrimitive 抽象操作后，再进行比较。</li><li>如果一个操作值为 NaN ，则相等比较返回 false（ NaN 本身也不等于 NaN ）。</li><li>如果两个操作值都是对象，则比较它们是不是指向同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回 true，否则，返回 false。</li></ul><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/d5175667072fe77e2182f89306bcdb77.webp" alt="img"></p><h3 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h3><ol><li>新增 <strong>Symbol</strong> 类型 表示独一无二的值，用来定义独一无二的对象属性名;</li><li><strong>const/let</strong> 都是用来<strong>声明变量, ** **不可重复声明</strong>，具有块级作用域。存在暂时性死区，不存在变量提升。(const 一般用于声明常量);</li><li>变量的解构赋值(包含数组、对象、字符串、数字及布尔值,函数参数),剩余运算符(…rest);</li><li>模板字符串(<code>$&#123;data&#125;</code>);</li><li><code>...</code>扩展运算符(数组、对象);;</li><li>箭头函数;</li><li>Set 和 Map 数据结构;</li><li>Proxy/Reflect;</li><li><strong>Promise;</strong></li><li><strong>async</strong> 函数;</li><li>Class;</li><li><strong>Module 语法(import/export)。</strong></li></ol><h3 id="let-const"><a href="#let-const" class="headerlink" title="let/const"></a>let/const</h3><blockquote><p><code>const</code>声明一个只读的常量。一旦声明，常量的值就不能改变 <a href="https://es6.ruanyifeng.com/#docs/let">https://es6.ruanyifeng.com/#docs/let</a></p></blockquote><p>var 在全局作用域中声明的变量会变成全局变量</p><p>let、const 和 var 的区别</p><ul><li><p>不允许重复声明</p></li><li><p>不存在变量提升</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// var 的情况</span></span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// 输出undefined</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// let 的情况</span></span><br><span class="line"><span class="built_in">console</span>.log(bar); <span class="comment">// 报错ReferenceError</span></span><br><span class="line"><span class="keyword">let</span> bar = <span class="number">2</span>;</span><br></pre></td></tr></table></figure></li><li><p>暂时性死区（不能在未声明之前使用）</p><blockquote><p>注意暂时性死区和不存在变量提升不是同一个东西</p></blockquote><p>只要块级作用域内存在<code>let</code>命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="number">123</span>; <span class="comment">// 声明了 tmp</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  tmp = <span class="string">&quot;abc&quot;</span>; <span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="keyword">let</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>块级作用域：用 let 和 const 声明的变量，在这个块中会形成块级作用域</p><p><strong>es5 只有函数作用域和全局作用域</strong></p><p>IIFE <code>立即执行函数表达式</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IIFE 写法</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> tmp = ...;</span><br><span class="line">  ...</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 块级作用域写法</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> tmp = ...;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br></pre></td></tr></table></figure><h3 id="ES6-的一些叫法"><a href="#ES6-的一些叫法" class="headerlink" title="ES6 的一些叫法"></a>ES6 的一些叫法</h3></li><li><p>reset 参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">...values</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> val <span class="keyword">of</span> values) &#123;</span><br><span class="line">    sum += val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure></li><li><p>扩展运算符</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(...[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="comment">// 1 2 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b = &#123; ...&#123; <span class="attr">a</span>: <span class="string">&quot;2&quot;</span>, <span class="attr">b</span>: <span class="string">&quot;3&quot;</span> &#125; &#125;;</span><br></pre></td></tr></table></figure></li><li><p><code>?.</code> 可选链运算符</p><blockquote><p>左侧的对象是否为<code>null</code>或<code>undefined</code>。如果是的，就不再往下运算，而是返回<code>undefined</code></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a?.b;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">a == <span class="literal">null</span> ? <span class="literal">undefined</span> : a.b;</span><br><span class="line"><span class="comment">// 注意 undefined == null ==&gt; true</span></span><br></pre></td></tr></table></figure></li><li><p><code>??</code> Null 判断运算符</p></li></ul><blockquote><p><a href="https://es6.ruanyifeng.com/#docs/operator#Null-%E5%88%A4%E6%96%AD%E8%BF%90%E7%AE%97%E7%AC%A6">https://es6.ruanyifeng.com/#docs/operator#Null-%E5%88%A4%E6%96%AD%E8%BF%90%E7%AE%97%E7%AC%A6</a></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> headerText = response.settings.headerText ?? <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> animationDuration = response.settings.animationDuration ?? <span class="number">300</span>;</span><br><span class="line"><span class="keyword">const</span> showSplashScreen = response.settings.showSplashScreen ?? <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>但左侧的为 <code>undefined</code>或者<code>null</code>是就返回右边的，否则就直接返回左边的</p><h3 id="箭头函数和普通函数的区别"><a href="#箭头函数和普通函数的区别" class="headerlink" title="箭头函数和普通函数的区别"></a>箭头函数和普通函数的区别</h3><ol><li>箭头函数没有<code>this</code>，<code>this</code>是继承于当前的上下文，不能通过<code>call</code>,<code>apply</code>,<code>bind</code>去改变 this</li><li>箭头函数没有自己的 <code>arguments</code> 对象，但是可以访问外围函数的 <code>arguments </code>对象</li><li>不能通过<code> new</code> 关键字调用(不能作为构造函数)，同样也没有 <code>new.target</code> 和原型</li></ol><h3 id="如何解决异步回调地狱"><a href="#如何解决异步回调地狱" class="headerlink" title="如何解决异步回调地狱"></a><strong>如何解决异步回调地狱</strong></h3><p>promise、generator、async/await</p><h3 id="mouseover-和-mouseenter-的区别"><a href="#mouseover-和-mouseenter-的区别" class="headerlink" title="mouseover 和 mouseenter 的区别"></a><strong>mouseover</strong> <strong>和</strong> <strong>mouseenter</strong> <strong>的区别</strong></h3><p>mouseover：当<strong>鼠标移入元素或其子元素</strong>都会触发事件，所以有一个<strong>重复触发</strong>， </p><p><strong>冒泡</strong>的过程。对应的移除事件是 mouseout </p><p>mouseenter：当鼠标<strong>移除元素本身</strong>（不包含元素的子元素）会触发事件，也就是 </p><p>不会冒泡，对应的移除事件是 mouseleave </p><h3 id="setTimeout、setInterval-和-requestAnimationFrame-之间的区别"><a href="#setTimeout、setInterval-和-requestAnimationFrame-之间的区别" class="headerlink" title="setTimeout、setInterval 和 requestAnimationFrame 之间的区别"></a>setTimeout、setInterval 和 requestAnimationFrame 之间的区别</h3><p>与 setTimeout 和 setInterval 不同，requestAnimationFrame 不需要设置时间 间隔， 大多数电脑显示器的刷新频率是 60Hz，大概相当于每秒钟重绘 60 次。大多数浏 览器都会对重绘操作加以限制，不超过显示器的重绘频率，因为即使超过那个频 率用户体验也不会有提升。因此，最平滑动画的最佳循环间隔是 1000ms/60，约 等于 16.6ms。 RAF 采用的是系统时间间隔，不会因为前面的任务，不会影响 RAF，但是如果前 面的任务多的话，会响应 setTimeout 和 setInterval 真正运行时的时间间隔。 特点：</p><p>（1）requestAnimationFrame 会把<strong>每一帧中</strong>的<strong>所有 DOM 操作</strong>集中起来，在一次<strong>重绘或回流中</strong>就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率。<br>（2）在<strong>隐藏或不可见</strong>的元素中，requestAnimationFrame 将不会进行重绘或回流，这当然就意味着更少的CPU、GPU 和内存使用量<br>（3）requestAnimationFrame 是由浏览器专门为动画提供的 API，在运行时浏览 器会自动优化方法的调用，并且如果页面不是激活状态下的话，动画会自动暂停， 有效节省了 CPU 开销。 </p><h2 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h2><p>vue2 是通过<code>Object.defineProperty</code>来实现响应式的，所以就会有一些缺陷</p><ol><li>当修改一个对象的某个键值属性时，当这个键值没有在这个对象中，vue 不能做响应式处理</li><li>但直接修改数组的某一项（<code>arr[index]=&#39;xxx&#39;</code>）vue 不能做响应式处理</li></ol><p>可用下面的解决响应式</p><ol><li>Vue.set ==&gt; this.$set(对象\数组， key 值、index， value)</li><li>修改数组<code>length</code>, 调用数据的 <code>splice</code> 方法</li></ol><h3 id="vue-生命周期"><a href="#vue-生命周期" class="headerlink" title="vue 生命周期"></a>vue 生命周期</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">beforeCreate 实例化之前这里能拿到<span class="built_in">this</span>，但是还不能拿到data里面的数据</span><br><span class="line">created  实例化之后</span><br><span class="line">beforeMount()</span><br><span class="line">mounted() $el</span><br><span class="line">beforeUpdate</span><br><span class="line">updated</span><br><span class="line"></span><br><span class="line">beforeDestroy 清除定时/移除监听事件</span><br><span class="line">destroyed</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被keep-alive 包裹的</span></span><br><span class="line"><span class="comment">// keep-alive 标签 include exclude max</span></span><br><span class="line"><span class="function"><span class="title">activated</span>(<span class="params"></span>)</span> &#123;&#125;,</span><br><span class="line"><span class="function"><span class="title">deactivated</span>(<span class="params"></span>)</span> &#123;&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父子</span></span><br><span class="line">父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount-&gt;子mounted-&gt;父mounted。</span><br><span class="line"></span><br><span class="line"><span class="comment">// 离开页面：实例销毁 --&gt; DOM卸载 先父后子 先子后父</span></span><br><span class="line">parent  beforeDestroy</span><br><span class="line">child   beforeDestroy</span><br><span class="line">child   destroyed</span><br><span class="line">parent  destroyed</span><br></pre></td></tr></table></figure><p>1、创建前(beforeCreate)</p><p>此阶段为实例初始化之后，此时的数据观察和事件机制都未形成，不能获得DOM节点。</p><p>vue实例的挂载元素el和数据对象data都是undefined，还没有初始化。</p><p>2、创建后(created)</p><p>对应的钩子函数为created。在这个阶段vue实例已经创建，仍然不能获取DOM元素。</p><p>vue实例的数据对象data有了，可以访问里面的数据和方法，未挂载到DOM，el还没有</p><p>3、载入前(beforeMount)</p><p>在这一阶段，我们虽然依然得不到具体的DOM元素，但vue挂载的根节点已经创建，下面vue对DOM的操作将围绕这个根元素继续进行；beforeMount这个阶段是过渡性的，一般一个项目只能用到一两次。</p><h3 id="Vue-的-data-为什么是一个函数"><a href="#Vue-的-data-为什么是一个函数" class="headerlink" title="Vue 的 data 为什么是一个函数"></a>Vue 的 data 为什么是一个函数</h3><p>因为 Vue 的组件可能会在很多地方使用， 会产生多个实例，如果返回的是对象的， 这些组件之间的数据是同一份（引用关系），那么修改其中一个组件的数据，另外一个组件的数据都会被修改到</p><h3 id="Vue-key-值的作用"><a href="#Vue-key-值的作用" class="headerlink" title="Vue key 值的作用"></a>Vue key 值的作用</h3><blockquote><p>看这个视频，你能给面试官说这些，你就很不错了，vue 和 react 的差不多 <a href="https://www.bilibili.com/video/BV1wy4y1D7JT?p=48">https://www.bilibili.com/video/BV1wy4y1D7JT?p=48</a></p></blockquote><p>…待更新</p><h3 id="Vue-双向数据绑定原理"><a href="#Vue-双向数据绑定原理" class="headerlink" title="Vue 双向数据绑定原理"></a>Vue 双向数据绑定原理</h3><blockquote><p>下面是照抄的一段话，个人觉得这个主要看个人理解，如果看过源码理解 MVVM 这方面的，就很简单</p></blockquote><p>vue.js 是采用<strong>数据劫持结合发布者-订阅者模式</strong>的方式，通过 Object.defineProperty()来劫持</p><p>各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。</p><p>具体步骤：</p><p>第一步：需要 <strong>observe</strong> 的数据对象进行<strong>递归遍历</strong>，包括子属性对象的属性，都加上 setter和 getter</p><p>这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化</p><p>第二步：compile 解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，</p><p>并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通</p><p>知，更新视图</p><p>第三步：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁，主要做的事情是:</p><p>1、在自身实例化时往属性订阅器(dep)里面添加自己</p><p>2、自身必须有一个 update()方法</p><p>3、待属性变动 dep.notice()通知时，能调用自身的 update()方法，并触发 Compile 中绑定的</p><p>回调，则功成身退。</p><p>第四步：MVVM 作为数据绑定的入口，整合 Observer、</p><p>Compile 和 Watcher 三者，通过 Observer</p><p>来监听自己的 model 数据变化，通过 Compile 来解析编译模板指令，最终利用 Watcher 搭起</p><p>Observer 和 Compile 之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数</p><p>据 model 变更的双向绑定效果。</p><p>所以也可以根据这个来说明为什么 给<code>Vue</code>对象不存在的属性设置值的时候不生效，直接修改数组的<code>index</code>不生效</p><p>Vue 提供了 <code> Vue.set(对象|数组, key|index, 值)</code>修改触发响应式，重新数组的原型方法实现响应式</p><h3 id="Vue-extend-和-mixins"><a href="#Vue-extend-和-mixins" class="headerlink" title="Vue extend 和 mixins"></a>Vue extend 和 mixins</h3><p>vue extend 和 mixins 的区别， mixins 里面的 函数和本身的函数重名了使用哪一个，mixins 里面的生命周期和本身的生命周期哪一个先执行</p><p>…待更新</p><h3 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// component 动态组件，通过is设置要显示的组件</span></span><br><span class="line">&lt;component is=<span class="string">&quot;UserInfo&quot;</span> &gt;</span><br></pre></td></tr></table></figure><h3 id="递归组件"><a href="#递归组件" class="headerlink" title="递归组件"></a>递归组件</h3><p>就是给组件设置<code>name</code>，之后就可以在当前组件去递归使用组件</p><h3 id="Vue-组件间的传值的几种方式"><a href="#Vue-组件间的传值的几种方式" class="headerlink" title="Vue 组件间的传值的几种方式"></a>Vue 组件间的传值的几种方式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vue组件间的传值的几种方式</span></span><br><span class="line"><span class="number">1.</span> props/emit</span><br><span class="line"><span class="number">2.</span> $attrs/$listeners <span class="comment">// $attrs 除了父级作用域 props、class、style 之外的属性</span></span><br><span class="line"><span class="comment">// $listeners 父组件里面的所有的监听方法</span></span><br><span class="line"><span class="number">3.</span> $refs/$parent/$children/$root/</span><br><span class="line"><span class="number">4.</span> vuex</span><br><span class="line"><span class="number">5.</span> 事件总线，通过<span class="keyword">new</span> Vue去实现 / mitt &lt;==&gt; vue3</span><br><span class="line"><span class="number">6.</span> provide/inject</span><br><span class="line">    <span class="comment">// 父组件</span></span><br><span class="line">    props: &#123;&#125;,</span><br><span class="line">    <span class="function"><span class="title">provide</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        name: <span class="built_in">this</span>.name,</span><br><span class="line">        user: <span class="built_in">this</span>.user</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 子组件</span></span><br><span class="line">    props: &#123;&#125;,</span><br><span class="line">    inject: [<span class="string">&#x27;user&#x27;</span>]</span><br><span class="line"><span class="number">7.</span> 本地存储、全局变量</span><br></pre></td></tr></table></figure><h3 id="watch、mixins、组件顺序、组件配置"><a href="#watch、mixins、组件顺序、组件配置" class="headerlink" title="watch、mixins、组件顺序、组件配置"></a>watch、mixins、组件顺序、组件配置</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">&quot;MyComponentName&quot;</span>,</span><br><span class="line">  mixins: [tableMixin],</span><br><span class="line">  components: &#123;&#125;,</span><br><span class="line">  inject: [<span class="string">&quot;xxx&quot;</span>],</span><br><span class="line">  <span class="comment">// props: [&#x27;value&#x27;, &#x27;visible&#x27;],</span></span><br><span class="line">  props: &#123;</span><br><span class="line">    id: <span class="built_in">String</span>,</span><br><span class="line">    type: &#123;</span><br><span class="line">      <span class="comment">// required: true,</span></span><br><span class="line">      type: <span class="built_in">String</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="string">&quot;warning&quot;</span>,</span><br><span class="line">      <span class="function"><span class="title">validator</span>(<span class="params">val</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="string">&quot;primary&quot;</span>, <span class="string">&quot;warning&quot;</span>, <span class="string">&quot;danger&quot;</span>, <span class="string">&quot;success&quot;</span>, <span class="string">&quot;info&quot;</span>].includes(</span><br><span class="line">          val</span><br><span class="line">        );</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    list: &#123;</span><br><span class="line">      type: <span class="built_in">Array</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="function">() =&gt;</span> [],</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      name: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">      user: &#123; <span class="attr">name</span>: <span class="string">&quot;张三&quot;</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;,</span><br><span class="line">      loading: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// vue2</span></span><br><span class="line">      obj: &#123;</span><br><span class="line">        name: <span class="string">&quot;李四~&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// vue2 会进行深度合并</span></span><br><span class="line">      <span class="comment">// obj  &#123;&quot;name&quot;:&quot;李四~&quot;,&quot;age&quot;:19&#125;</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// vue3 &#123; name: &quot;李四~&quot; &#125;</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// provide 不支持响应式，想支持响应式的话我们要传对象</span></span><br><span class="line">  <span class="function"><span class="title">provide</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      userName: <span class="built_in">this</span>.name,</span><br><span class="line">      user: <span class="built_in">this</span>.user,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    <span class="comment">// fullName() &#123;</span></span><br><span class="line">    <span class="comment">//   return &#x27;xxxxx&#x27;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    fullName: &#123;</span><br><span class="line">      <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.$store.state.userName;</span><br><span class="line">        <span class="comment">// return &#x27;李四&#x27;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="function"><span class="title">set</span>(<span class="params">val</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.$store.commit(<span class="string">&quot;SET_NAME&quot;</span>, val);</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  watch: &#123;</span><br><span class="line">    <span class="comment">// name(value) &#123;</span></span><br><span class="line">    <span class="comment">//   this.handlerName()</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// name: &#123;</span></span><br><span class="line">    <span class="comment">//   immediate: true,</span></span><br><span class="line">    <span class="comment">//   deep: true, //</span></span><br><span class="line">    <span class="comment">//   handler(val, oldValue) &#123;</span></span><br><span class="line">    <span class="comment">//     this.handlerName()</span></span><br><span class="line">    <span class="comment">//   &#125;,</span></span><br><span class="line">    <span class="comment">// &#125;,</span></span><br><span class="line">    <span class="comment">// this.obj.name = &#x27;xxxx&#x27; 这样不会执行</span></span><br><span class="line">    <span class="comment">// this.obj = &#123;name: &#x27;xxx&#x27;&#125; 这样才会执行</span></span><br><span class="line">    <span class="comment">// obj(value) &#123;</span></span><br><span class="line">    <span class="comment">//   console.log(&#x27; value: &#x27;, value)</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">//  和上面等价</span></span><br><span class="line">    <span class="comment">// obj: &#123;</span></span><br><span class="line">    <span class="comment">//   handler(value) &#123;</span></span><br><span class="line">    <span class="comment">//     console.log(&quot; value: &quot;, value)</span></span><br><span class="line">    <span class="comment">//   &#125;,</span></span><br><span class="line">    <span class="comment">// &#125;,</span></span><br><span class="line">    <span class="comment">// this.obj.name = &#x27;xxxx&#x27; 这样去修改也能监听</span></span><br><span class="line">    <span class="comment">// obj: &#123;</span></span><br><span class="line">    <span class="comment">//   deep: true, // 深度监听</span></span><br><span class="line">    <span class="comment">//   immediate: true, // 第一次就用执行这个方法，可以理解为在 created 的时候会执行 handler</span></span><br><span class="line">    <span class="comment">//   handler(value) &#123;</span></span><br><span class="line">    <span class="comment">//     console.log(&quot; value: &quot;, value)</span></span><br><span class="line">    <span class="comment">//   &#125;,</span></span><br><span class="line">    <span class="comment">// &#125;,</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// obj: &#123;</span></span><br><span class="line">    <span class="comment">//   deep: true, // 深度监听</span></span><br><span class="line">    <span class="comment">//   immediate: true, // 第一次就用执行这个方法，可以理解为在 created 的时候会执行 handler</span></span><br><span class="line">    <span class="comment">//   handler: &#x27;handlerName&#x27;,</span></span><br><span class="line">    <span class="comment">// &#125;,</span></span><br><span class="line">    <span class="comment">// ==》</span></span><br><span class="line">    <span class="comment">// obj: &#x27;handlerName&#x27;</span></span><br><span class="line">    <span class="comment">// &#x27;$route.path&#x27;: &#123;&#125;,</span></span><br><span class="line">    <span class="comment">// &#x27;obj.a&#x27; : &#123;&#125;</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">beforeCreate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;this&quot;</span>, <span class="built_in">this</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// this.handlerName()</span></span><br><span class="line">    <span class="built_in">this</span>.fullName = <span class="string">&quot;xxxx&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  this.fullName &#x27;李四&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">handlerName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.obj.name = <span class="string">&quot;xxxx&quot;</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><p>常用指令</p><ul><li><p><code>v-show</code> <code>dispaly none</code> 的切换</p></li><li><p><code>v-if</code>/<code>v-else</code></p></li><li><p><code>v-html </code></p></li><li><p><code>v-text</code></p></li><li><p><code>v-for</code> (vue2 <code>v-for</code>比<code>v-if</code>优先级高，vu3<code>v-if</code>优先级比<code>v-for</code>高 )</p></li><li><p><code>v-cloak</code> <code> [v-cloak] &#123;dispaly:none&#125;</code></p></li><li><p><code>v-once</code> 静态内容</p></li><li><p><code>v-bind </code>=&gt; <code>:</code> <code>v-on</code> =&gt; <code>@</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--- 可以直接 v-bind=&quot;object&quot; v-on=&quot;object&quot; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Child</span> <span class="attr">v-bind</span>=<span class="string">&quot;$attrs&quot;</span> <span class="attr">v-on</span>=<span class="string">&quot;$listeners&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">Child</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>v-model</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-input</span> <span class="attr">v-model</span>=<span class="string">&quot;keyword&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">el-input</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--- 等价下面这个 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">el-input</span> <span class="attr">:value</span>=<span class="string">&quot;keyword&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;keyword = $event&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">el-input</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Vue.directive(<span class="string">&quot;指令名&quot;</span>, &#123;</span><br><span class="line">  <span class="comment">// 生命周期</span></span><br><span class="line">  <span class="comment">// 只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</span></span><br><span class="line">  <span class="function"><span class="title">bind</span>(<span class="params">el, binding, vnode, oldVnode</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// binging.value 拿到指令值</span></span><br><span class="line">    <span class="comment">// binding.modifiers 修饰符对象</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)</span></span><br><span class="line">  <span class="function"><span class="title">inserted</span>(<span class="params"></span>)</span> &#123;&#125;,</span><br><span class="line">  <span class="function"><span class="title">update</span>(<span class="params"></span>)</span> &#123;&#125;,</span><br><span class="line">  <span class="function"><span class="title">componentUpdated</span>(<span class="params"></span>)</span> &#123;&#125;,</span><br><span class="line">  <span class="comment">// 只调用一次，指令与元素解绑时调用</span></span><br><span class="line">  <span class="function"><span class="title">unbind</span>(<span class="params"></span>)</span> &#123;&#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认绑定 bind update 的生命周期</span></span><br><span class="line">Vue.directive(<span class="string">&quot;指令名&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">el, binding, vnode, oldVnode</span>) </span>&#123;&#125;);</span><br></pre></td></tr></table></figure><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3></li><li><p>.lazy、.number、.trim、.enter、.prevent、.self</p></li><li><p><code>.sync</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Dialog</span>  <span class="attr">:visible.sync</span>=<span class="string">&quot;visible&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">Child</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--- 等价下面这个 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Dialog</span>  <span class="attr">:visible</span>=<span class="string">&quot;visible&quot;</span> @<span class="attr">update:visible</span>=<span class="string">&quot;visible = $event&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">Child</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="scoped"><a href="#scoped" class="headerlink" title="scoped"></a>scoped</h3></li></ul><p>加了 scoped 就只作用于当前组件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>渲染规则</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.a</span> <span class="selector-class">.b</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line">== &gt; .a .b[data-v-xx] &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.a</span> /<span class="selector-tag">deep</span>/ <span class="selector-class">.b</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line">== &gt; .a[data-v-xxx] .b &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.a</span> &gt;&gt;&gt; <span class="selector-class">.b</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line">== &gt; .a[data-v-xxx] .b &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.a</span> <span class="selector-pseudo">::v-deep</span> <span class="selector-class">.b</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line">== &gt; .a[data-v-xxx] .b &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a><code>vue-router</code></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局 路由守卫</span></span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;&#125;)</span><br><span class="line">router.afterEach(<span class="function">(<span class="params">to, <span class="keyword">from</span></span>) =&gt;</span> &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">    mode: <span class="string">&#x27;hash&#x27;</span>, <span class="comment">// hash | history | abstract</span></span><br><span class="line">    <span class="comment">// 滚动位置</span></span><br><span class="line">    <span class="function"><span class="title">scrollBehavior</span>(<span class="params">to, <span class="keyword">from</span>, savedPosition</span>)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (savedPosition) <span class="keyword">return</span> savedPosition</span><br><span class="line">       <span class="keyword">return</span> &#123; <span class="attr">y</span>: <span class="number">0</span> &#125;</span><br><span class="line">&#125;,</span><br><span class="line">    routes: [</span><br><span class="line">        &#123;</span><br><span class="line">            path: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">            <span class="comment">// 路由独享守卫</span></span><br><span class="line">            <span class="function"><span class="title">beforeEnter</span>(<span class="params">to, <span class="keyword">from</span>, next</span>)</span> &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件内的路由</span></span><br><span class="line"><span class="function"><span class="title">beforeRouteEnter</span>(<span class="params">to, <span class="keyword">from</span>, next</span>)</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="title">beforeRouteUpdate</span>(<span class="params">to, <span class="keyword">from</span>, next</span>)</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="title">beforeRouteLeave</span>(<span class="params">to, <span class="keyword">from</span>, next</span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跳转</span></span><br><span class="line"><span class="built_in">this</span>.$router.push(&#123;<span class="attr">name</span>: <span class="string">&#x27;&#x27;</span>, <span class="attr">path</span>: <span class="string">&#x27;&#x27;</span>, <span class="attr">query</span>: &#123;&#125;&#125;)</span><br><span class="line"><span class="comment">// 路由信息</span></span><br><span class="line"><span class="built_in">this</span>.$route.query <span class="built_in">this</span>.$route.params</span><br></pre></td></tr></table></figure><h3 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a><code>vuex</code></h3><p>state getters mutations actions modules</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// state</span></span><br><span class="line"><span class="built_in">this</span>.$store.state.userInfo;</span><br><span class="line"><span class="comment">// getters</span></span><br><span class="line"><span class="built_in">this</span>.$store.getters.userInfo;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mutations</span></span><br><span class="line"><span class="built_in">this</span>.$store.commit(<span class="string">&quot;SET_USER_INFO&quot;</span>, <span class="string">&quot;传递数据&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// actions</span></span><br><span class="line"><span class="built_in">this</span>.$store.dispatch(<span class="string">&quot;logout&quot;</span>).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------------------------------</span></span><br><span class="line"><span class="comment">// modules &gt; user</span></span><br><span class="line"><span class="comment">// namespaced: true,</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// state 拿 name</span></span><br><span class="line"><span class="built_in">this</span>.$store.state.user.avatar;</span><br><span class="line"><span class="comment">// getters</span></span><br><span class="line"><span class="built_in">this</span>.$store.getters.user.avatar;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mutations</span></span><br><span class="line"><span class="built_in">this</span>.$store.commit(<span class="string">&quot;user/SET_TOKEN&quot;</span>, <span class="string">&quot;传递数据&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// actions</span></span><br><span class="line"><span class="built_in">this</span>.$store.dispatch(<span class="string">&quot;user/login&quot;</span>).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------------------------------</span></span><br><span class="line"><span class="comment">// modules &gt; user</span></span><br><span class="line"><span class="comment">// namespaced: false,</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// state 拿 name</span></span><br><span class="line"><span class="built_in">this</span>.$store.state.user.avatar;</span><br><span class="line"><span class="comment">// getters</span></span><br><span class="line"><span class="built_in">this</span>.$store.getters.user.avatar;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mutations</span></span><br><span class="line"><span class="built_in">this</span>.$store.commit(<span class="string">&quot;SET_TOKEN&quot;</span>, <span class="string">&quot;传递数据&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// actions</span></span><br><span class="line"><span class="built_in">this</span>.$store.dispatch(<span class="string">&quot;login&quot;</span>).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;&#125;);</span><br></pre></td></tr></table></figure><p>辅助函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mapState, mapGetters, mapMutations, mapActions;</span><br></pre></td></tr></table></figure><h2 id="vue3"><a href="#vue3" class="headerlink" title="vue3"></a>vue3</h2><blockquote><p><a href="https://juejin.cn/post/6999687348120190983">Vue3 的 8 种和 Vue2 的 12 种组件通信，值得收藏</a></p><p><a href="https://juejin.cn/post/7026249448233631752">聊一聊 Vue3 的 9 个知识点</a></p></blockquote><p><strong>Vue3 有哪些变化</strong></p><ul><li>新增了三个组件：<code>Fragment</code> 支持多个根节点、<code>Suspense</code> 可以在组件渲染之前的等待时间显示指定内容、<code>Teleport</code> 可以让子组件能够在视觉上跳出父组件(如父组件 overflow:hidden)</li><li>新增指令 <code>v-memo</code>，可以缓存 html 模板，比如 v-for 列表不会变化的就缓存，简单说就是用内存换时间</li><li>支持 <code>Tree-Shaking</code>，会在打包时去除一些无用代码，没有用到的模块，使得代码打包体积更小</li><li>新增 <code>Composition API</code> 可以更好的逻辑复用和代码组织，同一功能的代码不至于像以前一样太分散，虽然 Vue2 中可以用 minxin 来实现复用代码，但也存在问题，比如方法或属性名会冲突，代码来源也不清楚等</li><li>用 <code>Proxy</code> 代替 <code>Object.defineProperty</code> 重构了响应式系统，可以监听到数组下标变化，及对象新增属性，因为监听的不是对象属性，而是对象本身，还可拦截 apply、has 等 13 种方法</li><li>重构了虚拟 DOM，在编译时会将事件缓存、将 slot 编译为 lazy 函数、保存静态节点直接复用(静态提升)、以及添加静态标记、Diff 算法使用 最长递增子序列 优化了对比流程，使得虚拟 DOM 生成速度提升 <code>200%</code></li><li>支持在 <code>&lt;style&gt;&lt;/style&gt;</code> 里使用 <code>v-bind</code>，给 CSS 绑定 JS 变量(<code>color: v-bind(str)</code>)</li><li>用 <code>setup</code> 代替了 beforeCreate 和 created 这两个生命周期</li><li>新增了<strong>开发环境</strong>的两个钩子函数，在组件更新时 <code>onRenderTracked</code> 会跟踪组件里所有变量和方法的变化、每次触发渲染时 <code>onRenderTriggered</code> 会返回发生变化的新旧值，可以让我们进行有针对性调试</li><li>毕竟 Vue3 是用 <code>TS</code> 写的，所以对 <code>TS</code> 的支持度更好</li><li>Vue3 不兼容 <code>IE11</code></li></ul><h3 id="vue3-生命周期"><a href="#vue3-生命周期" class="headerlink" title="vue3 生命周期"></a>vue3 生命周期</h3><table><thead><tr><th>选项式 API</th><th>Hook inside <code>setup</code></th></tr></thead><tbody><tr><td><code>beforeCreate</code></td><td>Not needed*</td></tr><tr><td><code>created</code></td><td>Not needed*</td></tr><tr><td><code>beforeMount</code></td><td><code>onBeforeMount</code></td></tr><tr><td><code>mounted</code></td><td><code>onMounted</code></td></tr><tr><td><code>beforeUpdate</code></td><td><code>onBeforeUpdate</code></td></tr><tr><td><code>updated</code></td><td><code>onUpdated</code></td></tr><tr><td><code>beforeUnmount</code></td><td><code>onBeforeUnmount</code></td></tr><tr><td><code>unmounted</code></td><td><code>onUnmounted</code></td></tr><tr><td><code>errorCaptured</code></td><td><code>onErrorCaptured</code></td></tr><tr><td><code>renderTracked</code></td><td><code>onRenderTracked</code></td></tr><tr><td><code>renderTriggered</code></td><td><code>onRenderTriggered</code></td></tr><tr><td><code>activated</code></td><td><code>onActivated</code></td></tr><tr><td><code>deactivated</code></td><td><code>onDeactivated</code></td></tr></tbody></table><h3 id="基本代码"><a href="#基本代码" class="headerlink" title="基本代码"></a>基本代码</h3><h4 id="main-js"><a href="#main-js" class="headerlink" title="main.js"></a>main.js</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&quot;./App.vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> HelloWorld <span class="keyword">from</span> <span class="string">&quot;./components/HelloWorld.vue&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> app = createApp(App);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局组件</span></span><br><span class="line">app.component(<span class="string">&quot;HelloWorld&quot;</span>, HelloWorld);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局属性</span></span><br><span class="line"><span class="comment">// vue2.0 Vue.prototype.$http</span></span><br><span class="line">app.config.globalProperties.$http = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;http ==&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">app.mount(<span class="string">&quot;#app&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="App-vue"><a href="#App-vue" class="headerlink" title="App.vue"></a>App.vue</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--- App.vue  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- v-model=&quot;xxx&quot;  &lt;==&gt; v-model:modelValue=&quot;xxx&quot; --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- :value=&quot;xxx&quot; @input=&quot;xxx = $event&quot; --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- value $emit(&#x27;input&#x27;, &#x27;传递&#x27;) --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">      visible.sync=&quot;visible&quot; </span></span><br><span class="line"><span class="comment">      ==&gt;</span></span><br><span class="line"><span class="comment">      :visible=&quot;visible&quot; @update:visible=&quot;visible = $event&quot;</span></span><br><span class="line"><span class="comment">      --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- vue3 把 .sync 去掉，==&gt; </span></span><br><span class="line"><span class="comment">        v-model:visible=&quot;visible&quot;</span></span><br><span class="line"><span class="comment">       --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--     </span></span><br><span class="line"><span class="comment">    &lt;div :ref=&quot;setDivRef&quot;&gt;</span></span><br><span class="line"><span class="comment">      count: &#123;&#123; count &#125;&#125;</span></span><br><span class="line"><span class="comment">      &lt;p&gt;</span></span><br><span class="line"><span class="comment">        &lt;button @click=&quot;add&quot;&gt;+&lt;/button&gt;</span></span><br><span class="line"><span class="comment">        &lt;button @click=&quot;reduce&quot;&gt;-&lt;/button&gt;</span></span><br><span class="line"><span class="comment">      &lt;/p&gt;</span></span><br><span class="line"><span class="comment">    &lt;/div&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &lt;ul&gt;</span></span><br><span class="line"><span class="comment">      &lt;li&gt;姓名：&#123;&#123; user.name &#125;&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">      &lt;li&gt;年龄：&#123;&#123; user.age &#125;&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">    &lt;/ul&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- v-model=&quot;num&quot; --&gt;</span></span><br><span class="line">    &lt;Child</span><br><span class="line">      title=&quot;父组件传递的title&quot;</span><br><span class="line">      :modelValue=&quot;num&quot;</span><br><span class="line">      @update:modelValue=&quot;num = $event&quot;</span><br><span class="line">      @change=&quot;onChildChange&quot;</span><br><span class="line">      v-model:visible=&quot;visible&quot;</span><br><span class="line">      ref=&quot;childRef&quot;</span><br><span class="line">    &gt;<span class="tag">&lt;/<span class="name">Child</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;HelloWorld&gt;&lt;/HelloWorld&gt; --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> Child <span class="keyword">from</span> <span class="string">&quot;./Child-setup.vue&quot;</span>;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> &#123; reactive, ref &#125; <span class="keyword">from</span> <span class="string">&quot;@vue/reactivity&quot;</span>;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> &#123; onMounted, provide &#125; <span class="keyword">from</span> <span class="string">&quot;@vue/runtime-core&quot;</span>;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    components: &#123; Child &#125;,</span><br><span class="line"><span class="javascript">    <span class="comment">// data() &#123;</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">//   return &#123;</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">//     msg: &#x27;哈哈哈&#x27;,</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">//   &#125;</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// &#125;,</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> msg = ref(<span class="string">&quot;哈哈哈2&quot;</span>); <span class="comment">// =&gt; reactive(&#123;value: 哈哈哈2 &#125;)</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> obj = ref(&#123; <span class="attr">x</span>: <span class="string">&quot;xx&quot;</span> &#125;);</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&quot; obj.value: &quot;</span>, obj.value);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> user = reactive(&#123; <span class="attr">name</span>: <span class="string">&quot;张三&quot;</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> count = ref(<span class="number">0</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">      provide(<span class="string">&quot;count&quot;</span>, count);</span></span><br><span class="line"><span class="javascript">      provide(<span class="string">&quot;http&quot;</span>, <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&quot;$http &gt;&gt;&gt;&quot;</span>);</span></span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> add = <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line">        count.value++;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> reduce = <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line">        count.value--;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> num = ref(<span class="number">1</span>);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> visible = ref(<span class="literal">false</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="comment">// this.$refs.childRef x</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// refs</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// 1. 用字符串</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> childRef = ref(<span class="literal">null</span>);</span></span><br><span class="line"><span class="javascript">      onMounted(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&quot; childRef.value: &quot;</span>, childRef.value);</span></span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> divRef;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> setDivRef = <span class="function">(<span class="params">el</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&quot; el: &quot;</span>, el);</span></span><br><span class="line">        divRef = el;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line">        msg,</span><br><span class="line">        user,</span><br><span class="line">        count,</span><br><span class="line">        add,</span><br><span class="line">        reduce,</span><br><span class="line">        num,</span><br><span class="line">        visible,</span><br><span class="line">        childRef,</span><br><span class="line">        setDivRef,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    methods: &#123;</span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">onChildChange</span>(<span class="params"></span>)</span> &#123;&#125;,</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-id">#app</span> &#123;</span></span><br><span class="line">    font-family: Avenir, Helvetica, Arial, sans-serif;</span><br><span class="line">    -webkit-font-smoothing: antialiased;</span><br><span class="line">    -moz-osx-font-smoothing: grayscale;</span><br><span class="line">    text-align: center;</span><br><span class="line"><span class="css">    <span class="selector-tag">color</span>: <span class="selector-id">#2c3e50</span>;</span></span><br><span class="line">    margin-top: 60px;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Child-composition-（组合式-api）"><a href="#Child-composition-（组合式-api）" class="headerlink" title="Child-composition （组合式 api）"></a>Child-composition （组合式 api）</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">  1. 多个片段， 多个根标签 </span></span><br><span class="line"><span class="comment">  2. v-for v-if 优先级变化 v3 v-if &gt; v-for</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;triggerEvent&quot;</span>&gt;</span>触发事件<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>num2：&#123;&#123; num2 &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>count：&#123;&#123; count &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    modelValue：&#123;&#123; modelValue &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;add&quot;</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span> /&gt;</span></span><br><span class="line">    visible：&#123;&#123; visible &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;updateVisible&quot;</span>&gt;</span>更新visible<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--   --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">teleport</span> <span class="attr">to</span>=<span class="string">&quot;body&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">&quot;visible&quot;</span>&gt;</span>对话框<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">teleport</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> &#123;</span></span><br><span class="line">    computed,</span><br><span class="line">    inject,</span><br><span class="line">    onActivated,</span><br><span class="line">    onBeforeMount,</span><br><span class="line">    onBeforeUnmount,</span><br><span class="line">    onBeforeUpdate,</span><br><span class="line">    onDeactivated,</span><br><span class="line">    onMounted,</span><br><span class="line">    onUnmounted,</span><br><span class="line">    onUpdated,</span><br><span class="line">    watch,</span><br><span class="line">    watchEffect,</span><br><span class="line"><span class="javascript">  &#125; <span class="keyword">from</span> <span class="string">&quot;@vue/runtime-core&quot;</span>;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    props: &#123;</span><br><span class="line"><span class="javascript">      title: <span class="built_in">String</span>,</span></span><br><span class="line"><span class="javascript">      modelValue: <span class="built_in">Number</span>,</span></span><br><span class="line"><span class="javascript">      visible: <span class="built_in">Boolean</span>,</span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    <span class="comment">// computed: &#123;</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">//   num2() &#123;</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">//     return this.modelValue * 2</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">//   &#125;</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// &#125;,</span></span></span><br><span class="line"><span class="javascript">    emits: [<span class="string">&quot;change&quot;</span>, <span class="string">&quot;update:modelValue&quot;</span>, <span class="string">&quot;update:visible&quot;</span>],</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 发生在 beforeCreate</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// attrs 除了 class style,props 之外的属性</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">//</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="comment">// watch: &#123;</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">//   title: &#123;</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">//     deep: true, // 深度简单</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="comment">//   &#125;</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// &#125;,</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 组合式API(composition),  选项式API(options)</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">setup</span>(<span class="params">props, &#123; emit, attrs, slots &#125;</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&quot; attrs: &quot;</span>, attrs);</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&quot; props: &quot;</span>, props);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="comment">// computed</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> num2 = computed(<span class="function">() =&gt;</span> props.modelValue * <span class="number">2</span>);</span></span><br><span class="line"><span class="javascript">      <span class="comment">// const num2 = computed(&#123;</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">//   get: () =&gt; props.modelValue * 2,</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">//   set: (val) =&gt; &#123;</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">//     ssss</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">//   &#125;</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// &#125;)</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="comment">//</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> count = inject(<span class="string">&quot;count&quot;</span>);</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&quot; count: &quot;</span>, count);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="comment">// watch</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// this.$watch()</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> unwatch = watch(</span></span><br><span class="line">        () =&gt; props.modelValue,</span><br><span class="line">        (newVal, oldValue) =&gt; &#123;</span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">&quot; newVal: &quot;</span>, newVal);</span></span><br><span class="line"><span class="javascript">          <span class="keyword">if</span> (newVal &gt;= <span class="number">10</span>) &#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 取消监听</span></span></span><br><span class="line">            unwatch();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line"><span class="javascript">          deep: <span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript">          <span class="comment">// immediate: true</span></span></span><br><span class="line">        &#125;</span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="comment">// 自动收集依赖，所以会初始化的时候就执行一次</span></span></span><br><span class="line"><span class="javascript">      watchEffect(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&quot; props.modelValue: &quot;</span>, props.modelValue);</span></span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="comment">// hooks</span></span></span><br><span class="line"><span class="javascript">      onBeforeMount(<span class="function">() =&gt;</span> &#123;&#125;);</span></span><br><span class="line"><span class="javascript">      onMounted(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&quot;哈哈哈&quot;</span>);</span></span><br><span class="line">      &#125;);</span><br><span class="line"><span class="javascript">      onBeforeUpdate(<span class="function">() =&gt;</span> &#123;&#125;);</span></span><br><span class="line"><span class="javascript">      onUpdated(<span class="function">() =&gt;</span> &#123;&#125;);</span></span><br><span class="line"><span class="javascript">      onBeforeUnmount(<span class="function">() =&gt;</span> &#123;&#125;);</span></span><br><span class="line"><span class="javascript">      onUnmounted(<span class="function">() =&gt;</span> &#123;&#125;);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="comment">// keep-alive</span></span></span><br><span class="line"><span class="javascript">      onActivated(<span class="function">() =&gt;</span> &#123;&#125;);</span></span><br><span class="line"><span class="javascript">      onDeactivated(<span class="function">() =&gt;</span> &#123;&#125;);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="comment">// methods</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> triggerEvent = <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        emit(<span class="string">&quot;change&quot;</span>, <span class="string">&quot;传递的数据&quot;</span>);</span></span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> add = <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        emit(<span class="string">&quot;update:modelValue&quot;</span>, props.modelValue + <span class="number">1</span>);</span></span><br><span class="line">      &#125;;</span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> updateVisible = <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&quot; props.visible: &quot;</span>, props.visible);</span></span><br><span class="line"><span class="javascript">        emit(<span class="string">&quot;update:visible&quot;</span>, !props.visible);</span></span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line">        triggerEvent,</span><br><span class="line">        add,</span><br><span class="line">        updateVisible,</span><br><span class="line">        num2,</span><br><span class="line">        count,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    <span class="comment">// beforeCreate() &#123;</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">//   console.log(&#x27;beforeCreate&#x27;)</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// &#125;,</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// created() &#123;</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">//   console.log(&#x27;created&#x27;)</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// &#125;,</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="comment">// beforeDestroy beforeUnmount</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// destroyed unmounted</span></span></span><br><span class="line">  &#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Child-setup"><a href="#Child-setup" class="headerlink" title="Child-setup"></a>Child-setup</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>title: &#123;&#123; title &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>num2: &#123;&#123; num2 &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>count: &#123;&#123; count &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      modelValue：&#123;&#123; modelValue &#125;&#125;</span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;add&quot;</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;triggerEvent&quot;</span>&gt;</span>触发事件<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- &lt;input type=&quot;text&quot; v-model=&quot;inputValue&quot;&gt; --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--   --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">:value</span>=<span class="string">&quot;inputValue&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;onInputUpdate&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- volar --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Foo</span>&gt;</span><span class="tag">&lt;/<span class="name">Foo</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--- vue 3.2.x --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> &#123;</span></span><br><span class="line">    computed,</span><br><span class="line">    getCurrentInstance,</span><br><span class="line">    inject,</span><br><span class="line">    ref,</span><br><span class="line">    useAttrs,</span><br><span class="line">    useSlots,</span><br><span class="line"><span class="javascript">  &#125; <span class="keyword">from</span> <span class="string">&quot;@vue/runtime-core&quot;</span>;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> Foo <span class="keyword">from</span> <span class="string">&quot;./foo.vue&quot;</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="comment">// props</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> props = defineProps(&#123;</span></span><br><span class="line"><span class="javascript">    title: <span class="built_in">String</span>,</span></span><br><span class="line"><span class="javascript">    modelValue: <span class="built_in">Number</span>,</span></span><br><span class="line">  &#125;);</span><br><span class="line"><span class="javascript">  <span class="comment">// computed</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> num2 = computed(<span class="function">() =&gt;</span> props.modelValue * <span class="number">2</span>);</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> count = inject(<span class="string">&quot;count&quot;</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="comment">// emit</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> emit = defineEmits([<span class="string">&quot;change&quot;</span>, <span class="string">&quot;update:modelValue&quot;</span>, <span class="string">&quot;update:visible&quot;</span>]);</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> triggerEvent = <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">    emit(<span class="string">&quot;change&quot;</span>, <span class="string">&quot;传递的数据&quot;</span>);</span></span><br><span class="line">  &#125;;</span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> add = <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">    emit(<span class="string">&quot;update:modelValue&quot;</span>, props.modelValue + <span class="number">1</span>);</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="comment">// 向父组件暴露自己的属性和方法</span></span></span><br><span class="line">  defineExpose(&#123;</span><br><span class="line">    num2,</span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">test</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&quot;888&quot;</span>);</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> attrs = useAttrs();</span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(<span class="string">&quot; attrs: &quot;</span>, attrs);</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> solts = useSlots();</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> ctx = getCurrentInstance();</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> http = ctx.appContext.config.globalProperties.$http;</span></span><br><span class="line"><span class="javascript">  http(<span class="string">&quot;xxx&quot;</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> $http = inject(<span class="string">&quot;http&quot;</span>);</span></span><br><span class="line">  $http();</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="comment">// $ref: ref(false)</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> inputValue = ref(<span class="string">&quot;&quot;</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> onInputUpdate = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">&quot; event: &quot;</span>, event);</span></span><br><span class="line">    inputValue.value = event.target.value;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="项目相关"><a href="#项目相关" class="headerlink" title="项目相关"></a>项目相关</h2><h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><p><a href="https://shfshanyue.github.io/cheat-sheets/git">https://shfshanyue.github.io/cheat-sheets/git</a></p><h4 id="git-pull-和-git-featch-的区别"><a href="#git-pull-和-git-featch-的区别" class="headerlink" title="git pull 和 git featch 的区别"></a>git pull 和 git featch 的区别</h4><h4 id="怎么样进行合并，比如把-mater-分支合并到-dev-分支"><a href="#怎么样进行合并，比如把-mater-分支合并到-dev-分支" class="headerlink" title="怎么样进行合并，比如把 mater 分支合并到 dev 分支"></a>怎么样进行合并，比如把 mater 分支合并到 dev 分支</h4><p>git fetch是<strong>从远程获取最新版本到本地，但不会自动merge</strong>。<br>       而git pull则是<strong>会获取所有远程索引并合并到本地分支中</strong>来</p><h3 id="Webpack-一些核心概念："><a href="#Webpack-一些核心概念：" class="headerlink" title="Webpack 一些核心概念："></a>Webpack 一些核心概念：</h3><blockquote><p><a href="https://juejin.cn/post/7023242274876162084">【万字】透过分析 webpack 面试题，构建 webpack5.x 知识体系</a></p></blockquote><ul><li><p><code>Entry</code>：入口，指示 Webpack 应该使用哪个模块，来作为构建其内部 依赖图(dependency graph) 的开始。</p></li><li><p><code>Output</code>：输出结果，告诉 Webpack 在哪里输出它所创建的 bundle，以及如何命名这些文件。</p></li><li><p><code>Module</code>：模块，在 Webpack 里一切皆模块，一个模块对应着一个文件。Webpack 会从配置的 Entry 开始递归找出所有依赖的模块。</p></li><li><p><code>Chunk</code>：代码块，一个 Chunk 由多个模块组合而成，用于代码合并与分割。</p></li><li><p><code>Loader</code>：模块代码转换器，让 webpack 能够去处理除了 JS、JSON 之外的其他类型的文件，并将它们转换为有效 模块，以供应用程序使用，以及被添加到依赖图中。</p></li><li><p><code>Plugin</code>：扩展插件。在 webpack 运行的生命周期中会广播出许多事件，plugin 可以监听这些事件，在合适的时机通过 webpack 提供的 api 改变输出结果。常见的有：打包优化，资源管理，注入环境变量。</p></li><li><p><code>Mode</code>：模式，告知 webpack 使用相应模式的内置优化</p><hr></li></ul><ul><li><code>hash</code>: 每次构建的生成唯一的一个 hash，且所有的文件 hash 串是一样的</li></ul><ul><li><p><code>chunkhash</code>: 每个<strong>入口文件</strong>都是一个 chunk，每个 chunk 是由入口文件与其依赖所构成，<strong>异步加载</strong>的文件也被视为是一个 chunk, <strong>chunkhash</strong>是由每次编译模块，根据模块及其依赖模块构成 chunk 生成对应的 chunkhash, 这也就表明了<strong>每个 chunk 的 chunkhash 值</strong>都不一样， 也就是说每个 chunk 都是独立开来的，互不影响，每个 chunk 的更新不会影响其他 chunk 的编译构建</p></li><li><p><code>contenthash</code>：由文件内容决定，文件变化 contenthash 才会变化，一般配合 <code>mini-css-extract-plugin</code>插件提取出 css</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">&quot;mini-css-extract-plugin&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> HTMLWebpackPlugin = <span class="built_in">require</span>(<span class="string">&quot;html-webpack-plugin&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="comment">// 把 style-loader替换掉，不要使用 style-loader了</span></span><br><span class="line">            loader: MiniCssExtractPlugin.loader,</span><br><span class="line">            options: &#123;</span><br><span class="line">              outputPath: <span class="string">&quot;css/&quot;</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="string">&quot;css-loader&quot;</span>,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: <span class="string">&quot;css/[name].[contenthash].css&quot;</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="提升-webpack-打包速度"><a href="#提升-webpack-打包速度" class="headerlink" title="提升 webpack 打包速度"></a>提升 webpack 打包速度</h3></li></ul><blockquote><p><a href="https://juejin.cn/post/7046616302521155614">一套骚操作下来，webpack 项目打包速度飞升 🚀、体积骤减 ↓</a></p><p><a href="https://juejin.cn/post/6844904071736852487">玩转 webpack，使你的打包速度提升 90%</a></p><p><a href="https://juejin.cn/post/6844904093463347208">带你深度解锁 Webpack 系列(优化篇)</a></p><p><a href="https://juejin.cn/post/6996816316875161637">学习 Webpack5 之路（优化篇）- 近 7k 字</a></p></blockquote><ul><li><p>速度分析，可以使用 <code>speed-measure-webpack-plugin</code></p></li><li><p>提升基础环境，nodejs 版本，webpack 版本</p></li><li><p><code>CDN</code> 分包 <code>html-webpack-externals-plugin</code>, <code>externals</code></p></li><li><p>多进程、多实例构建 <code>thread-loader</code> <code>happypack(不再维护)</code> </p></li><li><p>多进程并行构建打包<code>uglifyjs-webpack-plugin</code> <code>terser-webpack-plugin</code></p></li><li><p>缓存: webpack5 内置了<code>cache</code>模块 、<code>babel-loader</code> 的 <code>cacheDirectory</code> 标志、<code>cache-loader</code>, <code>HardSourceWebpackPlugin</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// webpack5内置缓存</span></span><br><span class="line">  cache: &#123;</span><br><span class="line">    type: <span class="string">&quot;filesystem&quot;</span>, <span class="comment">// 使用文件缓存</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>构建缩小范围 <code>include</code>,<code>exclude</code></p></li><li><p>加快文件查找速度<code>resolve.alias</code>,<code>resolve.extensions</code>, <code>module.noParse</code></p></li><li><p><code>DllPlugin</code></p></li><li><p><code>babel </code>配置的优化</p></li></ul><h3 id="webpack-常用-loader，plugin"><a href="#webpack-常用-loader，plugin" class="headerlink" title="webpack 常用 loader，plugin"></a>webpack 常用 loader，plugin</h3><p><strong>loader</strong></p><p>“<em>Babel是一个广泛使用的转码器,可以将ES6代码转为ES5代码,从而在现有环境执行</em></p><ul><li><code>babel-loader</code> 将 <code>es6</code> 转换成 <code>es5</code>  <strong>（为了兼容 ES5）</strong>, <code>ts-loader</code>、<code>vue-loader</code></li><li><code>eslint-loader</code> 配置 <code>enforce: &#39;pre&#39;</code> 这个 loader 最先执行</li><li><code>css-loader</code>、<code>style-loader</code>、<code>postcss-loader</code> (兼容性)、<code>less-loader</code>、<code>sass-loader</code></li><li><code>file-loader</code> 把文件转换成路径引入, <code>url-loader</code>（比<code>file-loader</code>多了小于多少的能转换成 base64）</li><li><code>image-loader</code></li><li><code>svg-sprite-loader</code> 处理 svg</li><li><code>thread-loader</code> 开启多进程 ，会在一个单独的 worker 池（worker pool）中运行</li><li><code>cache-loader</code> 缓存一些性能开销比较大的 loader 的处理结果</li></ul><p><strong>plugin</strong></p><ul><li><p><code>html-webpack-plugin</code> 将生成的 css，js 自动注入到 html 文件中，能对 html 文件压缩</p></li><li><p><code>copy-webpack-plugin</code> 拷贝某个目录</p></li><li><p><code>clean-webpack-plugin</code> 清空某个目录</p></li><li><p><code>webpack.HotModuleReplacementPlugin</code> 热重载</p></li><li><p><code>webpack.DefinePlugin</code> 定义全局变量</p></li><li><p><code>mini-css-extract-plugin</code> 提取 CSS 到独立 bundle 文件。 <code>extract-text-webpack-plugin</code></p></li><li><p><code>optimize-css-assets-webpack-plugin</code> 压缩 css webpack5 推荐<code>css-minimizer-webpack-plugin</code></p></li><li><p><code>purgecss-webpack-plugin </code> 会单独提取 CSS 并清除用不到的 CSS（会有问题把有用的 css 删除）</p></li><li><p><code>uglifyjs-webpack-plugin</code> ❌（不推荐） 压缩 js、多进程 <code>parallel: true</code></p></li><li><p><code>terser-webpack-plugin</code> 压缩 js， 可开启多进程压缩、推荐使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    minimize: <span class="literal">true</span>,</span><br><span class="line">    minimizer: [</span><br><span class="line">      <span class="keyword">new</span> TerserPlugin(&#123;</span><br><span class="line">        parallel: <span class="literal">true</span>, <span class="comment">// 多进程压缩</span></span><br><span class="line">      &#125;),</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><code>Happypack</code> ❌（不再维护） 可开启多进程</p></li><li><p><code>HardSourceWebpackPlugin</code> 缓存</p></li><li><p><code>speed-measure-webpack-plugin</code> 打包构建速度分析、查看编译速度</p></li><li><p><code>webpack-bundle-analyzer </code>打包体积分析</p></li><li><p><code>compression-webpack-plugin</code> gzip 压缩</p></li></ul><h3 id="前端性能优化"><a href="#前端性能优化" class="headerlink" title="前端性能优化"></a>前端性能优化</h3><blockquote><p><a href="https://juejin.cn/post/6892994632968306702">前端性能优化 24 条建议（2020）</a></p></blockquote><ol><li>减少 http 请求</li><li>使用 http2</li><li>静态资源使用 CDN</li><li>将 CSS 放在文件头部，JavaScript 文件放在底部</li><li>使用字体图标 iconfont 代替图片图标</li><li>设置缓存，强缓存，协商缓存</li><li>压缩文件，css(<code>MiniCssExtractPlugin</code>),js(<code>UglifyPlugin</code>),html(<code>html-webpack-plugin</code>)文件压缩，清除无用的代码，<code>tree-shaking</code>（需要 es6 的 import 才支持），gzip 压缩(<code>compression-webpack-plugin</code>)</li><li>splitChunks 分包配置，optimization.splitChunks 是基于 <a href="https://link.juejin.cn/?target=https://webpack.docschina.org/plugins/split-chunks-plugin/">SplitChunksPlugin</a> 插件实现的</li><li>图片优化、图片压缩</li><li>webpack 按需加载代码，<code>hash</code>，<code>contenthash</code></li><li>减少重排重绘</li><li>降低 css 选择器的复杂性</li></ol><h3 id="babel"><a href="#babel" class="headerlink" title="babel"></a>babel</h3><blockquote><p><a href="https://juejin.cn/post/6844904008679686152">不容错过的 Babel7 知识</a></p></blockquote><p>核心库 <code>@babel/core</code></p><p><code>Polyfill</code> 垫片</p><p>CLI 命令行工具 <code>@babel/cli</code></p><p>插件</p><p>预设：包含了很多插件的一个组合，<code>@babel/preset-env</code> <code>@babel/preset-react</code> <code>@babel/preset-typescript</code></p><p><strong>polyfill</strong></p><p>Babel 默认只转换新的 JavaScript 句法（syntax），而不转换新的 API，比如<code>Iterator</code>、<code>Generator</code>、<code>Set</code>、<code>Map</code>、<code>Proxy</code>、<code>Reflect</code>、<code>Symbol</code>、<code>Promise</code>等全局对象，以及一些定义在全局对象上的方法（比如<code>Object.assign</code>）都不会转码。</p><p>举例来说，ES6 在<code>Array</code>对象上新增了<code>Array.from</code>方法。Babel 就不会转码这个方法。如果想让这个方法运行，可以使用<code>core-js</code>和<code>regenerator-runtime</code>(后者提供 generator 函数的转码)，为当前环境提供一个垫片。</p><p><strong><code>@babel/plugin-transform-runtime</code></strong></p><p><code>Babel</code> 会使用很小的辅助函数来实现类似 <code>_createClass</code> 等公共方法。默认情况下，它将被添加(<code>inject</code>)到需要它的每个文件中。</p><p>如果你有 10 个文件中都使用了这个 <code>class</code>，是不是意味着 <code>_classCallCheck</code>、<code>_defineProperties</code>、<code>_createClass</code> 这些方法被 <code>inject</code> 了 10 次。这显然会导致包体积增大，最关键的是，我们并不需要它 <code>inject</code> 多次。</p><p><code>@babel/plugin-transform-runtime</code> 是一个可以重复使用 <code>Babel</code> 注入的帮助程序，以节省代码大小的插件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev @babel/plugin-transform-runtime</span><br><span class="line">npm install --save @babel/runtime</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//.babelrc</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;presets&quot;</span>: [</span><br><span class="line">        [</span><br><span class="line">            <span class="string">&quot;@babel/preset-env&quot;</span>,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&quot;useBuiltIns&quot;</span>: <span class="string">&quot;usage&quot;</span>, <span class="comment">// 配置 polyfill 动态导入</span></span><br><span class="line">                <span class="string">&quot;corejs&quot;</span>: <span class="number">3</span> <span class="comment">// core-js@3</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;plugins&quot;</span>: [</span><br><span class="line">        [</span><br><span class="line">            <span class="string">&quot;@babel/plugin-transform-runtime&quot;</span></span><br><span class="line">        ]</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><h3 id="Cookie-和-Session-的区别"><a href="#Cookie-和-Session-的区别" class="headerlink" title="Cookie 和 Session 的区别"></a>Cookie 和 Session 的区别</h3><p>1、cookie数据存放在客户的浏览器上，session数据放在服务器上。</p><p>2、cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，考虑到安全应当使用session。</p><p>3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用cookie。</p><p>4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</p><p>5、可以考虑将登陆信息等重要信息存放为session，其他信息如果需要保留，可以放在cookie中。</p><h3 id="localStorage和cookie的区别"><a href="#localStorage和cookie的区别" class="headerlink" title="localStorage和cookie的区别"></a>localStorage和cookie的区别</h3><p>cookie 只能存储文本、单条存储有大小限制4KB左右</p><p><strong>localStorage</strong>：主要是用来作为本地存储来使用的，解决了cookie存储空间不足的问题(cookie中每条cookie的存储空间为4k)，<a href="https://so.csdn.net/so/search?q=localStorage&spm=1001.2101.3001.7020">localStorage</a>中一般浏览器支持的是5M大小，这个在不同的浏览器中localStorage会有所不同。</p><h3 id="跨域、同源策略"><a href="#跨域、同源策略" class="headerlink" title="跨域、同源策略"></a>跨域、同源策略</h3><p>参考：<a href="https://blog.csdn.net/weixin_43745075/article/details/115482227">https://blog.csdn.net/weixin_43745075/article/details/115482227</a></p><blockquote><p>同源策略是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSRF等攻击。所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个ip地址，也非同源。</p></blockquote><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/20210407114820178.png" alt="img"></p><p><strong>同源策略限制内容有：</strong></p><ul><li>Cookie、LocalStorage、IndexedDB 等存储性内容</li><li>DOM 节点</li><li>AJAX 请求发送后，结果被浏览器拦截了</li></ul><p>但是有三个标签是允许跨域加载资源：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;XXX&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;XXX&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;XXX&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="跨域解决方案"><a href="#跨域解决方案" class="headerlink" title="跨域解决方案"></a>跨域解决方案</h3><ol><li><p><code>JSONP</code>：通 过 动 态 创 建 <code>script</code> ， 再 请 求 一 个 带 参 网 址 实 现 跨 域 通 信 。</p></li><li><p>开发环境：前端做代理</p></li><li><p><code>nginx</code>反向代理</p></li><li><p><code>CORS</code>: 服务端设置 <code>Access-Control-Allow-Origin</code> 即可，前端无须设置，若要带 <code>cookie</code> 请求，前后端都需要设置。</p></li><li><p><code>websocket</code></p><p>—下面的跨域通信、注意只是页面之间的跨域，不是前后端服务跨域，别人问前后端跨域就不要回答下面的了</p></li><li><p><code>postMessage</code></p></li><li><p>window.name + iframe</p></li><li><p>document.domain + iframe</p></li><li><p>location.hash + iframe</p></li></ol><h3 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h3><ul><li>标记清除： 进入环境、离开环境</li><li>引用计数（不常用）：值被引用的次数， 当引用次数为零时会被清除（缺陷，相互引用的会有问题）</li></ul><h3 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h3><h4 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h4><blockquote><p>如果命中强缓存–就不用像服务器去请求</p></blockquote><ol><li><p><code>Expires</code> 设置时间，过期时间 <code>expires: Tue, 15 Oct 2019 13:30:54 GMT</code></p><p>通过本地时间和 expires 比较是否过期，如果过期了就去服务器请求，没有过期的话就直接使用本地的</p><p>缺点：本地时间可能会更改， 导致缓存出错</p></li><li><p><code>Cache-Control</code> HTTP1.1 中新增的</p><ul><li><p>max-age 最大缓存多少毫秒，列如 <code>Cache-Control: max-age=2592000</code></p></li><li><p>no-store (每次都要请求，就连协商缓存都不走)表示不进行缓存，缓存中不得存储任何关于客户端请求和服务端响应的内容。每次 由客户端发起的请求都会下载完整的响应内容。<code>Cache-Control: no-store</code></p></li><li><p>no-cache（默认值）表示不缓存过期的资源，缓存会向源服务器进行有效期确认后处理资源，也许称 为 do-notserve-from-cache-without-revalidation 更合适。浏览器默认开启的是 no-cache，其 实这里也可理解为开启协商缓存</p></li><li><p>public 和 private</p><p>public 与 private 是针对资源是否能够被代理服务缓存而存在的一组对立概念</p><p>当我们为资源设置了 <strong>pubile</strong>，那么它既<strong>可以被浏览器缓存也可被代理服务器缓存</strong>。设置为</p><p>private 的时候，则该资源<strong>只能被浏览器缓存</strong>，其中默认值是 private。</p></li><li><p>max-age 和 s-maxage</p><p>s-maxage 只适用于供多用户使用的公共服务器上(如 CND cache)，并只对 public 缓存有效</p></li></ul></li></ol><h4 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h4><blockquote><p>需要向服务器请求，如果没有过期，服务器会返回 304，</p></blockquote><ol><li><strong>ETag 和 If-None-Match 唯一标识</strong></li></ol><ul><li><p>服务器响应 ETag 值，浏览器携带的是 If-None-Match（携带的是上一次响应的 ETag），服务拿到这 If-None-Match 值后判断过期–&gt; 没有过期 304，并且返回 ETag</p><hr><p>二者的值都是服务器为每份资源分配的唯一标识字符串。</p><p>• 浏览器请求资源，服务器会在响应报文头中加入 ETag 字段。资源更新的时候，服务端的</p><p>ETag 值也随之更新</p><p>• 浏览器再次请求资源，会在请求报文头中添加 If-None-Match 字段，它的值就是上次响应</p><p>报文中的 ETag 值，服务器会对比 ETag 和 If-None-Match 的值是否一致。如果不一致，服务</p><p>器则接受请求，返回更新后的资源，状态码返回 200；如果一致，表明资源未更新，则返回</p><p>状态码 304，可继续使用本地缓存，值得注意的是此时响应头会加上 ETag 字段，即使它没</p><p>有变化</p><hr></li><li><p><strong>Last-Modified 和 If-Modified-Since 时间戳</strong><br>缺点： 某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说 1s 内修改了 N 次)，</p><p>If-Modified-Since 可查到的是秒级，这种修改无法判断</p></li></ul><h3 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h3><p>四部曲</p><ol><li>创建<code>AO</code>对象</li><li>找形参和变量声明，将变量和形参名作为<code>AO</code>的属性名，值为<code>undefined</code></li><li>将实参值和形参值相统一</li><li>在函数体里面找到函数声明，值赋予函数体</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 预编译</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">test <span class="comment">/* 形参 */</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot; test: &quot;</span>, test); <span class="comment">// function()&#123;&#125;</span></span><br><span class="line">  <span class="keyword">var</span> test = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">var</span> str = <span class="string">&quot;bs&quot;</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot; test: &quot;</span>, test); <span class="comment">// 2</span></span><br><span class="line">  <span class="comment">// 函数声明</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  <span class="comment">// 函数表达式</span></span><br><span class="line">  str = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot; test: &quot;</span>, test); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 预编译 四部曲</span></span><br><span class="line"><span class="comment">// 1. 创建AO对象</span></span><br><span class="line"><span class="comment">// 2. 找形参和变量声明，将变量和形参名作为AO的属性名，值为undefined</span></span><br><span class="line"><span class="comment">// 3. 将实参值和形参值相统一</span></span><br><span class="line"><span class="comment">// 4. 在函数体里面找到函数声明，值赋予函数体</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// AO &#123;</span></span><br><span class="line"><span class="comment">//   test: undefined</span></span><br><span class="line"><span class="comment">//   str: undefined</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// AO &#123;</span></span><br><span class="line"><span class="comment">//   test: 1</span></span><br><span class="line"><span class="comment">//   str: undefined</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// AO &#123;</span></span><br><span class="line"><span class="comment">//   test: 1</span></span><br><span class="line"><span class="comment">//   str: function() &#123;&#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">foo(<span class="number">1</span> <span class="comment">/*实参*/</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">  <span class="built_in">console</span>.log(b);</span><br><span class="line">  <span class="keyword">var</span> a = <span class="string">&quot;222&quot;</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">  <span class="built_in">console</span>.log(b);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot; a, b, c: &quot;</span>, a, b, c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AO &#123;</span></span><br><span class="line"><span class="comment">//   a : &#x27;222&#x27;,</span></span><br><span class="line"><span class="comment">//   b : function() &#123;&#125;,</span></span><br><span class="line"><span class="comment">//   c : 3</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">foo(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">22</span>;</span><br><span class="line"><span class="comment">// let a = 22</span></span><br><span class="line"><span class="comment">// window.a ==&gt; 22</span></span><br></pre></td></tr></table></figure><p>全局</p><ol><li>创建 GO 对象==window</li><li>变量声明，将变量作为 GO 的属性名，值为<code>undefined</code></li><li>找到函数声明，值赋予函数体</li></ol><h3 id="event-loop-事件循环"><a href="#event-loop-事件循环" class="headerlink" title="event-loop(事件循环)"></a>event-loop(事件循环)</h3><blockquote><p><a href="https://juejin.cn/post/6844903764202094606">一次弄懂 Event Loop（彻底解决此类面试问题）</a></p></blockquote><p><code>JS</code>是单线程的，为了防止一个函数执行时间过长阻塞后面的代码，所以会先将同步代码压入执行栈中，依次执行，将异步代码推入异步队列，异步队列又分为宏任务队列和微任务队列，因为宏任务队列的执行时间较长，所以微任务队列要优先于宏任务队列。微任务队列的代表就是，<code>Promise.then</code>，<code>MutationObserver</code>，宏任务的话就是<code>setImmediate setTimeout setInterval</code></p><p><strong>MacroTask（宏任务）*</strong></p><ul><li><code>script</code>全部代码、<code>setTimeout</code>、<code>setInterval</code>、<code>setImmediate</code>（浏览器暂时不支持，只有 IE10 支持，具体可见<a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/Window/setImmediate"><code>MDN</code></a>）、<code>I/O</code>、<code>UI Rendering</code>。</li></ul><p><strong>MicroTask（微任务）</strong></p><ul><li><code>Process.nextTick（Node独有）</code>、<code>Promise.then</code>、<code>Object.observe(废弃)</code>、<code>MutationObserver</code></li></ul><h4 id="浏览器中"><a href="#浏览器中" class="headerlink" title="浏览器中"></a>浏览器中</h4><blockquote><p>执行完一个宏任务，会执行所有的微任务</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;script start&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;setTimeout&quot;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;promise1&quot;</span>);</span><br><span class="line">  resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;promise2&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;script end&quot;</span>);</span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">script start</span><br><span class="line">promise1</span><br><span class="line">script end</span><br><span class="line">promise2</span><br><span class="line">setTimeout</span><br></pre></td></tr></table></figure><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/608a4edf58d141c88e75262938c3ac66.gif" alt="在这里插入图片描述"></p><h4 id="nodejs-中"><a href="#nodejs-中" class="headerlink" title="nodejs 中"></a>nodejs 中</h4><blockquote><p>在 11 之前的版本，会在每个阶段之后执行所有的微任务</p><p>在 11 版本及之后，会每执行完一个宏任务，就会清空所用的微任务（和浏览器保存一致）</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;new Promise 1&quot;</span>);</span><br><span class="line">  resolve();</span><br><span class="line">&#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;new Promise then&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;timer1&quot;</span>);</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;timer1 new Promise&quot;</span>);</span><br><span class="line">    resolve();</span><br><span class="line">  &#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;timer1 new Promise then&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;timer1 Promise then&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;timer2&quot;</span>);</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;timer2 Promise then&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;start end&quot;</span>);</span><br></pre></td></tr></table></figure><p>在 node11 版本之前（不包含 11）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">new Promise 1</span><br><span class="line">start end</span><br><span class="line">new Promise then</span><br><span class="line">timer1</span><br><span class="line">timer1 new Promise</span><br><span class="line">timer2</span><br><span class="line">timer1 new Promise then</span><br><span class="line">timer1 Promise then</span><br><span class="line">timer2 Promise then</span><br></pre></td></tr></table></figure><p>在 node11 版本及之后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">new Promise 1</span><br><span class="line">start end</span><br><span class="line">new Promise then</span><br><span class="line">timer1</span><br><span class="line">timer1 new Promise</span><br><span class="line">timer1 new Promise then</span><br><span class="line">timer1 Promise then</span><br><span class="line">timer2</span><br><span class="line">timer2 Promise then</span><br></pre></td></tr></table></figure><p><img src= "/img/loading1.gif" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b222442fa0904f0d956565597e1fab17~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p><code>Node</code>的<code>Event loop</code>一共分为 6 个阶段，每个细节具体如下：</p><ol><li> <code>timers</code>: 执行<code>setTimeout</code>和<code>setInterval</code>中到期的<code>callback</code>。</li><li> <code>pending callback</code>: 上一轮循环中少数的<code>callback</code>会放在这一阶段执行。</li><li> <code>idle, prepare</code>: 仅在内部使用。</li><li> <code>poll</code>: 最重要的阶段，执行<code>pending callback</code>，在适当的情况下回阻塞在这个阶段。</li><li> <code>check</code>: 执行<code>setImmediate</code>(<code>setImmediate()</code>是将事件插入到事件队列尾部，主线程和事件队列的函数执行完成之后立即执行<code>setImmediate</code>指定的回调函数)的<code>callback</code>。</li><li> <code>close callbacks</code>: 执行<code>close</code>事件的<code>callback</code>，例如<code>socket.on(&#39;close&#39;[,fn])</code>或者<code>http.server.on(&#39;close, fn)</code>。</li></ol><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h3 id="常见状态码"><a href="#常见状态码" class="headerlink" title="常见状态码"></a><strong>常见状态码</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1xx: 接受，继续处理 </span><br><span class="line">200: 成功，并返回数据 </span><br><span class="line">201: 已创建 </span><br><span class="line">202: 已接受 </span><br><span class="line">203: 成为，但未授权 </span><br><span class="line">204: 成功，无内容 </span><br><span class="line">205: 成功，重置内容 </span><br><span class="line">206: 成功，部分内容 </span><br><span class="line">301: 永久移动，重定向 </span><br><span class="line">302: 临时移动，可使用原有 URI </span><br><span class="line">304: 资源未修改，可使用缓存 </span><br><span class="line">305: 需代理访问 </span><br><span class="line">400: 请求语法错误 </span><br><span class="line">401: 要求身份认证 </span><br><span class="line">403: 拒绝请求 </span><br><span class="line">404: 资源不存在 </span><br><span class="line">500: 服务器错误</span><br></pre></td></tr></table></figure><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><blockquote><p><a href="https://juejin.cn/post/6844903958624878606">面试官，不要再问我三次握手和四次挥手</a></p></blockquote><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a><strong>三次握手</strong></h4><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/16da9fd28a45bd19~tplv-t2oaga2asx-watermark.awebp" alt="三次握手.png"></p><p><strong>为什么需要三次握手，两次不可以吗</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">为了防止失效的连接请求又传送到主机，因而产生错误。</span><br><span class="line">如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请</span><br><span class="line">求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于 TCP 的客</span><br><span class="line">户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条</span><br><span class="line">报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。</span><br><span class="line">此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失</span><br><span class="line">效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不</span><br><span class="line">必要的错误和资源的浪费。</span><br><span class="line"></span><br><span class="line">如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了</span><br><span class="line">那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器</span><br><span class="line">收不到确认，就知道客户端并没有请求连接。</span><br></pre></td></tr></table></figure><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/16da9fd28b49f652~tplv-t2oaga2asx-watermark.awebp" alt="image.png"></p><p><strong>挥手为什么需要四次？</strong></p><p>因为当服务端收到客户端的 SYN 连接请求报文后，可以直接发送 SYN+ACK 报文。其中<strong>ACK 报文是用来应答的，SYN 报文是用来同步的</strong>。但是关闭连接时，当服务端收到 FIN 报文时，很可能并不会立即关闭 SOCKET，所以只能先回复一个 ACK 报文，告诉客户端，”你发的 FIN 报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送 FIN 报文，因此不能一起发送。故需要四次挥手。</p><p><strong><code>2MSL</code>等待状态</strong></p><p>TIME_WAIT 状态也成为<code>2MSL</code>等待状态。每个具体 TCP 实现必须选择一个报文段最大生存时间 MSL（Maximum Segment Lifetime），它是任何报文段被丢弃前在网络内的最长时间。这个时间是有限的，因为 TCP 报文段以 IP 数据报在网络内传输，而 IP 数据报则有限制其生存时间的 TTL 字段。</p><p>对一个具体实现所给定的 MSL 值，处理的原则是：当 TCP 执行一个主动关闭，并发回最后一个 ACK，该连接必须在 TIME_WAIT 状态停留的时间为 2 倍的 MSL。这样可让 TCP 再次发送最后的 ACK 以防这个 ACK 丢失（另一端超时并重发最后的 FIN）。</p><p>这种 2MSL 等待的另一个结果是这个 TCP 连接在 2MSL 等待期间，定义这个连接的插口（客户的 IP 地址和端口号，服务器的 IP 地址和端口号）不能再被使用。这个连接只能在 2MSL 结束后才能再被使用。</p><h3 id="HTTP-版本"><a href="#HTTP-版本" class="headerlink" title="HTTP 版本"></a>HTTP <strong>版本</strong></h3><p>HTTP/1.0 </p><p>最早的 http 只是使用一些简单的网页上和网络请求上，每次请求都打开一个新的 TCP 连接， 收到响应后立即断开连接 </p><p>HTTP/1.1<br>缓存处理，HTTP/1.1 更多的引入了缓存策略，如 Cache-Control，Entity tag，If-Unmodified-Since, If-Match, If-None-Match 等 </p><p>宽带优化及网络连接的使用，在 HTTP/1.0 中，存在一些浪费宽带的现象，列如客户端只需要某个对象的一部分，而服务器把整个对象都送过来了，并且不支持断点续传，HTTP1.1 则 </p><p>在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（PartialContent），这样就方便了开发者自由的选择以便于充分利用带宽和连接。 </p><p>错误通知的管理，在 HTTP/1.1 中新增了 24 个错误状态响应码，如 409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。 </p><p>Host 头处理，在 HTTP1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中 </p><p>的 URL 并没有传递主机名。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多 </p><p>个虚拟主机（Multi-homed Web Servers），并且它们共享一个 IP 地址。HTTP1.1 的请求消息和响应消息都应支持 Host 头域，且请求消息中如果没有 Host 头域会报告一个错误（400 Bad Request） </p><p>长连接， HTTP/1.1 默认开启持久连接（默认：keep-alive），在一个 TCP 连接上可以传递多 </p><p>个 HTTP 请求和响应，减少了建立与关闭连接的消耗和延迟 </p><p>HTTP/2.0 </p><p>在 HTTP/2.0 中，有两个重要的概念，分别是帧（frame） 和 流（stream），帧代表数据传输 </p><p>的最小单位，每个帧都有序列标识标明该帧属于哪个流，流也就是多个帧组成的数据流，每 </p><p>个流表示一个请求。 </p><p>新的二进制格式： HTTP/1.x 的解析是基于文本的。基于文本协议的格式解析存在天然缺陷， </p><p>文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认 0 和 1 </p><p>的组合。基于这种考虑 HTTP2.0 的协议解析决定采用二进制格式，实现方便且健壮。 </p><p>多路复用： HTTP/2.0 支持多路复用，这是 HTTP/1.1 持久连接的升级版。多路复用，就是在 </p><p>一个 TCP 连接中存在多个条流，也就是多个请求，服务器则可以通过帧中的标识知道该帧属 </p><p>于哪个流（即请求），通过重新排序还原请求。多路复用允许并发多个请求，每个请求及该 </p><p>请求的响应不需要等待其他的请求或响应，避免了线头阻塞问题。这样某个请求任务耗时严 </p><p>重，不会影响到其它连接的正常执行,极大的提高传输性能。 </p><p>头部压缩： 对前面提到的 HTTP/1.x 的 header 带有大量信息，而且每次都要重复发送， </p><p>HTTP/2.0 使用 encoder 来减少需要传输的头部大小，通讯双方各自 cache 一份头部 fields 表， </p><p>既避免了重复头部的传输，又减小了需要传输的大小。 </p><p>服务端推送： 服务端推送指把客户端所需要的 css/js/img 资源伴随着 index.html 一起发送 </p><p>到客户端，省去了客户端重复请求的步骤（从缓存中取）。正因为没有发起请求，建立连接 </p><p>等操作，所以静态资源通过服务端推送的方式极大的提升了速度HTTP/3.0 </p><p>HTTP/2.0 使用了多路复用，一般来说同一域名下只需要使用一个 TCP 连接。但当这个连接中 </p><p>出现了丢包的情况，会导致整个 TCP 都要开始等待重传，也就导致了后面所有的数据都阻塞了。</p><p>避免包阻塞： 多个流的数据包在 TCP 连接上传输时，若一个流中的数据包传输出现问题， </p><p>TCP 需要等待该包重传后，才能继续传输其它流的数据包。但在基于 UDP 的 QUIC 协议中， </p><p>不同的流之间的数据传输真正实现了相互独立互不干扰，某个流的数据包在出问题需要重传 </p><p>时，并不会对其他流的数据包传输产生影响。 </p><p>快速重启会话: 普通基于 tcp 的连接，是基于两端的 ip 和端口和协议来建立的。在网络切换 </p><p>场景，例如手机端切换了无线网，使用 4G 网络，会改变本身的 ip，这就导致 tcp 连接必须 </p><p>重新创建。而 QUIC 协议使用特有的 UUID 来标记每一次连接，在网络环境发生变化的时候， </p><p>只要 UUID 不变，就能不需要握手，继续传输数据。 </p><p>HTTP2.0 的多路复用和 HTTP1.X 中的长连接有什么区别？ </p><p>HTTP/1.* 一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接； </p><p>HTTP/1.1 在一个 TCP 连接上可以传递多个 HTTP 请求和响应，后面的请求等待前面的请求返 </p><p>回才能获得执行机会，一旦有某个请求超时，后续请求只能被阻塞，毫无办法，也就是常说 </p><p>的线头阻塞 </p><p>HTTP/2.0 多个请求可同时在一个连接上并行执行.某个请求任务耗时严重，不影响其他连接 </p><p>的正常执行。 </p><h3 id="https-http-ssl-tls"><a href="#https-http-ssl-tls" class="headerlink" title="https(http + ssl/tls)"></a>https(http + ssl/tls)</h3><p>http: 最广泛网络协议，BS 模型，浏览器高效。</p><p>https: 安全版，通过 SSL 加密，加密传输，身份认证，密钥</p><p>1 https 相对于 http 加入了 ssl 层, 加密传输, 身份认证;</p><p>2 需要到 ca 申请收费的证书;</p><p>3 安全但是耗时多，缓存不是很好;</p><p>4 注意兼容 http 和 https;</p><p>5 连接方式不同, 端口号也不同, http 是 80, https 是 443</p><ul><li><p>明文： 普通的文本</p></li><li><p>密钥：把明文加密的那个钥匙</p></li><li><p>密文： 把明文加密</p><p>明文+密钥==&gt;密文==&gt;密钥==解密=&gt;明文</p></li><li><p>对称加密 解密的 key（密钥）和解密的 key 是同一个 3 + 1</p></li><li><p>非对称加密 私钥和公钥</p></li></ul><p><img src= "/img/loading1.gif" data-lazy-src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/489428dbcc4840d689ed717d4335a833~tplv-k3u1fbpfcp-watermark.image" alt="无标题.png"></p><h2 id="手写"><a href="#手写" class="headerlink" title="手写"></a>手写</h2><blockquote><p><a href="https://juejin.cn/post/7031322059414175774">10 个常见的前端手写功能，你全都会吗</a></p></blockquote><p>最近面试 2022 年 3 月问到了很多手写，这个一定要准备下</p><h3 id="防抖-1"><a href="#防抖-1" class="headerlink" title="防抖"></a>防抖</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait, immediate</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timeout;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> context = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">const</span> args = [...arguments];</span><br><span class="line">    <span class="keyword">if</span> (timeout) <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">    <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">      <span class="keyword">const</span> callNow = !timeout;</span><br><span class="line">      timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        timeout = <span class="literal">null</span>;</span><br><span class="line">      &#125;, wait);</span><br><span class="line">      <span class="keyword">if</span> (callNow) func.apply(context, args);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        func.apply(context, args);</span><br><span class="line">      &#125;, wait);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="节流-1"><a href="#节流-1" class="headerlink" title="节流"></a>节流</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> pre = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> now = <span class="built_in">Date</span>.now();</span><br><span class="line">    <span class="keyword">if</span> (now - pre &gt;= wait) &#123;</span><br><span class="line">      fn.apply(<span class="built_in">this</span>, args);</span><br><span class="line">      pre = now;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="event-bus-事件总线-发布订阅模式"><a href="#event-bus-事件总线-发布订阅模式" class="headerlink" title="event bus 事件总线 | 发布订阅模式"></a>event bus 事件总线 | 发布订阅模式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// event bus</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventBus</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.events = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">on</span>(<span class="params">name, callback</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; events &#125; = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (!events[name]) &#123;</span><br><span class="line">      events[name] = [];</span><br><span class="line">    &#125;</span><br><span class="line">    events[name].push(callback);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">emit</span>(<span class="params">name, ...args</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> handlers = <span class="built_in">this</span>.events[name];</span><br><span class="line">    handlers &amp;&amp;</span><br><span class="line">      handlers.forEach(<span class="function">(<span class="params">fn</span>) =&gt;</span> &#123;</span><br><span class="line">        fn.apply(<span class="built_in">this</span>, args);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">off</span>(<span class="params">name, callback</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; events &#125; = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (!events[name]) <span class="keyword">return</span>;</span><br><span class="line">    events[name] = events[name].filter(<span class="function">(<span class="params">fn</span>) =&gt;</span> fn !== callback);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">once</span>(<span class="params">name, callback</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> handler = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      callback.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">      <span class="built_in">this</span>.off(name, handler);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">this</span>.on(name, handler);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">clear</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.events = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数据偏平化"><a href="#数据偏平化" class="headerlink" title="数据偏平化"></a>数据偏平化</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据偏平化</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatter</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">prev, curr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.isArray(curr) ? [...prev, ...flatter(curr)] : [...prev, curr];</span><br><span class="line">  &#125;, []);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="手写-new"><a href="#手写-new" class="headerlink" title="手写 new"></a>手写 new</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 手写 new</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myNew</span>(<span class="params">ctr, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> obj = <span class="built_in">Object</span>.create(ctr.prototype);</span><br><span class="line">  myNew.target = ctr;</span><br><span class="line">  <span class="keyword">const</span> result = ctr.apply(obj, args);</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    result &amp;&amp;</span><br><span class="line">    (<span class="keyword">typeof</span> result === <span class="string">&quot;function&quot;</span> || <span class="keyword">typeof</span> result === <span class="string">&quot;function&quot;</span>)</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="call、bind"><a href="#call、bind" class="headerlink" title="call、bind"></a>call、bind</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span> (<span class="params">context, ...args</span>) </span>&#123;</span><br><span class="line">  context = context || <span class="built_in">window</span>;</span><br><span class="line">  <span class="keyword">const</span> fn = <span class="built_in">Symbol</span>();</span><br><span class="line">  context[fn] = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">const</span> result = context[fn](...args);</span><br><span class="line">  <span class="keyword">delete</span> context[fn];</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//bind实现要复杂一点  因为他考虑的情况比较多 还要涉及到参数合并(类似函数柯里化)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span> (<span class="params">context, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!context || context === <span class="literal">null</span>) &#123;</span><br><span class="line">    context = <span class="built_in">window</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创造唯一的key值  作为我们构造的context内部方法名</span></span><br><span class="line">  <span class="keyword">let</span> fn = <span class="built_in">Symbol</span>();</span><br><span class="line">  context[fn] = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">let</span> _this = <span class="built_in">this</span>;</span><br><span class="line">  <span class="comment">//  bind情况要复杂一点</span></span><br><span class="line">  <span class="keyword">const</span> result = <span class="function"><span class="keyword">function</span> (<span class="params">...innerArgs</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 第一种情况 :若是将 bind 绑定之后的函数当作构造函数，通过 new 操作符使用，则不绑定传入的 this，而是将 this 指向实例化出来的对象</span></span><br><span class="line">    <span class="comment">// 此时由于new操作符作用  this指向result实例对象  而result又继承自传入的_this 根据原型链知识可得出以下结论</span></span><br><span class="line">    <span class="comment">// this.__proto__ === result.prototype   //this instanceof result =&gt;true</span></span><br><span class="line">    <span class="comment">// this.__proto__.__proto__ === result.prototype.__proto__ === _this.prototype; //this instanceof _this =&gt;true</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> <span class="keyword">instanceof</span> _this === <span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="comment">// 此时this指向指向result的实例  这时候不需要改变this指向</span></span><br><span class="line">      <span class="built_in">this</span>[fn] = _this;</span><br><span class="line">      <span class="built_in">this</span>[fn](...[...args, ...innerArgs]); <span class="comment">//这里使用es6的方法让bind支持参数合并</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果只是作为普通函数调用  那就很简单了 直接改变this指向为传入的context</span></span><br><span class="line">      context[fn](...[...args, ...innerArgs]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 如果绑定的是构造函数 那么需要继承构造函数原型属性和方法</span></span><br><span class="line">  <span class="comment">// 实现继承的方式: 使用Object.create</span></span><br><span class="line">  result.prototype = <span class="built_in">Object</span>.create(<span class="built_in">this</span>.prototype);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="异步控制并发数"><a href="#异步控制并发数" class="headerlink" title="异步控制并发数"></a>异步控制并发数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">limitRequest</span>(<span class="params">requests, limit = <span class="number">3</span></span>) </span>&#123;</span><br><span class="line">  requests = requests.slice();</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> len = requests.length;</span><br><span class="line">    <span class="keyword">while</span> (limit &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      start();</span><br><span class="line">      limit--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> promiseFn = requests.shift();</span><br><span class="line"></span><br><span class="line">      promiseFn?.().finally(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        count++; <span class="comment">// 一定要通过 count 判断、不能通过 requests.length 判断是否为空，这样不对的</span></span><br><span class="line">        <span class="keyword">if</span> (count === len) &#123;</span><br><span class="line">          <span class="comment">// 最后一个</span></span><br><span class="line">          resolve();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          start();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">const</span> arr = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> <span class="string">&quot;12345&quot;</span>) &#123;</span><br><span class="line">  arr.push(<span class="function">() =&gt;</span> fetch(<span class="string">`https://www.baidu.com/s?ie=UTF-8&amp;wd=<span class="subst">$&#123;value&#125;</span>`</span>));</span><br><span class="line">&#125;</span><br><span class="line">limitRequest(arr);</span><br></pre></td></tr></table></figure><h2 id="算法-特殊题目"><a href="#算法-特殊题目" class="headerlink" title="算法/特殊题目"></a>算法/特殊题目</h2><p>最近面试 2022 年 3 月问到了很多手写，这个一定要准备下、下面都是我被问到的</p><h3 id="台阶问题"><a href="#台阶问题" class="headerlink" title="台阶问题"></a>台阶问题</h3><p>有 N 个台阶，一步可以走一梯或者两梯，请问有多少种走法</p><p>解答：<a href="https://blog.csdn.net/z1832729975/article/details/123836190">https://blog.csdn.net/z1832729975/article/details/123836190</a></p><h3 id="有效括号"><a href="#有效括号" class="headerlink" title="有效括号"></a>有效括号</h3><blockquote><p>我面试才几家，这个有两家都问到了 <a href="https://leetcode-cn.com/problems/valid-parentheses/">力扣原题</a></p></blockquote><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p><p>有效字符串需满足：</p><p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：s &#x3D; &quot;()&quot;</span><br><span class="line">输出：true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：s &#x3D; &quot;()[]&#123;&#125;&quot;</span><br><span class="line">输出：true</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：s &#x3D; &quot;(]&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>实现</strong></p><p>我们可以通过栈来实现、当遇到左括号的时候就把对应的右括号值<code>push</code>到栈中，否则的话我们就把栈定的元素<code>pop</code>和当前字符比较是否相等，不相信的话直接返回 <code>false</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isValid = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!s) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">const</span> leftFlags = &#123;</span><br><span class="line">    <span class="string">&quot;(&quot;</span>: <span class="string">&quot;)&quot;</span>,</span><br><span class="line">    <span class="string">&quot;&#123;&quot;</span>: <span class="string">&quot;&#125;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;[&quot;</span>: <span class="string">&quot;]&quot;</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> stack = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> chart <span class="keyword">of</span> s) &#123;</span><br><span class="line">    <span class="keyword">const</span> flag = leftFlags[chart];</span><br><span class="line">    <span class="comment">// 是左括号</span></span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">      stack.push(flag);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 是右括号</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (chart !== stack.pop()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> stack.length === <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="现在时间-07-15，请问分针和时针的夹角是多少"><a href="#现在时间-07-15，请问分针和时针的夹角是多少" class="headerlink" title="现在时间 07:15，请问分针和时针的夹角是多少"></a>现在时间 07:15，请问分针和时针的夹角是多少</h3><p>先看看时钟，要了解 07:15 在哪，这个不知道在哪就尴尬了</p><p><img src= "/img/loading1.gif" data-lazy-src="https://img-blog.csdnimg.cn/833a03cad6e346789184fbe5643ec241.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAemjpmL_po54=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>画图，结果如下</p><p>7 点 15 分时针和分针所形成的角是</p><p>120 + 30*1/4=127.5</p><p>这题需要注意时针还好继续走，不会固定，不然容易被坑</p><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220331153206674.png" alt="image-20220331153206674"></p><h3 id="写-IP-地址的正则表达式"><a href="#写-IP-地址的正则表达式" class="headerlink" title="写 IP 地址的正则表达式"></a>写 IP 地址的正则表达式</h3><p>分析<code>ip</code>地址</p><h3 id="让-a-1-amp-amp-a-2-amp-amp-a-3-为-true"><a href="#让-a-1-amp-amp-a-2-amp-amp-a-3-为-true" class="headerlink" title="让 a==1 &amp;&amp; a==2 &amp;&amp; a==3 为 true"></a>让 <code>a==1 &amp;&amp; a==2 &amp;&amp; a==3</code> 为 <code>true</code></h3><blockquote><p>因为这个是 ==, 会存在隐式类型转换</p></blockquote><ul><li><p>利用对象</p><p><code>Symbol.toString</code></p><p><code>valueOf</code></p><p><code>toString</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  value: <span class="number">1</span>,</span><br><span class="line">  <span class="comment">// 这三种方法都可以，优先级也是这个顺序</span></span><br><span class="line">  [<span class="built_in">Symbol</span>.toString]() &#123;</span><br><span class="line">    <span class="keyword">return</span> a.value++;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// valueOf() &#123;</span></span><br><span class="line">  <span class="comment">//   return a.value++</span></span><br><span class="line">  <span class="comment">// &#125;,</span></span><br><span class="line">  <span class="comment">// toString() &#123;</span></span><br><span class="line">  <span class="comment">//   return a.value++</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>利用数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a.valueOf = a.shift;</span><br><span class="line"><span class="comment">// 一样有</span></span><br><span class="line"><span class="comment">//a[Symbol.toPrimitive] = a.shift</span></span><br><span class="line"><span class="comment">//a.toString = a.shift</span></span><br></pre></td></tr></table></figure></li><li><p>通过<code>Object.defineProperty</code>拦截</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">window</span>, <span class="string">&quot;a&quot;</span>, &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value++;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>通过 Proxy 拦截</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="built_in">Proxy</span>(</span><br><span class="line">  &#123;&#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value++;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="typescript"><a href="#typescript" class="headerlink" title="typescript"></a>typescript</h2></li></ul><blockquote><p>建议先把基础的东西学会，推荐看这篇文章、基础的学会，就能应付大多数的 typescript 面试了</p><p><a href="https://juejin.cn/post/7018805943710253086">2021 typescript 史上最强学习入门文章(2w 字)</a></p></blockquote><h3 id="const和readonly的区别"><a href="#const和readonly的区别" class="headerlink" title="const和readonly的区别"></a><code>const</code>和<code>readonly</code>的区别</h3><p><code>const</code>常量：表示这个变量的指针地址不可以在改变，可以更改对象内部的属性</p><p><code>readonly</code>只读：指针地址不可以改变，并且对象内部的属性也不可以改变</p><ol><li>const 用于变量，readonly 用于属性</li><li>const 在运行时检查，readonly 在编译时检查</li><li>使用 const 变量保存的数组，可以使用 push，pop 等方法。但是如果使用<code>ReadonlyArray</code>声明的数组不能使用 push，pop 等方法。</li></ol><h3 id="type和interface的区别"><a href="#type和interface的区别" class="headerlink" title="type和interface的区别"></a><code>type</code>和<code>interface</code>的区别</h3><p>参考：<a href="https://juejin.cn/post/7018805943710253086#heading-63">https://juejin.cn/post/7018805943710253086#heading-63</a></p><p>type-类型别名</p><p>interface-接口</p><ol start="2"><li><p>接口重名会合并、类型别名重名会报错</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个接口合并，变成下面的</span></span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Aanimal = &#123; <span class="attr">name</span>: <span class="built_in">string</span> &#125;;</span><br><span class="line"><span class="keyword">type</span> Aanimal = &#123; <span class="attr">age</span>: <span class="built_in">number</span> &#125;; <span class="comment">// 会报错、重名了</span></span><br></pre></td></tr></table></figure></li><li><p>两者都可以用来描述对象或函数的类型，但是语法不同</p><p>interface</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Point &#123;</span><br><span class="line">  x: <span class="built_in">number</span>;</span><br><span class="line">  y: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> SetPoint &#123;</span><br><span class="line">  (x: <span class="built_in">number</span>, <span class="attr">y</span>: <span class="built_in">number</span>): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>type</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Point = &#123;</span><br><span class="line">  x: <span class="built_in">number</span>;</span><br><span class="line">  y: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SetPoint = <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br></pre></td></tr></table></figure></li><li><p>类型别名可以为任何类型引入名称。例如基本类型，联合类型等</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// primitive</span></span><br><span class="line"><span class="keyword">type</span> Name = <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// object</span></span><br><span class="line"><span class="keyword">type</span> PartialPointX = &#123; <span class="attr">x</span>: <span class="built_in">number</span> &#125;;</span><br><span class="line"><span class="keyword">type</span> PartialPointY = &#123; <span class="attr">y</span>: <span class="built_in">number</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// union</span></span><br><span class="line"><span class="keyword">type</span> PartialPoint = PartialPointX | PartialPointY;</span><br><span class="line"></span><br><span class="line"><span class="comment">// tuple</span></span><br><span class="line"><span class="keyword">type</span> Data = [<span class="built_in">number</span>, <span class="built_in">string</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// dom</span></span><br><span class="line"><span class="keyword">let</span> div = <span class="built_in">document</span>.createElement(<span class="string">&quot;div&quot;</span>);</span><br><span class="line"><span class="keyword">type</span> B = <span class="keyword">typeof</span> div;</span><br></pre></td></tr></table></figure></li><li><p>扩展</p><p>两者的扩展方式不同，但并不互斥。接口可以扩展类型别名，同理，类型别名也可以扩展接口。</p><p>接口的扩展就是继承，通过 <code>extends</code> 来实现。类型别名的扩展就是交叉类型，通过 <code>&amp;</code> 来实现。</p><p>接口扩展接口</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> PointX &#123;</span><br><span class="line">  x: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Point <span class="keyword">extends</span> PointX &#123;</span><br><span class="line">  y: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类型别名扩展类型别名</p></li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PointX = &#123;</span><br><span class="line">  x: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Point = PointX &amp; &#123;</span><br><span class="line">  y: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接口扩展类型别名</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PointX = &#123;</span><br><span class="line">  x: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">interface</span> Point <span class="keyword">extends</span> PointX &#123;</span><br><span class="line">  y: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类型别名扩展接口</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> PointX &#123;</span><br><span class="line">  x: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Point = PointX &amp; &#123;</span><br><span class="line">  y: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="keyof-和-typeof-关键字的作用？"><a href="#keyof-和-typeof-关键字的作用？" class="headerlink" title="keyof 和 typeof 关键字的作用？"></a><strong>keyof 和 typeof 关键字的作用？</strong></h3><blockquote><p><code>keyof 索引类型查询操作符</code> 获取索引类型的属性名，构成联合类型。<br><code>typeof</code> 获取一个变量或对象的类型。</p></blockquote><h3 id="unknown-any-的区别"><a href="#unknown-any-的区别" class="headerlink" title="unknown, any 的区别"></a>unknown, any 的区别</h3><blockquote><p>unknown 类型和 any 类型类似。与 any 类型不同的是。unknown 类型可以接受任意类型赋值，但是 unknown 类型赋值给其他类型前，必须被断言</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo提交问题</title>
      <link href="2021/06/19/hexo%E6%8F%90%E4%BA%A4%E9%97%AE%E9%A2%98/"/>
      <url>2021/06/19/hexo%E6%8F%90%E4%BA%A4%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="hexo提交问题"><a href="#hexo提交问题" class="headerlink" title="hexo提交问题"></a>hexo提交问题</h1><h2 id="解决报错：Failed-to-connect-to-github-com-port-443-after-21098-ms-Timed-out"><a href="#解决报错：Failed-to-connect-to-github-com-port-443-after-21098-ms-Timed-out" class="headerlink" title="解决报错：Failed to connect to github.com port 443 after 21098 ms: Timed out"></a>解决报错：Failed to connect to github.com port 443 after 21098 ms: Timed out</h2><h3 id="错误信息："><a href="#错误信息：" class="headerlink" title="错误信息："></a><strong>错误信息：</strong></h3><p><img src= "/img/loading1.gif" data-lazy-src="https://img-blog.csdnimg.cn/33a75ba3ec6d446aae2d176bf2a644ed.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5YmN56uv5bCP5a2m55SfICjil4_igJTil48p,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><p><strong>原因：</strong> 这样的问题往往是由于网络慢访问超时，这时候我们可以在终端选择使用设置代理和取消代理的命令解决。</p><h3 id="设置代理："><a href="#设置代理：" class="headerlink" title="设置代理："></a>设置代理：</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">config</span> <span class="comment">--global https.proxy</span></span><br></pre></td></tr></table></figure><h3 id="取消代理："><a href="#取消代理：" class="headerlink" title="取消代理："></a>取消代理：</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">config</span> <span class="comment">--global --unset https.proxy</span></span><br></pre></td></tr></table></figure><h3 id="解决步骤：我们直接在终端先输入设置代理的命令，再输入取消代理的命令即可解决"><a href="#解决步骤：我们直接在终端先输入设置代理的命令，再输入取消代理的命令即可解决" class="headerlink" title="解决步骤：我们直接在终端先输入设置代理的命令，再输入取消代理的命令即可解决"></a><strong>解决步骤：</strong>我们直接在终端先输入设置代理的命令，再输入取消代理的命令即可解决</h3><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5YmN56uv5bCP5a2m55SfICjil4_igJTil48p,size_18,color_FFFFFF,t_70,g_se,x_16.png" alt="img"></p><p>​     如此，再输入我用的git指令，就可以将github的仓库克隆下来了。也成功解决了这个问题。</p>]]></content>
      
      
      <categories>
          
          <category> hexo错误 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo post question </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue2知识总结(二)</title>
      <link href="2021/06/19/Vue2%E7%AC%94%E8%AE%B0-%E4%B8%89/"/>
      <url>2021/06/19/Vue2%E7%AC%94%E8%AE%B0-%E4%B8%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue2知识总结（三）"><a href="#Vue2知识总结（三）" class="headerlink" title="Vue2知识总结（三）"></a>Vue2知识总结（三）</h1><h2 id="vue-route"><a href="#vue-route" class="headerlink" title="vue-route"></a>vue-route</h2><ul><li>vue-router是基于路由和组件的<ul><li>路由用于设定访问路径, 将路径和组件映射起来.</li><li>在vue-router的单页面应用中, 页面的路径的改变就是组件的切换.</li></ul></li></ul><h3 id="安装和使用vue-router"><a href="#安装和使用vue-router" class="headerlink" title="安装和使用vue-router"></a>安装和使用vue-router</h3><ul><li>步骤一: 安装vue-router </li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">npm</span> <span class="selector-tag">install</span> <span class="selector-tag">vue-router</span> <span class="selector-tag">--save</span></span><br></pre></td></tr></table></figure><ul><li>步骤二: 在模块化工程中使用它(因为是一个插件, 所以可以通过Vue.use()来安装路由功能) </li></ul><p>第一步：<strong>导入</strong>路由对象，并且调用 <strong>Vue.use(VueRouter)</strong></p><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220517160237976.png" alt="image-20220517160237976"></p><p>第二步：创建路由实例，并且传入路由映射配置</p><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220517160331131.png" alt="image-20220517160331131"></p><p>第三步：在<strong>Vue实例</strong>中<strong>挂载</strong>创建的<strong>路由实例</strong></p><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220517160416016.png" alt="image-20220517160416016"></p><p>使用vue-router的步骤:</p><ul><li><p>第一步: 创建路由组件</p><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220517160703947.png" alt="image-20220517160703947"></p></li></ul><p>第二步: 配置路由映射: 组件和路径映射关系</p><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220517160956809.png" alt="image-20220517160956809"></p><ul><li>第三步: 使用路由: 通过<router-link>和<router-view></li></ul><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220517161022121.png" alt="image-20220517161022121"></p><ul><li><router-link>: 该标签是一个vue-router中已经内置的组件, 它会被渲染成一个<a>标签.</li><li><router-view>: 该标签会根据当前的路径, 动态渲染出不同的组件. </li><li>网页的其他内容, 比如顶部的标题/导航, 或者底部的一些版权信息等会和<router-view>处于同一个等级.</li><li>在路由切换时, 切换的是<router-view>挂载的组件, 其他内容不会发生改变.</li></ul><h3 id="路由的默认路径"><a href="#路由的默认路径" class="headerlink" title="路由的默认路径"></a>路由的默认路径</h3><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220517161156358.png" alt="image-20220517161156358"></p><ul><li>配置解析:<ul><li>我们在routes中又配置了一个映射.</li><li>path配置的是根路径: /</li><li><strong>redirect是重定向,</strong> 也就是我们将根路径重定向到/home的路径下, 这样就可以得到我们想要的结果了. </li></ul></li></ul><h3 id="HTML5的History模式"><a href="#HTML5的History模式" class="headerlink" title="HTML5的History模式"></a>HTML5的History模式</h3><ul><li>我们前面说过改变路径的方式有两种:<ul><li>URL的hash</li><li>HTML5的history</li><li>默认情况下, 路径的改变使用的URL的hash.</li></ul></li><li>如果希望使用HTML5的history模式, 非常简单, 进行如下配置即可: </li></ul><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220517161534219.png" alt="image-20220517161534219"></p><p>hash的url是带# 而history是不带的</p><h3 id="router-link补充"><a href="#router-link补充" class="headerlink" title="router-link补充"></a>router-link补充</h3><p><router-link>还有一些其他属性:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&#x27;/home&#x27;</span> <span class="attr">tag</span>=<span class="string">&#x27;li&#x27;</span> <span class="attr">replace</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong>属性: to,</strong> 用于指定跳转的路径. </li><li>tag: tag可以指定<router-link>之后渲染成什么组件, 比如上面的代码会被渲染成一个<li>元素, 而不是<a></li><li>replace: replace不会留下history记录, 所以指定replace的情况下, 后退键返回不能返回到上一个页面中</li><li>active-class: 当<router-link>对应的路由匹配成功时, 会自动给当前元素设置一个router-link-active的class, 设置active-class可以修改默认的名称.</li><li>在进行高亮显示的导航菜单或者底部tabbar时, 会使用到该类.</li><li>但是通常不会修改类的属性, 会直接使用默认的router-link-active即可.</li></ul><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220517161923241.png" alt="image-20220517161923241"></p><h3 id="修改linkActiveClass"><a href="#修改linkActiveClass" class="headerlink" title="修改linkActiveClass"></a>修改linkActiveClass</h3><ul><li>该class具体的名称也可以通过router实例的属性进行修改</li></ul><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220517162129848.png" alt="image-20220517162129848"></p><ul><li>exact-active-class 类似于active-class,</li><li>只是在精准匹配下才会出现的class.</li><li>后面看到嵌套路由时, 我们再看下这个属性.</li></ul><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220517162140769.png" alt="image-20220517162140769"></p><h3 id="路由代码跳转"><a href="#路由代码跳转" class="headerlink" title="路由代码跳转"></a>路由代码跳转</h3><ul><li>router里的index.js </li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置路由相关的信息</span></span><br><span class="line"><span class="comment">// 导入路由对象</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">&#x27;../components/Home&#x27;</span></span><br><span class="line"><span class="keyword">import</span> About <span class="keyword">from</span> <span class="string">&#x27;../components/About&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 1.通过Vue.use(插件), 安装插件</span></span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 2.创建VueRouter对象</span></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="comment">// redirect重定向</span></span><br><span class="line">    redirect: <span class="string">&#x27;/home&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">    component: Home</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">    component: About</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"><span class="comment">// 创建路由实例，并且传入路由映射配置</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  <span class="comment">// 配置路由和组件之间的应用关系</span></span><br><span class="line">  routes,</span><br><span class="line">  mode: <span class="string">&#x27;history&#x27;</span>,</span><br><span class="line">  linkActiveClass: <span class="string">&#x27;active&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 3.将router对象传入到Vue实例</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure><ul><li>App.vue</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是APP组件<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用路由 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;router-link to=&quot;/home&quot; tag=&quot;button&quot; replace active-class=&quot;active&quot;&gt;首页&lt;/router-link&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;router-link to=&quot;/about&quot; tag=&quot;button&quot; replace active-class=&quot;active&quot;&gt;关于&lt;/router-link&gt;--&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/home&quot;</span> <span class="attr">tag</span>=<span class="string">&quot;button&quot;</span> <span class="attr">replace</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/about&quot;</span> <span class="attr">tag</span>=<span class="string">&quot;button&quot;</span> <span class="attr">replace</span>&gt;</span>关于<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- // 通过代码的方式修改路由 vue-router --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;button @click=&quot;homeClick&quot;&gt;首页&lt;/button&gt;</span></span><br><span class="line"><span class="comment">    &lt;button @click=&quot;aboutClick&quot;&gt;关于&lt;/button&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  name: <span class="string">&#x27;App&#x27;</span>,</span></span><br><span class="line">  methods: &#123;</span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">homeClick</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 通过代码的方式修改路由 vue-router</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// push =&gt; pushState</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// this.$router.push(&#x27;/home&#x27;)</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.$router.replace(<span class="string">&#x27;/home&#x27;</span>)</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&#x27;homeClick&#x27;</span>);</span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">aboutClick</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// this.$router.push(&#x27;/about&#x27;)</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.$router.replace(<span class="string">&#x27;/about&#x27;</span>)</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&#x27;aboutClick&#x27;</span>);</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="comment">/*.router-link-active &#123;*/</span></span></span><br><span class="line"><span class="css">    <span class="comment">/*color: #f00;*/</span></span></span><br><span class="line"><span class="css">  <span class="comment">/*&#125;*/</span></span></span><br><span class="line"> </span><br><span class="line"><span class="css">  <span class="selector-class">.active</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">color</span>: <span class="selector-id">#f00</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h3><ul><li>在某些情况下，一个页面的path路径可能是不确定的，比如我们进入用户界面时，希望是如下的路径：</li><li>/user/aaaa或/user/bbbb</li><li>除了有前面的/user之外，后面还跟上了用户的ID</li><li>这种path和Component的匹配关系，我们称之为动态路由(也是路由传递数据的一种方式)。 </li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- app.vue --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 动态拼接 使用v-bind --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&quot;&#x27;/user/&#x27;+userId&quot;</span>&gt;</span>用户<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  name: <span class="string">&quot;App&quot;</span>,</span></span><br><span class="line">  components: &#123;&#125;,</span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">      userId: <span class="string">&quot;zhangsan&quot;</span></span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- router.js --&gt;</span></span><br><span class="line">const routes = [</span><br><span class="line">    ...</span><br><span class="line">    &#123;</span><br><span class="line">        path:&#x27;/user/:id&#x27;,</span><br><span class="line">        component:User</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- user.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>$route.params.id:&#123;&#123;$route.params.id&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 即可拿到路由携带过来的数据 --&gt;</span></span><br></pre></td></tr></table></figure><h3 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h3><ul><li><p>首先, 我们知道路由中通常会定义很多不同的页面.</p></li><li><p>这个页面最后被打包在哪里呢? 一般情况下, 是放在一个js文件中.</p></li><li><p>但是, 页面这么多放在一个js文件中, 必然会造成这个页面非常的大.</p></li><li><p>如果我们一次性从服务器请求下来这个页面, 可能需要花费一定的时间, 甚至用户的电脑上还出现了短暂空白的情况.</p></li><li><p>如何避免这种情况呢? 使用路由懒加载就可以了.</p></li><li><p>路由懒加载做了什么?</p><ul><li>路由懒加载的主要作用就是将路由对应的组件打包成一个个的js代码块.</li><li>只有在这个路由被访问到的时候, 才加载对应的组件</li></ul></li></ul><p><strong>实现</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在ES6中, 我们可以有更加简单的写法来组织Vue异步组件和Webpack的代码分割.</span></span><br><span class="line"><span class="keyword">const</span> Home = <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;../components/Home.vue&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="路由嵌套"><a href="#路由嵌套" class="headerlink" title="路由嵌套"></a>路由嵌套</h3><ul><li>嵌套路由是一个很常见的功能<ul><li>比如在home页面中, 我们希望通过/home/news和/home/message访问一些内容.</li><li>一个路径映射一个组件, 访问这两个路径也会分别渲染两个组件.</li></ul></li></ul><h3 id="嵌套路由实现"><a href="#嵌套路由实现" class="headerlink" title="嵌套路由实现"></a>嵌套路由实现</h3><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220517165914323.png" alt="image-20220517165914323"><br><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220517170056439.png" alt="image-20220517170056439"></p><h4 id="嵌套默认路径"><a href="#嵌套默认路径" class="headerlink" title="嵌套默认路径"></a>嵌套默认路径</h4><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220517170137425.png" alt="image-20220517170137425"></p><h3 id="传递参数的方式"><a href="#传递参数的方式" class="headerlink" title="传递参数的方式"></a>传递参数的方式</h3><ul><li>传递参数主要有两种类型:</li><li>params和query</li><li>params的类型:<br>配置路由格式: /router/:id<br>传递的方式: 在path后面跟上对应的值<br>传递后形成的路径: /router/123, /router/abc</li><li>query的类型:<br>配置路由格式: /router, 也就是普通配置<br>传递的方式: 对象中使用query的key作为传递方式<br>传递后形成的路径: /router?id=123, /router?id=abc</li></ul><h4 id="传递参数方式一-router-link"><a href="#传递参数方式一-router-link" class="headerlink" title="传递参数方式一:     router-link"></a>传递参数方式一:     router-link</h4><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220517170819234.png" alt="image-20220517170819234"></p><h4 id="传递参数方式二-JavaScript代码"><a href="#传递参数方式二-JavaScript代码" class="headerlink" title="传递参数方式二: JavaScript代码"></a>传递参数方式二: JavaScript代码</h4><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220517170900191.png" alt="image-20220517170900191"></p><h4 id="获取参数"><a href="#获取参数" class="headerlink" title="获取参数"></a>获取参数</h4><ul><li>获取参数通过$route对象获取的.<ul><li>在使用了 vue-router 的应用中，路由对象会被注入每个组件中，赋值为 this.$route ，并且当路由切换时，路由对象会被更新。 </li></ul></li></ul><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220517171125297.png" alt="image-20220517171125297"></p> 来获取里面的值<h4 id="route和-router是有区别的"><a href="#route和-router是有区别的" class="headerlink" title="$route和$router是有区别的"></a>$route和$router是有区别的</h4><ul><li>$route和$router是有区别的<ul><li>$router为VueRouter实例，想要导航到不同URL，则使用$router.push方法</li><li>$route为当前router跳转对象里面可以获取name、path、query、params等 </li></ul></li></ul><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220517171358484.png" alt="image-20220517171358484"></p><h2 id="导航守卫"><a href="#导航守卫" class="headerlink" title="导航守卫"></a>导航守卫</h2><ul><li>我们来考虑一个需求: 在一个SPA应用中, 如何改变网页的标题呢?</li><li>网页标题是通过<title>来显示的, 但是SPA只有一个固定的HTML, 切换不同的页面时, 标题并不会改变.</li><li>但是我们可以通过JavaScript来修改<title>的内容.window.document.title = ‘新的标题’.</li></ul><p>在Vue中不建议操作虚拟dom</p><ul><li>什么是导航守卫?<ul><li>vue-router提供的导航守卫主要用来监听监听路由的进入和离开的.</li><li>vue-router提供了beforeEach和afterEach的钩子函数, 它们会在路由即将改变前和改变后触发. </li></ul></li></ul><h3 id="导航守卫使用"><a href="#导航守卫使用" class="headerlink" title="导航守卫使用"></a>导航守卫使用</h3><ul><li>我们可以利用beforeEach来完成标题的修改.<ul><li>首先, 我们可以在钩子当中定义一些标题, 可以利用meta来定义</li><li>其次, 利用导航守卫,修改我们的标题. </li></ul></li></ul><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220517232239138.png" alt="image-20220517232239138"></p><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220517232343668.png" alt="image-20220517232343668"></p><p>结合使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 进入路由前方法勾子</span></span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(to, <span class="string">&#x27;前置第一个参数&#x27;</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">from</span>, <span class="string">&#x27;前置第二个参数&#x27;</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(next, <span class="string">&#x27;前置第三个参数&#x27;</span>)</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    to 目标路由</span></span><br><span class="line"><span class="comment">    from 源路由</span></span><br><span class="line"><span class="comment">    next 跳转到下一个路由</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="comment">//这里暂时用local、storange来简单模拟验证权限</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">window</span>.localstorange.getItem(<span class="string">&quot;token&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">// 如果存在，则直接跳转到对应路由</span></span><br><span class="line">     next();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果不存在，则跳转到登录页</span></span><br><span class="line">    next(<span class="string">&#x27;/login&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局路由改变后钩子</span></span><br><span class="line">router.afterEach(<span class="function">(<span class="params">to, <span class="keyword">from</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//将滚动条恢复到最顶端</span></span><br><span class="line">  <span class="built_in">window</span>.scrollTo(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="导航守卫补充"><a href="#导航守卫补充" class="headerlink" title="导航守卫补充"></a>导航守卫补充</h3><ul><li>补充一:如果是后置钩子, 也就是afterEach, 不需要主动调用next()函数.</li><li>补充二: 上面我们使用的导航守卫, 被称之为全局守卫（beforeEach、afterEach).<br>路由独享的守卫（beforeEnter）.</li><li>组件内的守卫（beforeRouterEnter、beforeRouterUpdate、beforeRouterLeave）. </li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path: &#x27;/about&#x27;,</span><br><span class="line">    component: About,</span><br><span class="line">    meta: &#123;</span><br><span class="line">      title: &#x27;关于&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">    // 2.路由独享的守卫</span><br><span class="line">    beforeEnter: (to, from, next) =&gt; &#123;</span><br><span class="line">      console.log(&#x27;about beforeEnter&#x27;);</span><br><span class="line">      next()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  name: <span class="string">&quot;Home&quot;</span>,</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">      name: <span class="string">&quot;yyy&quot;</span>,</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">beforeRouteEnter</span>(<span class="params">to, <span class="keyword">from</span>, next</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 在渲染该组件的对应路由被 confirm 前调用</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 不！能！获取组件实例 `this`</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 因为当守卫执行前，组件实例还没被创建</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// console.log(to);</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// console.log(from);</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">// undefined</span></span></span><br><span class="line"><span class="javascript">    next(<span class="function">(<span class="params">vm</span>) =&gt;</span> &#123; <span class="comment">// 通过传一个回调给 next来访问组件实例</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(vm.name);</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">beforeRouteUpdate</span>(<span class="params">to, <span class="keyword">from</span>, next</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 在当前路由改变，但是该组件被复用时调用</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 可以访问组件实例 `this`</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">&quot;beforeRouteUpdate&quot;</span>);</span></span><br><span class="line">    next();</span><br><span class="line">  &#125;,</span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">beforeRouteLeave</span>(<span class="params">to, <span class="keyword">from</span>, next</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 导航离开该组件的对应路由时调用</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 可以访问组件实例 `this`</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.$route.path);</span></span><br><span class="line">    next();</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h2><ul><li>keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。</li><li>它们有两个非常重要的属性:</li><li><strong>include</strong> - 字符串或正则表达，只有匹配的组件会被缓存</li><li><strong>exclude</strong> - 字符串或正则表达式，任何匹配的组件都不会被缓存 </li><li>router-view 也是一个组件，如果直接被包在 keep-alive 里面，所有路径匹配到的视图组件都会被缓存</li><li><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220517233243882.png" alt="image-20220517233243882"></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> &lt;!-- 在vue中我们可以使用keepalive来进行组件缓存 --&gt;</span><br><span class="line">   &lt;keep-alive exclude=<span class="string">&quot;Profile,User&quot;</span>&gt;</span><br><span class="line">     &lt;router-view /&gt;</span><br><span class="line">   &lt;/keep-alive&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在&lt;script&gt;里面</span></span><br><span class="line"><span class="comment">// 这两个函数, 只有该组件被保持了状态使用了keep-alive时, 才是有效的</span></span><br><span class="line"> <span class="function"><span class="title">activated</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">   <span class="comment">// 活跃状态</span></span><br><span class="line">   <span class="built_in">this</span>.$router.push(<span class="built_in">this</span>.path);</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">&quot;activated&quot;</span>);</span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="function"><span class="title">deactivated</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">&quot;deactivated&quot;</span>);</span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="comment">// 离开当前路由页面时调用</span></span><br><span class="line"> <span class="function"><span class="title">beforeRouteLeave</span>(<span class="params">to, <span class="keyword">from</span>, next</span>)</span> &#123;</span><br><span class="line">   <span class="comment">// 首页中使用path属性记录离开时的路径，在beforeRouteLeave中记录</span></span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">this</span>.$route.path);</span><br><span class="line">   <span class="built_in">this</span>.path = <span class="built_in">this</span>.$route.path;</span><br><span class="line">   next();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>可以通过create周期函数来进行验证 看看是否出现重复渲染</p><h3 id="文件路径问题"><a href="#文件路径问题" class="headerlink" title="文件路径问题"></a>文件路径问题</h3><ul><li>可以起别名，在dom中需要加 ~ ，其他地方不需要</li></ul><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220517234616151.png" alt="image-20220517234616151"></p><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220517234625860.png" alt="image-20220517234625860"></p><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220517234636131.png" alt="image-20220517234636131"></p><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><ul><li>Promise到底是做什么的呢？<ul><li><strong>Promise是异步编程的一种解决方案。</strong></li></ul></li></ul><p>那什么时候我们会来处理异步事件呢？</p><ul><li>一种很常见的场景应该就是<strong>网络请求</strong>了。</li></ul><h2 id="Promise基本使用"><a href="#Promise基本使用" class="headerlink" title="Promise基本使用"></a>Promise基本使用</h2><h3 id="定时器的异步事件"><a href="#定时器的异步事件" class="headerlink" title="定时器的异步事件"></a>定时器的异步事件</h3><ul><li><p>这里，我们用一个定时器来模拟异步事件：</p><ul><li>假设下面的data是从网络上1秒后请求的数据</li><li>console.log就是我们的处理方式。</li></ul><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220518090249174.png" alt="image-20220518090249174"></p></li></ul><ul><li>我们先来认认真真的读一读这个程序到底做了什么？</li><li>new Promise很明显是创建一个Promise对象</li><li>小括号中((resolve, reject) =&gt; {})也很明显就是一个函数，而且我们这里用的是之前刚刚学习过的箭头函数。</li><li>但是resolve, reject它们是什么呢？</li><li>我们先知道一个事实：在创建Promise时，传入的这个箭头函数是固定的（一般我们都会这样写）</li><li>resolve和reject它们两个也是函数，通常情况下，我们会根据请求数据的成功和失败来决定调用哪一个。</li><li>成功还是失败？<ul><li>如果是成功的，那么通常我们会调用resolve(messsage)，这个时候，我们后续的then会被回调。</li><li>如果是失败的，那么通常我们会调用reject(error)，这个时候，我们后续的catch会被回调。</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// resolve(&#x27;Hello Vuejs&#x27;)</span></span><br><span class="line">      reject(<span class="string">&#x27;error message&#x27;</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">    <span class="comment">// 不想同时写then和catch的话 then里面可以直接传入两个函数 data,err</span></span><br><span class="line">  &#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">  &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="comment">//ES6 箭头函数的应用</span></span><br><span class="line"><span class="comment">// err=&gt;简化了catch</span></span><br></pre></td></tr></table></figure><h3 id="Promise三种状态和另外处理形式"><a href="#Promise三种状态和另外处理形式" class="headerlink" title="Promise三种状态和另外处理形式"></a>Promise三种状态和另外处理形式</h3><ul><li><strong>pending</strong>：等待状态，比如正在进行网络请求，或者定时器没有到时间。</li><li><strong>fulfill</strong>：满足状态，当我们主动回调了resolve时，就处于该状态，并且会回调.then()</li><li><strong>reject</strong>：拒绝状态，当我们主动回调了reject时，就处于该状态，并且会回调.catch() </li></ul><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220518090615966.png" alt="image-20220518090615966"></p><h2 id="Promise链式调用"><a href="#Promise链式调用" class="headerlink" title="Promise链式调用"></a>Promise链式调用</h2><h3 id="Promise链式调用-1"><a href="#Promise链式调用-1" class="headerlink" title="Promise链式调用"></a>Promise链式调用</h3><ul><li>我们在看Promise的流程图时，发现无论是then还是catch都可以返回一个Promise对象。</li><li>所以，我们的代码其实是可以进行链式调用的</li><li>这里我们直接通过Promise包装了一下新的数据，将Promise对象返回了</li><li>Promise.resovle()：将数据包装成Promise对象，并且在内部回调resolve()函数</li><li>Promise.reject()：将数据包装成Promise对象，并且在内部回调reject()函数 <img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220518090856289.png" alt="image-20220518090856289" style="zoom: 80%;" /></li></ul><p>链式操作简化代码 包含失败抛出异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">      setTimeout(() =&gt; &#123;</span><br><span class="line">        resolve(<span class="string">&#x27;aaa&#x27;</span>)</span><br><span class="line">      &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;).then(res =&gt; &#123;</span><br><span class="line">      <span class="comment">// 1.自己处理10行代码</span></span><br><span class="line">      console.log(res, <span class="string">&#x27;第一层的10行处理代码&#x27;</span>);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// reject失败的简写</span></span><br><span class="line">      <span class="comment">// return Promise.reject(&#x27;error message&#x27;)</span></span><br><span class="line">      <span class="comment">// 失败error的其他写法 手动抛出异常</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="string">&#x27;error message&#x27;</span></span><br><span class="line">    &#125;).then(res =&gt; &#123;</span><br><span class="line">      console.log(res, <span class="string">&#x27;第二层的10行处理代码&#x27;</span>);</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">return</span> Promise.resolve(res + <span class="string">&#x27;222&#x27;</span>)</span><br><span class="line">    &#125;).then(res =&gt; &#123;</span><br><span class="line">      console.log(res, <span class="string">&#x27;第三层的10行处理代码&#x27;</span>);</span><br><span class="line">    &#125;).<span class="keyword">catch</span>(err =&gt; &#123;</span><br><span class="line">      console.log(err);</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><ul><li>官方解释：Vuex 是一个专为 Vue.js 应用程序开发的<strong>状态管理模式</strong></li><li>它采用 <strong>集中式存储管理</strong> 应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</li><li>Vuex 也集成到 Vue 的官方调试工具 <strong>devtools extension</strong>，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。 </li></ul><h3 id="单界面的状态管理"><a href="#单界面的状态管理" class="headerlink" title="单界面的状态管理"></a>单界面的状态管理</h3><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220518091455913.png" alt="image-20220518091455913"></p><ul><li> 这图片中的三种东西，怎么理解呢？</li><li> State：不用多说，就是我们的状态。（你姑且可以当做就是data中的属性）</li><li> View：视图层，可以针对State的变化，显示不同的信息。（这个好理解吧？）</li><li> Actions：这里的Actions主要是用户的各种操作：点击、输入等等，会导致状态的改变。</li></ul><p>例子</p><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220518093151556.png" alt="image-20220518093151556"></p><ul><li>counter需要某种方式被记录下来，也就是我们的State。</li><li>counter目前的值需要被显示在界面中，也就是我们的View部分。</li><li>界面发生某些操作时（我们这里是用户的点击，也可以是用户的input），需要去更新状态，也就是我们的Actions 这不就是上面的流程图了吗？</li></ul><h3 id="多界面状态管理"><a href="#多界面状态管理" class="headerlink" title="多界面状态管理"></a>多界面状态管理</h3><ul><li><p>Vuex就是为我们提供这个大管家的工具。 </p></li><li><p>全局单例模式（大管家）</p><ul><li>我们现在要做的就是将共享的状态抽取出来，交给我们的大管家，统一进行管理。</li><li>之后，你们每个试图，按照我<strong>规定好</strong>的规定，进行访问和修改等操作。</li><li>这就是Vuex背后的基本思想。 </li></ul><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIzMDczODEx,size_16,color_FFFFFF,t_70.png" alt="img"></p></li></ul><h3 id="Vuex基本使用"><a href="#Vuex基本使用" class="headerlink" title="Vuex基本使用"></a>Vuex基本使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vuex --save</span><br></pre></td></tr></table></figure><p>vuex.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="comment">// 1.安装插件</span></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 2.创建对象 new Vuex.Store</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    <span class="comment">// 这5个对象一般都是固定的</span></span><br><span class="line">    state: &#123; <span class="comment">//保存状态</span></span><br><span class="line">        counter: <span class="number">1000</span></span><br><span class="line">    &#125;,</span><br><span class="line">    mutations: &#123; <span class="comment">// 方法 修改state唯一途径 同步操作</span></span><br><span class="line">        <span class="function"><span class="title">increment</span>(<span class="params">state</span>)</span> &#123; <span class="comment">// 默认就有个state参数，不用通过this.state</span></span><br><span class="line">            state.counter++</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">decrement</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">            state.counter--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    actions: &#123; <span class="comment">// 如果有异步操作在这里写 比如网络请求</span></span><br><span class="line"> </span><br><span class="line">    &#125;,</span><br><span class="line">    getters: &#123;</span><br><span class="line"> </span><br><span class="line">    &#125;,</span><br><span class="line">    modules: &#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 3.导出store对象</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure><h4 id="挂载到Vue实例中"><a href="#挂载到Vue实例中" class="headerlink" title="挂载到Vue实例中"></a>挂载到Vue实例中</h4><p>main.js代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store&#x27;</span></span><br><span class="line"> </span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 其他组件就能通过 $store 获取到store</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  store,</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><p>我们来对使用步骤，做一个简单的小节：</p></li><li><p>1.提取出一个公共的store对象，用于保存在多个组件中共享的状态</p></li><li><p>2.将store对象放置在new Vue对象中，这样可以保证在所有的组件中都可以使用到</p></li><li><p>3.在其他组件中使用store对象中保存的状态即可<br>通过this.$store.state.属性的方式来访问状态<br>通过this.$store.commit(‘mutation中方法’)来修改状态 </p></li><li><p>注意事项：</p><ul><li><strong>我们通过提交mutation的方式，而非直接改变store.state.count。</strong></li><li>这是因为Vuex可以更明确的追踪状态的变化，所以不要直接改变store.state.count的值。 </li></ul></li></ul><h2 id="Vuex核心概念"><a href="#Vuex核心概念" class="headerlink" title="Vuex核心概念"></a>Vuex核心概念</h2><ul><li>State</li><li>Getters</li><li>Mutation</li><li>Action</li><li>Module</li></ul><h2 id="State"><a href="#State" class="headerlink" title="State"></a>State</h2><h3 id="State单一状态树"><a href="#State单一状态树" class="headerlink" title="State单一状态树"></a>State单一状态树</h3><ul><li><p>Vuex提出使用单一状态树, 什么是单一状态树呢？</p><ul><li>英文名称是Single Source of Truth，也可以翻译成单一数据源。 </li></ul></li><li><p>Vuex也使用了单一状态树来管理应用层级的全部状态。</p></li><li><p>单一状态树能够让我们最直接的方式找到某个状态的片段，而且在之后的维护和调试过程中，也可以非常方便的管理和维护。 </p></li></ul><h2 id="Getters"><a href="#Getters" class="headerlink" title="Getters"></a>Getters</h2><p>有时候，我们需要从store中获取一些state变异后的状态，比如下面的Store中</p><p><strong><em>\</em>注意，getter 在通过属性访问时是作为 Vue 的响应式系统的一部分缓存其中的**</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  <span class="comment">// 这五个一般都是固定的，是对象</span></span><br><span class="line">  state: &#123; <span class="comment">//保存状态</span></span><br><span class="line">    counter: <span class="number">1000</span>,</span><br><span class="line">    students: [&#123;</span><br><span class="line">        id: <span class="number">110</span>,</span><br><span class="line">        name: <span class="string">&#x27;why&#x27;</span>,</span><br><span class="line">        age: <span class="number">18</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        id: <span class="number">111</span>,</span><br><span class="line">        name: <span class="string">&#x27;kobe&#x27;</span>,</span><br><span class="line">        age: <span class="number">24</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        id: <span class="number">112</span>,</span><br><span class="line">        name: <span class="string">&#x27;james&#x27;</span>,</span><br><span class="line">        age: <span class="number">30</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        id: <span class="number">113</span>,</span><br><span class="line">        name: <span class="string">&#x27;curry&#x27;</span>,</span><br><span class="line">        age: <span class="number">10</span></span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line"> </span><br><span class="line">  &#125;,</span><br><span class="line">  getters: &#123; <span class="comment">// 可以认为是 store 的计算属性</span></span><br><span class="line">    <span class="comment">// getters里面的方法 也会有state参数</span></span><br><span class="line">    <span class="function"><span class="title">powerCounter</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> state.counter * state.counter</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 找出多于20岁的学生 </span></span><br><span class="line">    <span class="comment">// filter(回调函数(当前元素的值))</span></span><br><span class="line">    <span class="function"><span class="title">more20stu</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> state.students.filter(<span class="function"><span class="params">s</span> =&gt;</span> s.age &gt; <span class="number">20</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Getters作为参数和传递参数"><a href="#Getters作为参数和传递参数" class="headerlink" title="Getters作为参数和传递参数"></a>Getters作为参数和传递参数</h3><ul><li>如果我们已经有了一个获取所有年龄大于20岁学生列表的getters, 那么代码可以这样来写 </li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 找出大于20岁学生的个数</span></span><br><span class="line">    <span class="function"><span class="title">more20stuLength</span>(<span class="params">state, getters</span>)</span> &#123; <span class="comment">// Getters 也可以接受其他 getters 作为第二个参数：</span></span><br><span class="line">      <span class="comment">//  return state.students.filter(s =&gt; s.age &gt; 20).length</span></span><br><span class="line">      <span class="keyword">return</span> getters.more20stu.length</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>其中就可以重复调用里面的函数了</p><ul><li>getters默认是不能传递参数的, 如果希望传递参数, 那么只能让getters本身返回另一个函数.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">getter:&#123;</span><br><span class="line">    <span class="comment">// 找出年龄大于参数age的学生</span></span><br><span class="line">    <span class="function"><span class="title">moreAgeStu</span>(<span class="params">state</span>)</span> &#123; <span class="comment">// getters传递参数 只能让getters本身返回另一个函数.</span></span><br><span class="line">      <span class="comment">// return function (age) &#123;</span></span><br><span class="line">      <span class="comment">//   return state.students.filter(s =&gt; s.age &gt; age)</span></span><br><span class="line">      <span class="comment">// &#125;</span></span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="params">age</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> state.students.filter(<span class="function"><span class="params">s</span> =&gt;</span> s.age &gt; age)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//应用 可以传参</span></span><br><span class="line"> &lt;h2&gt;&#123;&#123; $store.getters.moreAgeStu(<span class="number">12</span>) &#125;&#125;&lt;/h2&gt;</span><br></pre></td></tr></table></figure><h2 id="Mutation"><a href="#Mutation" class="headerlink" title="Mutation"></a>Mutation</h2><h3 id="Mutation状态更新"><a href="#Mutation状态更新" class="headerlink" title="Mutation状态更新"></a>Mutation状态更新</h3><ul><li> Vuex的store状态的更新唯一方式：提交Mutation</li><li>Mutation主要包括两部分：<ul><li>字符串的<strong>事件类型（type）</strong></li><li>一个<strong>回调函数（handler）</strong>,该回调函数的第一个参数就是state。</li></ul></li></ul><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIzMDczODEx,size_16,color_FFFFFF,t_70-16556397625151.png" alt="img"></p><ul><li>通过mutation更新 </li></ul><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220518095418683.png" alt="image-20220518095418683"></p><h3 id="Mutation传递参数"><a href="#Mutation传递参数" class="headerlink" title="Mutation传递参数"></a>Mutation传递参数</h3><ul><li><p>在通过mutation更新数据的时候, 有可能我们希望携带一些</p><p>额外的参数</p><ul><li>参数被称为是mutation的<strong>载荷(Payload)</strong></li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">mutations:&#123;</span><br><span class="line">     <span class="comment">// 特殊的提交封装  当作对象来进行使用</span></span><br><span class="line">    <span class="function"><span class="title">incrementCount</span>(<span class="params">state, payload</span>)</span> &#123;</span><br><span class="line">      <span class="comment">// console.log(count);</span></span><br><span class="line">      state.counter += payload.count</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//应用 带type风格的</span></span><br><span class="line"> <span class="function"><span class="title">addCount</span>(<span class="params">count</span>)</span> &#123;</span><br><span class="line">      <span class="comment">// payload: 负载</span></span><br><span class="line">      <span class="comment">// 1.普通的提交封装 这样写的 mutations里的 incrementCount(state, count) 的count 就是count</span></span><br><span class="line">      <span class="comment">// this.$store.commit(&#x27;incrementCount&#x27;, count) // 单个参数</span></span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 2.特殊的提交封装 mutations里的 incrementCount(state, count) 的count 是一个对象 写成payload比较合适，通过payload.count取</span></span><br><span class="line">      <span class="built_in">this</span>.$store.commit(&#123;</span><br><span class="line">        type: <span class="string">&quot;incrementCount&quot;</span>,</span><br><span class="line">        count,</span><br><span class="line">      &#125;);</span><br><span class="line">     <span class="comment">//不带type风格的</span></span><br><span class="line">      <span class="keyword">const</span> stu = &#123; <span class="attr">id</span>: <span class="number">114</span>, <span class="attr">name</span>: <span class="string">&quot;alan&quot;</span>, <span class="attr">age</span>: <span class="number">35</span> &#125;;</span><br><span class="line">      <span class="built_in">this</span>.$store.commit(<span class="string">&quot;addStudent&quot;</span>, stu);</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><h3 id="Mutation响应规则"><a href="#Mutation响应规则" class="headerlink" title="Mutation响应规则"></a>Mutation响应规则</h3><ul><li><p>Vuex的store中的state是响应式的, 当state中的数据发生改变时, Vue组件会自动更新.</p></li><li><p>这就要求我们必须遵守一些Vuex对应的规则:</p><ul><li>提前在store中初始化好所需的属性.</li><li>当给state中的对象添加新属性时, 使用下面的方式:<ul><li>方式一: 使用<strong>Vue.set</strong>(obj, ‘newProp’, 123)</li><li>方式二: 用新对象给旧对象重新赋值 </li></ul></li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123; <span class="comment">//保存状态</span></span><br><span class="line">    <span class="comment">// state里面都属性初始化后 每个属性对应一个dep 监听属性变化 dep观察者模式</span></span><br><span class="line">    info: &#123;</span><br><span class="line">      name: <span class="string">&#x27;kobe&#x27;</span>, <span class="comment">// Dep -&gt; [Watcher]</span></span><br><span class="line">      age: <span class="number">40</span>, <span class="comment">// Dep -&gt; [Watcher]</span></span><br><span class="line">      height: <span class="number">1.98</span> <span class="comment">// Dep -&gt; [Watcher]</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    mutations: &#123;</span><br><span class="line">        <span class="function"><span class="title">updateInfo</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">          <span class="comment">// 可以响应式</span></span><br><span class="line">          state.info.name = <span class="string">&#x27;coderwhy&#x27;</span></span><br><span class="line">          <span class="comment">// 不能响应式</span></span><br><span class="line">          <span class="comment">// state.info[&#x27;address&#x27;] = &#x27;洛杉矶&#x27; // 我的可以响应？？？视频中的不可以</span></span><br><span class="line">          Vue.set(state.info, <span class="string">&#x27;address&#x27;</span>, <span class="string">&#x27;洛杉矶&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">          <span class="comment">// delete state.info.age  // “delete+某个属性”该方式做不到响应式</span></span><br><span class="line">          <span class="comment">// Vue.delete(state.info, &#x27;age&#x27;) // Vue.delete() 响应式</span></span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Mutation常量类型-–-概念"><a href="#Mutation常量类型-–-概念" class="headerlink" title="Mutation常量类型 – 概念"></a>Mutation常量类型 – 概念</h3><p>  我们来考虑下面的问题:</p><ul><li>在mutation中, 我们定义了很多事件类型(也就是其中的方法名称).</li><li>当我们的项目增大时, Vuex管理的状态越来越多, 需要更新状态的情况越来越多, 那么意味着Mutation中的方法越来越多.</li><li>方法过多, 使用者需要花费大量的经历去记住这些方法, 甚至是多个文件间来回切换, 查看方法名称, 甚至如果不是复制的时候, 可能还会出现写错的情况.</li></ul><p>如何避免上述的问题呢?</p><ul><li><p>在各种Flux实现中, 一种很常见的方案就是使用<strong>常量</strong>替代Mutation<strong>事件的类型.</strong></p></li><li><p>我们可以将这些常量放在一个单独的文件中, 方便管理以及让整个app所有的事件类型一目了然.</p></li><li><p>具体怎么做呢?</p><ul><li>我们可以创建一个文件: mutation-types.js, 并且在其中定义我们的常量.</li><li>定义常量时, 我们可以使用ES2015中的风格, 使用一个常量来作为函数的名称. </li></ul></li></ul><h3 id="Mutation常量类型-–-代码"><a href="#Mutation常量类型-–-代码" class="headerlink" title="Mutation常量类型 – 代码"></a>Mutation常量类型 – 代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//建立 mutations-type.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> INCREMENT = <span class="string">&#x27;increment&#x27;</span>  <span class="comment">//向外导出一个属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//store下index.js</span></span><br><span class="line"><span class="comment">// import INCREMENT from &#x27;./mutations-types&#x27;// 不能这样导入，只能是export default</span></span><br><span class="line"><span class="comment">// export导出，导入需要加 &#123;&#125;</span></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  INCREMENT</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&#x27;./mutations-types&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">     <span class="comment">// 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名</span></span><br><span class="line">    [INCREMENT](state) &#123;</span><br><span class="line">      state.counter++</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">    </span><br><span class="line"><span class="comment">//App.vue</span></span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> HelloVuex <span class="keyword">from</span> <span class="string">&quot;./components/HelloVuex&quot;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> &#123; INCREMENT &#125; <span class="keyword">from</span> <span class="string">&quot;./store/mutations-types&quot;</span>;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">&quot;App&quot;</span>,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="comment">// 在这里提交方法对应的mutation 的方法名</span></span><br><span class="line">    <span class="function"><span class="title">addition</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.$store.commit(INCREMENT);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h3 id="Mutation同步函数"><a href="#Mutation同步函数" class="headerlink" title="Mutation同步函数"></a>Mutation同步函数</h3><p> 通常情况下, Vuex要求我们Mutation中的方法必须是同步方法.</p><ul><li>主要的原因是当我们使用devtools时, 可以devtools可以帮助我们捕捉mutation的快照.</li><li>但是如果是异步操作, 那么devtools将不能很好的追踪这个操作什么时候会被完成. </li></ul><p>注意！！！  不能在mutation使用异步处理，因为会追踪不到</p><h2 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h2><h3 id="Action的基本定义"><a href="#Action的基本定义" class="headerlink" title="Action的基本定义"></a>Action的基本定义</h3><ul><li><p>我们强调, 不要再Mutation中进行异步操作.</p><ul><li>但是某些情况, 我们确实希望在Vuex中进行一些异步操作, 比如网络请求, 必然是异步的.这个时候怎么处理呢?</li><li>Action类似于Mutation, 但是是用来代替Mutation进行异步操作的.</li></ul></li></ul><p>Action的基本使用代码如下:</p><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIzMDczODEx,size_16,color_FFFFFF,t_70-16556397625152.png" alt="img"></p><ul><li><strong>context是什么? context是和store对象具有相同方法和属性的对象.</strong></li><li>也就是说, 我们可以通过context去进行commit相关的操作, 也可以获取context.state等.</li><li>我们定义了actions, 然后又在actions中去进行commit, 这不是脱裤放屁吗?</li><li>事实上并不是这样, 如果在Vuex中有异步操作, 那么我们就可以在actions中完成了. </li></ul><h3 id="Action的分发"><a href="#Action的分发" class="headerlink" title="Action的分发"></a>Action的分发</h3><p>在Vue组件中, 如果我们调用action中的方法, 那么就需要使用dispatch</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用  </span></span><br><span class="line"><span class="function"><span class="title">updateInfo</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="comment">// this.$store.commit(&#x27;updateInfo&#x27;)  // 这样没有经过actions</span></span><br><span class="line">      <span class="comment">// 异步修改信息 actions</span></span><br><span class="line">      <span class="comment">// this.$store.dispatch(&#x27;aUpdateInfo&#x27;,&quot;我是携带的信息&quot;);// 携带一个参数</span></span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 通知外面已经改成功了 -&gt; commit调用之后就算成功，利用对象的方法回调</span></span><br><span class="line">      <span class="built_in">this</span>.$store.dispatch(<span class="string">&#x27;aUpdateInfo&#x27;</span>, &#123;</span><br><span class="line">        message: <span class="string">&#x27;我是携带的信息&#x27;</span>,</span><br><span class="line">        success: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">&#x27;里面已经完成了&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      &#125;,</span><br><span class="line">          </span><br><span class="line">          </span><br><span class="line"><span class="comment">//vuex相关代码</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    mutations:&#123;</span><br><span class="line">         <span class="function"><span class="title">updateInfo</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">              state.info.name = <span class="string">&#x27;coderwhy&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    actions:&#123;</span><br><span class="line">          <span class="comment">// 默认参数 context: 上下文 现在先理解成store</span></span><br><span class="line">         <span class="function"><span class="title">aUpdateInfo</span>(<span class="params">context, payload</span>)</span> &#123;</span><br><span class="line">              <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                context.commit(<span class="string">&#x27;updateInfo&#x27;</span>)</span><br><span class="line">                <span class="built_in">console</span>.log(payload.message);</span><br><span class="line">                payload.success() <span class="comment">// 调用回调 告诉外面已经成功</span></span><br><span class="line">              &#125;, <span class="number">1000</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Action返回的Promise"><a href="#Action返回的Promise" class="headerlink" title="Action返回的Promise"></a>Action返回的Promise</h3><p>优化异步请求</p><ul><li>前面我们学习ES6语法的时候说过, Promise经常用于异步操作.<ul><li>在Action中, 我们可以将异步操作放在一个Promise中, 并且在成功或者失败后, 调用对应的resolve或reject. </li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vuex代码</span></span><br><span class="line">actions:&#123;</span><br><span class="line">     <span class="comment">// Action返回的Promise</span></span><br><span class="line">    <span class="function"><span class="title">aUpdateInfo</span>(<span class="params">context, payload</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          context.commit(<span class="string">&#x27;updateInfo&#x27;</span>);</span><br><span class="line">          <span class="built_in">console</span>.log(payload);</span><br><span class="line">          <span class="comment">//调用成功返回回调 返回整个promise函数</span></span><br><span class="line">          resolve(<span class="string">&#x27;1111111&#x27;</span>)</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">      &#125;) <span class="comment">// then()在App.vue里面写</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//App.vue</span></span><br><span class="line"><span class="function"><span class="title">updateInfo</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="comment">// 之前写的不够优雅 回调消息与携带信息混在一起，现在用Promise封装再用resolve调用</span></span><br><span class="line">      <span class="built_in">this</span>.$store.dispatch(<span class="string">&quot;aUpdateInfo&quot;</span>, <span class="string">&quot;我是携带的信息&quot;</span>).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;里面完成了提交&quot;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(res);</span><br><span class="line">      &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h2><h3 id="认识Module"><a href="#认识Module" class="headerlink" title="认识Module"></a>认识Module</h3><p>​    Module是模块的意思, 为什么在Vuex中我们要使用模块呢?</p><ul><li>Vue使用单一状态树,那么也意味着很多状态都会交给Vuex来管理.</li><li>当应用变得非常复杂时,store对象就有可能变得相当臃肿.</li><li>为了解决这个问题, Vuex允许我们将store分割成模块(Module), 而每个模块拥有自己的state、mutations、actions、getters等</li></ul><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220518102622132.png" alt="image-20220518102622132"></p><p> 局部module rootState是原module里面的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  <span class="comment">// 组件里面通过$store.state.a.name获取属性</span></span><br><span class="line">  state: &#123;</span><br><span class="line">    name: <span class="string">&#x27;zhangsan&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 官网state写法</span></span><br><span class="line">  <span class="comment">// state: () =&gt; (&#123;</span></span><br><span class="line">  <span class="comment">// &#125;),</span></span><br><span class="line">  <span class="comment">// 使用 this.$store.commit() 提交</span></span><br><span class="line">  mutations: &#123;</span><br><span class="line">    <span class="function"><span class="title">updateName</span>(<span class="params">state, payload</span>)</span> &#123;</span><br><span class="line">      state.name = payload</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// $store.getters.fullname调用</span></span><br><span class="line">  getters: &#123;</span><br><span class="line">    <span class="function"><span class="title">fullname</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> state.name + <span class="string">&#x27;11111&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">fullname2</span>(<span class="params">state, getters</span>)</span> &#123; <span class="comment">// 使用其他getters</span></span><br><span class="line">      <span class="keyword">return</span> getters.fullname + <span class="string">&#x27;2222&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// rootState 可以使用大的state里面的值  这里这里这里</span></span><br><span class="line">    <span class="function"><span class="title">fullname3</span>(<span class="params">state, getters, rootState</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> getters.fullname2 + rootState.counter</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// this.$store.dispatch() 提交</span></span><br><span class="line">  actions: &#123;</span><br><span class="line">    <span class="comment">// 这里的 context 不是store对象了 而是这个module对应的mutations</span></span><br><span class="line">    <span class="function"><span class="title">aUpdateName</span>(<span class="params">context</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(context);</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        context.commit(<span class="string">&#x27;updateName&#x27;</span>, <span class="string">&#x27;wangwu&#x27;</span>)</span><br><span class="line">      &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="项目结构组织"><a href="#项目结构组织" class="headerlink" title="项目结构组织"></a>项目结构组织</h2><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220518111628292.png" alt="image-20220518111628292"></p><p>将vuex里面的部分文件都抽离出来</p><ul><li>index.js</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue from <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Vuex from <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> mutations from <span class="string">&#x27;./mutations&#x27;</span></span><br><span class="line"><span class="keyword">import</span> actions from <span class="string">&#x27;./actions&#x27;</span></span><br><span class="line"><span class="keyword">import</span> getters from <span class="string">&#x27;./getters&#x27;</span></span><br><span class="line"><span class="keyword">import</span> moduleA from <span class="string">&#x27;./modules/moduleA&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 1.安装插件</span></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 2.创建对象 new Vuex.Store</span></span><br><span class="line"><span class="comment">// state 一般不会抽出去 而是写在这个文件</span></span><br><span class="line"><span class="keyword">const</span> state = &#123;</span><br><span class="line">  counter: <span class="number">1000</span>,</span><br><span class="line">  students: [&#123;</span><br><span class="line">      id: <span class="number">110</span>,</span><br><span class="line">      name: <span class="string">&#x27;why&#x27;</span>,</span><br><span class="line">      age: <span class="number">18</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      id: <span class="number">111</span>,</span><br><span class="line">      name: <span class="string">&#x27;kobe&#x27;</span>,</span><br><span class="line">      age: <span class="number">24</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      id: <span class="number">112</span>,</span><br><span class="line">      name: <span class="string">&#x27;james&#x27;</span>,</span><br><span class="line">      age: <span class="number">30</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      id: <span class="number">113</span>,</span><br><span class="line">      name: <span class="string">&#x27;curry&#x27;</span>,</span><br><span class="line">      age: <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  info: &#123;</span><br><span class="line"> </span><br><span class="line">    name: <span class="string">&#x27;kobe&#x27;</span>, <span class="comment">// Dep -&gt; [Watcher]</span></span><br><span class="line">    age: <span class="number">40</span>, <span class="comment">// Dep -&gt; [Watcher]</span></span><br><span class="line">    height: <span class="number">1.98</span> <span class="comment">// Dep -&gt; [Watcher]</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  <span class="comment">// 这五个一般都是固定的，是对象</span></span><br><span class="line">  state, <span class="comment">//保存状态</span></span><br><span class="line">  mutations, <span class="comment">// 方法 修改state唯一途径 同步操作</span></span><br><span class="line">  actions, <span class="comment">// 如果有异步操作在这里写 比如网络请求</span></span><br><span class="line">  getters,</span><br><span class="line"> </span><br><span class="line">  modules: &#123;</span><br><span class="line">    a: moduleA</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 3.导出store对象</span></span><br><span class="line">export <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure><h1 id="网络模块封装"><a href="#网络模块封装" class="headerlink" title="网络模块封装"></a>网络模块封装</h1><ul><li>选择一: 传统的Ajax是基于XMLHttpRequest(XHR)<ul><li>为什么不用它呢?<ul><li>非常好解释, 配置和调用方式等非常混乱.</li><li>编码起来看起来就非常蛋疼.</li><li>所以真实开发中很少直接使用, 而是使用jQuery-Ajax </li></ul></li></ul></li></ul><p>选择二: 在前面的学习中, 我们经常会使用jQuery-Ajax</p><ul><li><p>相对于传统的Ajax非常好用.</p></li><li><p>为什么不选择它呢?</p><ul><li>完全没有必要为了用网络请求就引用这个重量级的框架 </li><li>Vue的代码才1w+行.</li><li>jQuery的代码1w+行.</li><li>那么, 就意味着为了方便我们进行一个网络请求, 特意引用一个jQuery, 你觉得合理吗?</li><li>首先, 我们先明确一点: 在Vue的整个开发中都是不需要使用jQuery了.</li></ul></li><li><p>选择四: 在说明不再继续更新和维护vue-resource的同时, 作者还推荐了一个框架: axios为什么不用它呢?</p></li><li><p>axios有非常多的优点, 并且用起来也非常方便.</p></li></ul><h2 id="jsonp封装"><a href="#jsonp封装" class="headerlink" title="jsonp封装"></a>jsonp封装</h2><ul><li>在前端开发中, 我们一种常见的网络请求方式就是JSONP<ul><li>使用JSONP最主要的原因往往是为了解决跨域访问的问题.</li></ul></li><li>SONP的原理是什么呢?<ul><li>JSONP的核心在于通过<script>标签的src来帮助我们请求数据.</li><li>原因是我们的项目部署在domain1.com服务器上时, 是不能直接访问domain2.com服务器上的资料的.</li><li>这个时候, 我们利用<script>标签的src帮助我们去服务器请求到数据, 将数据当做一个javascript的函数来执行, 并且执行的过程中传入我们需要的json.</li><li>所以, 封装jsonp的核心就在于我们监听window上的jsonp进行回调时的名称.</li></ul></li></ul><h3 id="JSONP封装"><a href="#JSONP封装" class="headerlink" title="JSONP封装"></a>JSONP封装</h3><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIzMDczODEx,size_16,color_FFFFFF,t_70-16556397625163.png" alt="img"><br><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/20210804130410779.png" alt="img"></p><h2 id="认识axios"><a href="#认识axios" class="headerlink" title="认识axios"></a>认识axios</h2><ul><li><p>功能特点:</p><ul><li>在浏览器中发送 XMLHttpRequests 请求</li><li>在 node.js 中发送 http请求</li><li>支持 Promise API</li><li>拦截请求和响应</li><li>转换请求和响应数据</li><li>等等 </li></ul><p> <strong><em>\</em>axios=ajax+promise**</strong></p></li></ul><h3 id="axiox请求方式"><a href="#axiox请求方式" class="headerlink" title="axiox请求方式"></a>axiox请求方式</h3><p>支持多种请求方式:</p><ul><li>axios(config)</li><li>axios.request(config)</li><li>axios.get(url[, config])</li><li>axios.delete(url[, config])</li><li>axios.head(url[, config])</li><li>axios.post(url[, data[, config]])</li><li>axios.put(url[, data[, config]])</li><li>axios.patch(url[, data[, config]]) </li></ul><h3 id="axios发送基本请求"><a href="#axios发送基本请求" class="headerlink" title="axios发送基本请求"></a>axios发送基本请求</h3><ul><li>安装axios</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install axios --save</span><br></pre></td></tr></table></figure><ul><li>main.js代码 </li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 1.axios的基本使用 axios(config)</span></span><br><span class="line">axios(&#123;</span><br><span class="line">  url: <span class="string">&#x27;http://123.207.32.32:8000/home/multidata&#x27;</span>, <span class="comment">// 项目接口</span></span><br><span class="line">  <span class="comment">// 默认是get请求 可以用method指定</span></span><br><span class="line">  <span class="comment">// method: &#x27;post&#x27;</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123; <span class="comment">// 获取返回的数据</span></span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">axios(&#123;</span><br><span class="line">  <span class="comment">//  url:&#x27;http://123.207.32.32:8000/home/data?type=sell&amp;page=1&#x27;</span></span><br><span class="line">  <span class="comment">// 参数除了可以直接拼接在url，也可以用params</span></span><br><span class="line">  url: <span class="string">&#x27;http://123.207.32.32:8000/home/data&#x27;</span>,</span><br><span class="line">  <span class="comment">// 专门针对get请求的参数拼接</span></span><br><span class="line">  params: &#123;</span><br><span class="line">    type: <span class="string">&#x27;pop&#x27;</span>,</span><br><span class="line">    page: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="发送并发请求"><a href="#发送并发请求" class="headerlink" title="发送并发请求"></a>发送并发请求</h3><ul><li>有时候, 我们可能需求同时发送两个请求<ul><li>使用axios.all, 可以放入多个请求的数组.</li><li>axios.all([]) 返回的结果是一个数组，使用 axios.spread 可将数组 [res1,res2] 展开为 res1, res2 </li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2.axios发送并发请求(同时发多个请求,同时到达之后才能往下写代码)</span></span><br><span class="line"><span class="comment">// axios.all([axios(),axios()]).then(reslut=&gt;&#123;&#125;)</span></span><br><span class="line">axios.all([axios(&#123;</span><br><span class="line">  url: <span class="string">&#x27;http://123.207.32.32:8000/home/multidata&#x27;</span></span><br><span class="line">&#125;), axios(&#123;</span><br><span class="line">  url: <span class="string">&#x27;http://123.207.32.32:8000/home/data&#x27;</span>,</span><br><span class="line">  params: &#123;</span><br><span class="line">    type: <span class="string">&#x27;sell&#x27;</span>,</span><br><span class="line">    page: <span class="number">5</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)]).then(<span class="function"><span class="params">results</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(results);</span><br><span class="line">  <span class="built_in">console</span>.log(results[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">console</span>.log(results[<span class="number">1</span>]);</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// .then()也可以写成  axios.spread可以将请求数据区分开来</span></span><br><span class="line">axios.all([axios(&#123;</span><br><span class="line">  url: <span class="string">&#x27;http://123.207.32.32:8000/home/multidata&#x27;</span></span><br><span class="line">&#125;), axios(&#123;</span><br><span class="line">  url: <span class="string">&#x27;http://123.207.32.32:8000/home/data&#x27;</span>,</span><br><span class="line">  params: &#123;</span><br><span class="line">    type: <span class="string">&#x27;sell&#x27;</span>,</span><br><span class="line">    page: <span class="number">5</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)]).then(axios.spread(<span class="function">(<span class="params">res1, res2</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res1);</span><br><span class="line">  <span class="built_in">console</span>.log(res2);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h3><ul><li>在上面的示例中, 我们的BaseURL是固定的<ul><li>事实上, 在开发中可能很多参数都是固定的.</li><li>这个时候我们可以进行一些抽取, 也可以利用axiox的全局配置</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3.使用全局的axios和对应的配置在进行网络请求</span></span><br><span class="line">axios.defaults.baseURL = <span class="string">&#x27;http://123.207.32.32:8000&#x27;</span></span><br><span class="line">axios.defaults.timeout = <span class="number">5000</span> <span class="comment">// 超时</span></span><br><span class="line"> </span><br><span class="line">axios.all([axios(&#123;</span><br><span class="line">  url: <span class="string">&#x27;/home/multidata&#x27;</span></span><br><span class="line">&#125;), axios(&#123;</span><br><span class="line">  url: <span class="string">&#x27;/home/data&#x27;</span>,</span><br><span class="line">  params: &#123;</span><br><span class="line">    type: <span class="string">&#x27;sell&#x27;</span>,</span><br><span class="line">    page: <span class="number">5</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)]).then(axios.spread(<span class="function">(<span class="params">res1, res2</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 使用 axios.spread 可将数组 [res1,res2] 展开为 res1, res2</span></span><br><span class="line">  <span class="built_in">console</span>.log(res1);</span><br><span class="line">  <span class="built_in">console</span>.log(res2);</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><h3 id="常见的配置选项"><a href="#常见的配置选项" class="headerlink" title="常见的配置选项"></a>常见的配置选项</h3><ul><li>请求地址<ul><li>url: ‘/user’, </li></ul></li><li>请求类型<ul><li>method: ‘get’,</li></ul></li><li>请根路径<ul><li>baseURL: ‘<a href="http://www.mt.com/api&#39;">http://www.mt.com/api&#39;</a>,</li></ul></li><li>请求前的数据处理<ul><li>transformRequest:[function(data){}],</li></ul></li><li>请求后的数据处理<ul><li>transformResponse: [function(data){}],</li></ul></li><li>自定义的请求头<ul><li>headers:{‘x-Requested-With’:’XMLHttpRequest’},</li></ul></li><li>URL查询对象<ul><li>params:{ id: 12 }, </li></ul></li><li>请求后的数据处理<ul><li>transformResponse: [function(data){}],</li></ul></li><li>自定义的请求头<ul><li>headers:{‘x-Requested-With’:’XMLHttpRequest’},</li></ul></li><li>URL查询对象<ul><li>params:{ id: 12 }, </li></ul></li><li>查询对象序列化函数<ul><li>paramsSerializer: function(params){ }</li></ul></li><li>request body<ul><li>data: { key: ‘aa’},</li></ul></li><li>超时设置s<ul><li>timeout: 1000,</li></ul></li><li>跨域是否带Token<ul><li>withCredentials: false,</li></ul></li><li>自定义请求处理<ul><li>adapter: function(resolve, reject, config){},</li></ul></li><li>身份验证信息<ul><li>auth: { uname: ‘’, pwd: ‘12’},</li></ul></li><li>响应的数据格式 json / blob /document /arraybuffer / text / stream<ul><li>responseType: ‘json’,</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get方法参数放parmas，post方法参数放request body 请求体的data </span><br></pre></td></tr></table></figure><h3 id="axios实例"><a href="#axios实例" class="headerlink" title="axios实例"></a>axios实例</h3><p>为什么要创建axios的实例呢?</p><ul><li>当我们从axios模块中导入对象时, 使用的实例是默认的实例.</li><li>当给该实例设置一些默认配置时, 这些配置就被固定下来了.</li><li>但是后续开发中, 某些配置可能会不太一样.</li><li>比如某些请求需要使用特定的baseURL或者timeout或者content-Type等.</li><li>这个时候, 我们就可以创建新的实例, 并且传入属于该实例的配置信息. </li></ul><p>方便应对多个开发</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为什么要创建axios实例？有些请求的配置可能会不同，大项目会有多个服务器，服务器的ip不同,baseURL也就不同</span></span><br><span class="line">axios.defaults.baseURL = <span class="string">&#x27;http://222.111.33.33:8000&#x27;</span></span><br><span class="line">axios.defaults.timeout = <span class="number">10000</span></span><br><span class="line"> </span><br><span class="line">axios(&#123;</span><br><span class="line">  url: <span class="string">&#x27;http://123.207.32.32:8000/category&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 4.创建对应的axios的实例</span></span><br><span class="line"><span class="keyword">const</span> instance1 = axios.create(&#123;</span><br><span class="line">  baseURL: <span class="string">&#x27;http://123.207.32.32:8000&#x27;</span>,</span><br><span class="line">  timeout: <span class="number">5000</span></span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line">instance1(&#123;</span><br><span class="line">  url: <span class="string">&#x27;/home/multidata&#x27;</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line">instance1(&#123;</span><br><span class="line">  url: <span class="string">&#x27;/home/data&#x27;</span>,</span><br><span class="line">  params: &#123;</span><br><span class="line">    type: <span class="string">&#x27;pop&#x27;</span>,</span><br><span class="line">    page: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instance2 = axios.create(&#123;</span><br><span class="line">  baseURL: <span class="string">&#x27;http://222.111.33.33:8000&#x27;</span>,</span><br><span class="line">  timeout: <span class="number">10000</span>,</span><br><span class="line">  headers: &#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="axios封装"><a href="#axios封装" class="headerlink" title="axios封装"></a>axios封装</h3><ul><li><strong>request封装v1.0</strong> 使用回调，返回数据</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// request.js</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// request封装v1.0 使用回调，返回数据</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config, success, failure</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1.创建axios的实例</span></span><br><span class="line">  <span class="keyword">const</span> instance = axios.create(&#123;</span><br><span class="line">    baseURL: <span class="string">&#x27;http://123.207.32.32:8000&#x27;</span>,</span><br><span class="line">    timeout: <span class="number">5000</span></span><br><span class="line">  &#125;)</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 发送真正的网络请求</span></span><br><span class="line">  instance(config)</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// console.log(res);</span></span><br><span class="line">      success(res);</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// console.log(err);</span></span><br><span class="line">      failure(err)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 5.封装request模块</span></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  request</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&quot;./network/request&quot;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// request封装v1.0 的调用</span></span><br><span class="line">request(&#123;</span><br><span class="line">  url: <span class="string">&#x27;/home/multidata&#x27;</span></span><br><span class="line">&#125;, <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><strong>request封装v2.0</strong> 直接传一个config 再从里面取success,failure</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// request.js</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// request封装v2.0 直接传一个config 再从里面取success,failure</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1.创建axios的实例</span></span><br><span class="line">  <span class="keyword">const</span> instance = axios.create(&#123;</span><br><span class="line">    baseURL: <span class="string">&#x27;http://123.207.32.32:8000&#x27;</span>,</span><br><span class="line">    timeout: <span class="number">5000</span></span><br><span class="line">  &#125;)</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 发送真正的网络请求</span></span><br><span class="line">  instance(config.baseConfig)</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// console.log(res);</span></span><br><span class="line">      config.success(res);</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// console.log(err);</span></span><br><span class="line">      config.failure(err)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="comment">// request封装v2.0 的调用</span></span><br><span class="line">request(&#123;</span><br><span class="line">  baseConfig: &#123;</span><br><span class="line">    url:<span class="string">&#x27;/home/multidata&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  success: <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">  &#125;,</span><br><span class="line">  failure: <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><strong>request封装v3.0</strong> 使用Promise</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// request.js</span></span><br><span class="line"><span class="comment">// request封装v3.0 使用Promise</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 1.创建axios的实例</span></span><br><span class="line">    <span class="keyword">const</span> instance = axios.create(&#123;</span><br><span class="line">      baseURL: <span class="string">&#x27;http://123.207.32.32:8000&#x27;</span>,</span><br><span class="line">      timeout: <span class="number">5000</span></span><br><span class="line">    &#125;)</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 发送真正的网络请求</span></span><br><span class="line">    instance(config)</span><br><span class="line">      .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        resolve(res)</span><br><span class="line">      &#125;)</span><br><span class="line">      .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        reject(err)</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line">request(&#123;</span><br><span class="line">  url: <span class="string">&#x27;/home/multidata&#x27;</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>request封装v4.0</strong> 直接return instance(config) 因为它这个本身就是一个Promise</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// request.js</span></span><br><span class="line"><span class="comment">// request封装v4.0 直接return instance(config) 因为它这个本身就是一个Promise</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1.创建axios的实例</span></span><br><span class="line">    <span class="keyword">const</span> instance = axios.create(&#123;</span><br><span class="line">        baseURL: <span class="string">&#x27;http://123.207.32.32:8000&#x27;</span>,</span><br><span class="line">        timeout: <span class="number">5000</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 2.发送真正的网络请求</span></span><br><span class="line">    <span class="keyword">return</span> instance(config) <span class="comment">// 本身的返回值就是个promise</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js </span></span><br><span class="line"><span class="comment">//  request封装v3.0 / v4.0的调用</span></span><br><span class="line">request(&#123;</span><br><span class="line">  url: <span class="string">&#x27;/home/multidata&#x27;</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// console.log(err);</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><h3 id="如何使用拦截器？"><a href="#如何使用拦截器？" class="headerlink" title="如何使用拦截器？"></a>如何使用拦截器？</h3><ul><li>axios提供了拦截器，用于我们在发送每次请求或者得到相应后，进行对应的处理。</li></ul><h3 id="拦截器中都做什么呢？"><a href="#拦截器中都做什么呢？" class="headerlink" title="拦截器中都做什么呢？"></a>拦截器中都做什么呢？</h3><ul><li><p>请求拦截中错误拦截较少，通常都是配置相关的拦截</p><ul><li>可能的错误比如请求超时，可以将页面跳转到一个错误页面中。</li></ul></li><li><p>响应拦截中完成的事情：</p><ul><li>响应的成功拦截中，主要是对数据进行过滤</li></ul></li><li><p> 代码：</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// request.js </span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1.创建axios的实例</span></span><br><span class="line">  <span class="keyword">const</span> instance = axios.create(&#123;</span><br><span class="line">    baseURL: <span class="string">&#x27;http://123.207.32.32:8000&#x27;</span>,</span><br><span class="line">    timeout: <span class="number">5000</span></span><br><span class="line">  &#125;)</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 2.axios的拦截器</span></span><br><span class="line">  <span class="comment">// 2.1.请求拦截的作用 成功/失败</span></span><br><span class="line">  instance.interceptors.request.use(<span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// console.log(config);</span></span><br><span class="line">    <span class="comment">// 1.比如config中的一些信息不符合服务器的要求</span></span><br><span class="line">    <span class="comment">// 2.比如每次发送网络请求时, 都希望在界面中显示一个请求的图标</span></span><br><span class="line">    <span class="comment">// 3.某些网络请求(比如登录(token)), 必须携带一些特殊的信息</span></span><br><span class="line">    <span class="comment">// 得把config再返回</span></span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">  &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// console.log(err);</span></span><br><span class="line">  &#125;)</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 2.2.响应拦截 成功/失败</span></span><br><span class="line">  instance.interceptors.response.use(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// console.log(res);</span></span><br><span class="line">    <span class="keyword">return</span> res.data</span><br><span class="line">  &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.发送真正的网络请求</span></span><br><span class="line">    <span class="keyword">return</span> instance(config) <span class="comment">// 本身的返回值就是个promise</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// main.js</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  request封装v3.0 / v4.0的调用</span></span><br><span class="line">    request(&#123;</span><br><span class="line">      url: <span class="string">&#x27;/home/multidata&#x27;</span></span><br><span class="line">    &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(res);</span><br><span class="line">    &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// console.log(err);</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Vue 知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> ES6 </tag>
            
            <tag> Webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue2知识总结(二)</title>
      <link href="2021/06/19/Vue2%E7%AC%94%E8%AE%B0-%E4%BA%8C/"/>
      <url>2021/06/19/Vue2%E7%AC%94%E8%AE%B0-%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue2知识总结（二）"><a href="#Vue2知识总结（二）" class="headerlink" title="Vue2知识总结（二）"></a>Vue2知识总结（二）</h1><h1 id="WebPack使用"><a href="#WebPack使用" class="headerlink" title="WebPack使用"></a>WebPack使用</h1><ul><li><p>webpack是一个现代的JavaScript应用的静态<strong>模块打包</strong>工具。</p></li><li><p>我们从两个点来解释上面这句话：模块 和 打包</p></li></ul><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><ul><li>在ES6之前，我们要想进行模块化开发，就必须借助于其他的工具，让我们可以进行模块化开发。</li><li>并且在通过模块化开发完成了项目后，还需要<strong>处理模块间的各种依赖</strong>，并且将其进行<strong>整合打包</strong>。</li><li>而webpack其中一个核心就是让<strong>我们可能进行模块化开发</strong>，并且会帮助我<strong>们处理模块间的依赖关系</strong>。</li><li>而且不仅仅是JavaScript文件，我们的<strong>CSS、图片、json文件等等在webpack中都可以被当做模块来使用</strong>（在后续我们会看到）。</li><li>这就是<strong>webpack中模块化</strong>的概念。 </li></ul><h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><ul><li>理解了webpack可以帮助我们进行模块化，并且处理模块间的各种复杂关系后，打包的概念就非常好理解了。</li><li>就是将webpack中的各种资源模块进行<strong>打包</strong>合并成**一个或多个包(Bundle)**。</li><li>并且在打包的过程中，<strong>还可以对资源进行处理</strong>，比如<strong>压缩图片</strong>，<strong>将scss转成css</strong>，将<strong>ES6语法转成ES5语法</strong>，将TypeScript转成JavaScript等等操作。</li></ul><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><ul><li><p>所以，grunt/gulp和webpack有什么不同呢？</p><ul><li><p>grunt/gulp更加强调的是前端流程的自动化，模块化不是它的核心。</p></li><li><p>webpack更加强调<strong>模块化开发管理</strong>，而文件压缩合并、<strong>预处理等功能</strong>，是他附带的功能。</p></li></ul></li></ul><p><strong>webpack依赖node.js环境</strong></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack@<span class="number">3.6</span><span class="number">.0</span> -g  </span><br></pre></td></tr></table></figure><p>关于npm后面的疑惑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">npm install module_name -S 即 npm install module_name --save 写入dependencies</span><br><span class="line"></span><br><span class="line">npm install module_name -D 即（局部安装） npm install module_name --save-dev 写入devDependencies</span><br><span class="line"></span><br><span class="line">npm install module_name -g 全局安装(命令行使用)</span><br><span class="line"></span><br><span class="line">npm install module_name 本地安装(将安装包放在 ./node_modules 下)</span><br><span class="line"></span><br><span class="line">dependencies与devDependencies有什么区别呢？</span><br><span class="line">devDependencies 里面的插件只用于开发环境，不用于生产环境</span><br><span class="line">dependencies 是需要发布到生产环境的</span><br></pre></td></tr></table></figure><h3 id="局部安装"><a href="#局部安装" class="headerlink" title="局部安装"></a>局部安装</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--save-dev是开发时依赖，项目打包后不需要继续使用的。</span><br><span class="line">npm install webpack@<span class="number">3.6</span><span class="number">.0</span> --save-dev</span><br></pre></td></tr></table></figure><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220512161330080.png" alt="image-20220512161330080"></p><h3 id="js文件的打包"><a href="#js文件的打包" class="headerlink" title="js文件的打包"></a>js文件的打包</h3><ul><li><p>现在的js文件中使用了模块化的方式进行开发，他们可以直接使用吗？</p></li><li><p>不可以。在真实项目中当有许多这样的js文件时，我们一个个引用非常麻烦，并且后期非常不方便对它们进行管理。 </p></li><li><p>使用webpack工具 对多个js文件进行打包</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">打包命令</span><br><span class="line">webpack src/main.js dist/bundle.js</span><br></pre></td></tr></table></figure><h2 id="webpack配置"><a href="#webpack配置" class="headerlink" title="webpack配置"></a>webpack配置</h2></li></ul><h3 id="入口和出口"><a href="#入口和出口" class="headerlink" title="入口和出口"></a>入口和出口</h3><ul><li>webpack的命令都需要写上入口和出口作为参数</li><li>创建一个<strong>webpack.config.js</strong>文件，方便管理</li></ul><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220512161645405.png" alt="image-20220512161645405"></p><ul><li><p>因为output的路径得是绝对路径，需要安装path包</p><ul><li>依赖到node的包，建议先<strong>npm init</strong>初始化一下,会出现下面信息，填package name后一路回车就行，然后会生成<strong>package.json</strong>文件</li></ul></li><li><p> 在终端输入 <strong>webpack</strong> 就能直接打包了 ，但是在开发中一般不会用webpack，一般映射为npm run build</p></li></ul><h3 id="package-json中定义启动"><a href="#package-json中定义启动" class="headerlink" title="package.json中定义启动"></a>package.json中定义启动</h3><p> <img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220512162143842.png" alt="image-20220512162143842"></p><p>package.json中的scripts的脚本在执行时，会按照一定的顺序寻找命令对应的位置。</p><ul><li><p>首先，会寻找本地的node_modules/.bin路径中对应的命令。</p></li><li><p>如果没有找到，会去全局的环境变量中寻找。</p></li><li><p>如何执行我们的build指令呢？</p></li><li><p>```coffeescript<br>npm run build</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## css文件处理---css-loader的使用</span><br><span class="line"></span><br><span class="line">### 什么是loader？</span><br><span class="line"></span><br><span class="line">- loader是webpack中一个非常核心的概念。</span><br><span class="line">- 在我们之前的实例中，我们主要是用webpack来处理我们写的js代码，并且webpack会自动处理js之间相关的依赖。</span><br><span class="line">- 但是，在开发中我们不仅仅有基本的js代码处理，我们也需要加载css、图片，也包括一些高级的将ES6转成ES5代码，将TypeScript转成ES5代码，将scss、less转成css，将.jsx、.vue文件转成js文件等等。</span><br><span class="line">- 这时候需要 loader</span><br><span class="line"></span><br><span class="line">### css文件处理 – css-loader</span><br><span class="line"></span><br><span class="line">- 在webpack的官方中，我们可以找到如下关于样式的loader使用方法： </span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">npm install css-loader --save-dev</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F; 视频所用版本</span><br><span class="line">npm install css-loader@2.0.2 --save-dev</span><br></pre></td></tr></table></figure></li><li><p>但是，运行index.html，你会发现样式并没有生效。</p><ul><li>原因是css-loader只负责加载css文件，但是并不负责将css具体样式嵌入到文档中。</li><li>这个时候，我们还需要一个<strong>style-loader</strong>帮助我们处理。 </li></ul></li></ul><h3 id="css文件处理-–-style-loader"><a href="#css文件处理-–-style-loader" class="headerlink" title="css文件处理 – style-loader"></a>css文件处理 – style-loader</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev style-loader</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 视频所用版本</span></span><br><span class="line">npm install style-loader@<span class="number">0.23</span><span class="number">.1</span> --save-dev</span><br></pre></td></tr></table></figure><p>webpack.config.js的配置如下：</p><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220512162712316.png" alt="image-20220512162712316"></p><ul><li>注意：style-loader需要放在css-loader的前面。</li><li>疑惑：不对吧？按照我们的逻辑，在处理css文件过程中，应该是css-loader先加载css文件，再由style-loader来进行进一步的处理，为什么会将style-loader放在前面呢？</li><li>答案：这次因为webpack在读取使用的loader的过程中，是按照<strong>从右向左</strong>的顺序读取的。</li></ul><p>style-loader和css-loader作用是不同的。 </p><ul><li><code>css-loader</code>: 加载.css文件</li><li><code>style-loader</code>:使用<code>&lt;style&gt;</code>将css-loader内部样式注入到我们的HTML页面</li></ul><h3 id="less文件处理-–-less-loader"><a href="#less文件处理-–-less-loader" class="headerlink" title="less文件处理 – less-loader"></a>less文件处理 – less-loader</h3><p>require(‘./ss.less’) 引入后就会还需要安装less-loader</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev less-loader less</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 视频所用版本</span></span><br><span class="line">npm install --save-dev less-loader@<span class="number">4.1</span><span class="number">.0</span> less@<span class="number">3.9</span><span class="number">.0</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = require(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">module</span>.<span class="keyword">exports</span> = &#123;</span><br><span class="line">    entry: <span class="string">&#x27;./src/main.js&#x27;</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">        filename: <span class="string">&#x27;bundle.js&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">module</span>: &#123;</span><br><span class="line">        rules: [&#123;</span><br><span class="line">                test: /\.css$/,</span><br><span class="line">                use: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>]</span><br><span class="line">            &#125;,</span><br><span class="line">             <span class="comment">//less规则</span></span><br><span class="line">            &#123;</span><br><span class="line">                test: /\.less$/,</span><br><span class="line">                use: [&#123;</span><br><span class="line">                    loader: <span class="string">&quot;style-loader&quot;</span>, <span class="comment">// creates style nodes from JS strings</span></span><br><span class="line">                &#125;, &#123;</span><br><span class="line">                    loader: <span class="string">&quot;css-loader&quot;</span> <span class="comment">// translates CSS into CommonJS</span></span><br><span class="line">                &#125;, &#123;</span><br><span class="line">                    loader: <span class="string">&quot;less-loader&quot;</span>, <span class="comment">// compiles Less to CSS</span></span><br><span class="line">                &#125;]</span><br><span class="line">            &#125;,</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h3 id="图片文件处理-–-url-loader"><a href="#图片文件处理-–-url-loader" class="headerlink" title="图片文件处理 – url-loader"></a>图片文件处理 – url-loader</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev url-loader</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 视频所用版本</span></span><br><span class="line">npm install --save-dev url-loader@<span class="number">1.1</span><span class="number">.2</span></span><br></pre></td></tr></table></figure><ul><li>修改webpack.config.js配置文件：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加规则 </span></span><br><span class="line">&#123;</span><br><span class="line">        test: /\.(png|jpg|gif|jpeg)$/,</span><br><span class="line">        use: [&#123;</span><br><span class="line">          loader: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">              <span class="comment">//limit属性的作用，当图片小于8kb时，对图片进行base64编码</span></span><br><span class="line">            limit: <span class="number">8192</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;]</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h3 id="图片文件处理-–-file-loader"><a href="#图片文件处理-–-file-loader" class="headerlink" title="图片文件处理 – file-loader"></a>图片文件处理 – file-loader</h3><p>大于8kb的图片要用file-loader进行处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev file-loader</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 视频所用版本</span></span><br><span class="line">npm install --save-dev file-loader@<span class="number">3.0</span><span class="number">.1</span></span><br></pre></td></tr></table></figure><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220512163429623.png" alt="image-20220512163429623"></p><ul><li>我们发现webpack自动帮助我们生成一个非常长的名字</li><li>这是一个32位hash值，目的是防止名字重复</li><li>但是，真实开发中，我们可能对打包的图片名字有一定的要求</li><li>比如，将所有的图片放在一个文件夹中，跟上图片原来的名称，同时也要防止重复 </li><li>所以，我们可以在options中添加上如下选项：<br>img：文件要打包到的文件夹<br>name：获取图片原来的名字，放在该位置<br>hash:8：为了防止图片名称冲突，依然使用hash，但是我们只保留8位<br>ext：使用图片原来的扩展名 </li></ul><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220512163514276.png" alt="image-20220512163514276"></p><ul><li><p>但是，我们发现图片并没有显示出来，这是因为图片使用的路径不正确</p><ul><li>默认情况下，webpack会将生成的路径直接返回给使用者</li><li>但是，我们整个程序是打包在dist文件夹下的，所以这里我们需要在路径下再添加一个dist/ </li></ul><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220512163605266.png" alt="image-20220512163605266"></p></li></ul><h3 id="babel的使用（ES6转ES5）"><a href="#babel的使用（ES6转ES5）" class="headerlink" title="babel的使用（ES6转ES5）"></a>babel的使用（ES6转ES5）</h3><ul><li><p>如果你仔细阅读webpack打包的js文件，发现写的ES6语法并没有转成ES5，那么就意味着可能一些对ES6还不支持的浏览器没有办法很好的运行我们的代码。</p></li><li><p>在前面我们说过，如果希望将ES6的语法转成ES5，那么就需要使用babel。</p><ul><li>而在webpack中，我们直接使用babel对应的loader就可以了。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev babel-loader@<span class="number">7</span> babel-core babel-preset-es2015</span><br></pre></td></tr></table></figure><ul><li>配置webpack.config.js文件</li></ul><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220512163704574.png" alt="image-20220512163704574"></p><h3 id="webpack配置vue"><a href="#webpack配置vue" class="headerlink" title="webpack配置vue"></a>webpack配置vue</h3><ul><li>注：因为我们后续是在实际项目中也会使用vue的，所以并不是开发时依赖,不用加-dev</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue --save</span><br></pre></td></tr></table></figure><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220512163912259.png" alt="image-20220512163912259"></p><p><strong>Vue不同版本构建</strong>，后续具体讲解runtime-only和runtime-compiler的区别</p><p>修改webpack.config.js的配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">    extensions: [<span class="string">&#x27;.js&#x27;</span>, <span class="string">&#x27;.css&#x27;</span>, <span class="string">&#x27;.vue&#x27;</span>],</span><br><span class="line">    <span class="comment">// 可以省略扩展名， 比如引入vue文件&#x27;./vue/App.vue&#x27; 可以写成&#x27;./vue/App&#x27;</span></span><br><span class="line">    <span class="comment">// alias: 别名</span></span><br><span class="line">    alias: &#123;</span><br><span class="line">      <span class="string">&#x27;vue$&#x27;</span>: <span class="string">&#x27;vue/dist/vue.esm.js&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br></pre></td></tr></table></figure><h2 id="el和template区别"><a href="#el和template区别" class="headerlink" title="el和template区别"></a>el和template区别</h2><ul><li>那么，el和template模板的关系是什么呢？</li><li>在我们之前的学习中，我们知道el用于指定<strong>Vue要管理的DOM</strong>，可以帮助解析其中的指令、事件监听等等。</li><li>而如果Vue实例中同时指定了template，那么<strong>template模板的内容</strong>会替换掉<strong>挂载的对应el的模板</strong>。 </li><li>这样做有什么好处呢？</li><li>这样做之后我们就不需要在以后的开发中再次操作index.html，只需要在template中写入对应的标签即可</li></ul><h3 id="Vue的终极使用方案–-vue文件封装处理"><a href="#Vue的终极使用方案–-vue文件封装处理" class="headerlink" title="Vue的终极使用方案– .vue文件封装处理"></a>Vue的终极使用方案– .vue文件封装处理</h3><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220512164342940.png" alt="image-20220512164342940"></p><ul><li><p>但是，这个时候这个文件可以被正确的加载吗？</p><ul><li><p>必然不可以，这种特殊的文件以及特殊的格式，必须有人帮助我们处理。</p></li><li><p>谁来处理呢？<strong>vue-loader（加载）</strong>以及<strong>vue-template-compiler（编译）</strong>。 </p></li><li><p>安装vue-loader和vue-template-compiler </p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue-loader vue-template-compiler --save-dev</span><br></pre></td></tr></table></figure><p>修改webpack.config.js的配置文件：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        test: /\.vue$/,</span><br><span class="line">        use: [<span class="string">&#x27;vue-loader&#x27;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>会出现报错原因 应该是loader版本原因，在package.json里面修改一下版本号</li></ul><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220512164544641.png" alt="image-20220512164544641"></p><h3 id="plugin的使用"><a href="#plugin的使用" class="headerlink" title="plugin的使用"></a>plugin的使用</h3><ul><li><p>loader和plugin区别</p><ul><li>loader主要用于转换某些类型的模块，它是一个转换器。</li><li>plugin是插件，它是对webpack本身的扩展，是一个扩展器。 </li></ul></li><li><p>plugin的使用过程：</p><ul><li>步骤一：通过npm安装需要使用的plugins(某些webpack已经内置的插件不需要安装)</li><li>步骤二：在webpack.config.js中的plugins中配置插件。</li></ul></li></ul><h3 id="添加版权的Plugin"><a href="#添加版权的Plugin" class="headerlink" title="添加版权的Plugin"></a>添加版权的Plugin</h3><ul><li>该插件名字叫BannerPlugin，属于webpack自带的插件。</li></ul><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220512165115606.png" alt="image-20220512165115606"></p><h3 id="js压缩的Plugin"><a href="#js压缩的Plugin" class="headerlink" title="js压缩的Plugin"></a>js压缩的Plugin</h3><ul><li>在项目发布之前，我们必然需要对js等文件进行压缩处理<ul><li>这里，我们就对打包的js文件进行压缩</li><li>我们使用一个第三方的插件uglifyjs-webpack-plugin，并且版本号指定1.1.1，和CLI2保持一致</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install uglifyjs-webpack-plugin@<span class="number">1.1</span><span class="number">.1</span> --save-dev</span><br></pre></td></tr></table></figure><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220512170140248.png" alt="image-20220512170140248"></p><h3 id="webpack配置文件的分离"><a href="#webpack配置文件的分离" class="headerlink" title="webpack配置文件的分离"></a>webpack配置文件的分离</h3><ul><li>webpack根据开发和生成环境一般可以将配置文件拆分，拆分dev和prod两种环境</li><li>我们在根目录下创建build文件夹，并创建三个配置文件，分别是：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|- /build</span><br><span class="line">    |- base.config.js  公共配置</span><br><span class="line">    |- dev.config.js   开发配置</span><br><span class="line">    |- prod.config.js  生产配置</span><br></pre></td></tr></table></figure><p>细看<a href="https://blog.csdn.net/qq_23073811/article/details/118940864">https://blog.csdn.net/qq_23073811/article/details/118940864</a></p><h2 id="本地服务器"><a href="#本地服务器" class="headerlink" title="本地服务器"></a>本地服务器</h2><ul><li>webpack提供了一个可选的本地开发服务器，这个本地服务器基于node.js搭建，内部使用express框架，可以实现我们想要的让浏览器自动刷新显示我们修改后的结果。</li><li>不过它是一个单独的模块，在webpack中使用之前需要先安装它</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev webpack-dev-server@<span class="number">2.9</span><span class="number">.1</span></span><br></pre></td></tr></table></figure><ul><li> devserver也是作为webpack中的一个选项，选项本身可以设置如下属性</li><li>contentBase：为哪一个文件夹提供本地服务，默认是根文件夹，我们这里要填写./dist<br> port：端口号<br> inline：页面实时刷新<br> historyApiFallback：在SPA页面中，依赖HTML5的history模式</li></ul><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220512171010749.png" alt="image-20220512171010749"></p><h1 id="Vue-Cli"><a href="#Vue-Cli" class="headerlink" title="Vue Cli"></a>Vue Cli</h1><ul><li><p>CLI是Command-Line Interface, 翻译为<strong>命令行界面,</strong> 但是<strong>俗称脚手架.</strong></p></li><li><p><strong>使用 vue-cli 可以快速搭建Vue开发环境以及对应的webpack配置.</strong> </p></li><li><p>什么是NPM呢</p><ul><li>NPM的全称是Node Package Manager</li><li>是一个NodeJS包管理和分发工具，已经成为了非官方的发布Node模块（包）的标准。</li></ul></li></ul><p><strong>cnpm安装</strong></p><ul><li>由于国内直接使用 npm 的官方镜像是非常慢的，这里推荐使用淘宝 NPM 镜像。</li><li>你可以使用淘宝定制的 cnpm (gzip 压缩支持) 命令行工具代替默认的 npm:</li><li>npm install -g cnpm –registry=<a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a></li></ul><p>Cli是基于webpack静态资源打包框架</p><ul><li>安装Vue脚手架</li></ul><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">npm</span> install -g @vue/cli</span><br></pre></td></tr></table></figure><ul><li> Vue CLI2初始化项目</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue <span class="keyword">init</span> webpack my-project</span><br></pre></td></tr></table></figure><ul><li>Vue CLI3初始化项目</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue <span class="keyword">create</span> my<span class="operator">-</span>project</span><br></pre></td></tr></table></figure><h2 id="Vue-CLI2-0构建过程"><a href="#Vue-CLI2-0构建过程" class="headerlink" title="Vue CLI2.0构建过程"></a>Vue CLI2.0构建过程</h2><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220517102327678.png" alt="image-20220517102327678"></p><h3 id="目录结构详解"><a href="#目录结构详解" class="headerlink" title="目录结构详解"></a>目录结构详解</h3><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220517105209635.png" alt="image-20220517105209635"></p><h3 id="Runtime-Compiler和Runtime-only的区别"><a href="#Runtime-Compiler和Runtime-only的区别" class="headerlink" title="Runtime-Compiler和Runtime-only的区别"></a>Runtime-Compiler和Runtime-only的区别</h3><ul><li>简单总结<ul><li>如果在之后的开发中，你依然使用template，就需要选择Runtime-Compiler</li><li>如果你之后的开发中，使用的是.vue文件夹开发，那么可以选择Runtime-only </li></ul></li></ul><h3 id="vue程序运行过程"><a href="#vue程序运行过程" class="headerlink" title="vue程序运行过程"></a>vue程序运行过程</h3><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220517105654321.png" alt="image-20220517105654321"></p><ul><li>总结<ul><li><strong>Runtime-Compiler：</strong><ul><li>template -&gt; ast -&gt; render -&gt; vdom -&gt; 真实DOM</li></ul></li><li><strong>Runtime-only：</strong>(1.性能更高 2.下面的代码量更少)</li><li>render -&gt; vdom -&gt; UI</li></ul></li></ul><h3 id="render函数的使用"><a href="#render函数的使用" class="headerlink" title="render函数的使用"></a>render函数的使用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span></span><br><span class="line"> </span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span> <span class="comment">// 消息提示的环境配置，设置为开发环境或者生产环境</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* eslint-disable no-new */</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">// runtime-compiler</span></span><br><span class="line"><span class="comment">new Vue(&#123;</span></span><br><span class="line"><span class="comment">  el: &#x27;#app&#x27;,</span></span><br><span class="line"><span class="comment">  components: &#123; App &#125;,</span></span><br><span class="line"><span class="comment">  template: &#x27;&lt;App/&gt;&#x27;,</span></span><br><span class="line"><span class="comment">&#125;)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">// const cpn = &#123; // 组件</span></span><br><span class="line"><span class="comment">//   template: &#x27;&lt;div&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt;&#x27;,</span></span><br><span class="line"><span class="comment">//   data() &#123;</span></span><br><span class="line"><span class="comment">//     return &#123;</span></span><br><span class="line"><span class="comment">//       message: &#x27;我是组件message&#x27;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 也可以用下面这个方案 runtime-only</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span> (<span class="params">createElement</span>) </span>&#123; <span class="comment">// createElement是一个函数</span></span><br><span class="line">    <span class="comment">// 1.使用方式一: createElement(&#x27;标签&#x27;, &#123;标签的属性&#125;, [&#x27;内容&#x27;])</span></span><br><span class="line">    <span class="comment">// 1.1 基本使用</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// return createElement(&#x27;h2&#x27;, &#123;</span></span><br><span class="line">    <span class="comment">//   class: &#x27;box&#x27;</span></span><br><span class="line">    <span class="comment">// &#125;,</span></span><br><span class="line">    <span class="comment">// [&#x27;Hello World&#x27;])</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 1.2 嵌套render函数</span></span><br><span class="line">    <span class="comment">// return createElement(&#x27;h2&#x27;, &#123;</span></span><br><span class="line">    <span class="comment">//     class: &#x27;box&#x27;</span></span><br><span class="line">    <span class="comment">//   &#125;,</span></span><br><span class="line">    <span class="comment">//   [&#x27;Hello World&#x27;, createElement(&#x27;button&#x27;, [&#x27;按钮&#x27;])])</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 2.传入组件对象:</span></span><br><span class="line">    <span class="comment">// return createElement(cpn)</span></span><br><span class="line">    <span class="keyword">return</span> createElement(App)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="npm-run-build"><a href="#npm-run-build" class="headerlink" title="npm run build"></a>npm run build</h3><h3 id=""><a href="#" class="headerlink" title=""></a><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220517110245937.png" alt="image-20220517110245937"></h3><h3 id="npm-run-dev"><a href="#npm-run-dev" class="headerlink" title="npm run dev"></a>npm run dev</h3><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220517110307442.png" alt="image-20220517110307442"></p><h3 id="修改配置：webpack-base-conf-js起别名"><a href="#修改配置：webpack-base-conf-js起别名" class="headerlink" title="修改配置：webpack.base.conf.js起别名"></a>修改配置：webpack.base.conf.js起别名</h3><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220517110351224.png" alt="image-20220517110351224"></p><h2 id="Vue-Cli3-0"><a href="#Vue-Cli3-0" class="headerlink" title="Vue Cli3.0"></a>Vue Cli3.0</h2><ul><li>vue-cli 3 与 2 版本有很大区别</li><li>vue-cli 3 是基于 webpack 4 打造，vue-cli 2 还是 webapck 3</li><li>vue-cli 3 的设计原则是“0配置”，移除的配置文件根目录下的，build和config等目录</li><li>vue-cli 3 提供了 vue ui 命令，提供了可视化配置，更加人性化</li><li>移除了static文件夹，新增了public文件夹，并且index.html移动到public中 </li></ul><h3 id="vue-cli3-0-构建过程"><a href="#vue-cli3-0-构建过程" class="headerlink" title="vue cli3.0 构建过程"></a>vue cli3.0 构建过程</h3><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220517110704894.png" alt="image-20220517110704894"></p><h4 id="UI方面的配置"><a href="#UI方面的配置" class="headerlink" title="UI方面的配置"></a>UI方面的配置</h4><ul><li>启动配置服务器：vue ui</li></ul><h4 id="自定义配置：起别名"><a href="#自定义配置：起别名" class="headerlink" title="自定义配置：起别名"></a>自定义配置：起别名</h4><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220517110817209.png" alt="image-20220517110817209"></p><h4 id="箭头函数找this"><a href="#箭头函数找this" class="headerlink" title="箭头函数找this"></a>箭头函数找this</h4><p>往本身最近的上一层来找</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">      <span class="function"><span class="title">aaa</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">// window</span></span><br><span class="line">          &#125;)</span><br><span class="line"> </span><br><span class="line">          <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">// window</span></span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">// window</span></span><br><span class="line">          &#125;)</span><br><span class="line"> </span><br><span class="line">          <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">// obj</span></span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    obj.aaa()</span><br></pre></td></tr></table></figure><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><h3 id="后端路由阶段"><a href="#后端路由阶段" class="headerlink" title="后端路由阶段"></a>后端路由阶段</h3><ul><li>早期的网站开发整个HTML页面是由服务器来渲染的.</li><li>服务器直接生产渲染好对应的HTML页面, 返回给客户端进行展示. </li><li>但是, 一个网站, 这么多页面服务器如何处理呢?</li><li>一个页面有自己对应的网址, 也就是URL.</li><li>URL会发送到服务器, 服务器会通过正则对该URL进行匹配, 并且最后交给一个Controlle进行处理.</li><li>Controller进行各种处理, 最终生成HTML或者数据, 返回给前端.</li><li>这就完成了一个IO操作. </li><li>上面的这种操作, 就是后端路由.</li><li>当我们页面中需要请求不同的路径内容时, 交给服务器来进行处理, 服务器渲染好整个页面, 并且将页面返回给客户顿.</li><li>这种情况下渲染好的页面, 不需要单独加载任何的js和css, 可以直接交给浏览器展示, 这样也有利于SEO的优化. </li></ul><p>后端路由的缺点:</p><ul><li>一种情况是整个页面的模块由后端人员来编写和维护的.</li><li>另一种情况是前端开发人员如果要开发页面, 需要通过PHP和Java等语言来编写页面代码.</li><li>而且通常情况下HTML代码和数据以及对应的逻辑会混在一起, 编写和维护都是非常糟糕的事情.</li></ul><h3 id="前端路由阶段"><a href="#前端路由阶段" class="headerlink" title="前端路由阶段"></a>前端路由阶段</h3><ul><li>前后端分离阶段：</li><li>随着Ajax的出现, 有了前后端分离的开发模式.</li><li>后端只提供API来返回数据, 前端通过Ajax获取数据, 并且可以通过JavaScript将数据渲染到页面中.</li><li>这样做最大的优点就是前后端责任的清晰, 后端专注于数据上, 前端专注于交互和可视化上.</li><li>并且当移动端(iOS/Android)出现后, 后端不需要进行任何处理, 依然使用之前的一套API即可.</li><li>目前很多的网站依然采用这种模式开发. </li></ul><h3 id="单页面富应用阶段"><a href="#单页面富应用阶段" class="headerlink" title="单页面富应用阶段"></a><strong>单页面富应用阶段</strong></h3><ul><li>其实SPA最主要的特点就是在前后端分离的基础上加了一层前端路由.</li></ul><h3 id="前端路由核心"><a href="#前端路由核心" class="headerlink" title="前端路由核心"></a>前端路由核心</h3><ul><li>改变URL，但是页面不进行整体的刷新。</li></ul><h2 id="前端路由的规则"><a href="#前端路由的规则" class="headerlink" title="前端路由的规则"></a>前端路由的规则</h2><h3 id="URL的hash"><a href="#URL的hash" class="headerlink" title="URL的hash"></a>URL的hash</h3><ul><li>URL的hash<ul><li>URL的hash也就是锚点(#), 本质上是改变window.location的href属性.</li><li>我们可以通过直接赋值location.hash来改变href, 但是页面不发生刷新 </li></ul></li></ul><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220517153601809.png" alt="image-20220517153601809"></p><h3 id="HTML5的history模式：pushState"><a href="#HTML5的history模式：pushState" class="headerlink" title="HTML5的history模式：pushState"></a>HTML5的history模式：pushState</h3><ul><li>history接口是HTML5新增的, 它有五种模式改变URL而不刷新页面.</li><li>history.<strong>pushState</strong>() </li></ul><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220517155837195.png" alt="image-20220517155837195"></p><h3 id="HTML5的history模式：replaceState"><a href="#HTML5的history模式：replaceState" class="headerlink" title="HTML5的history模式：replaceState"></a>HTML5的history模式：<strong>replaceState</strong></h3><ul><li> history.<strong>replaceState</strong>()</li></ul><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220517155905486.png" alt="image-20220517155905486"></p><h3 id="HTML5的history模式：go"><a href="#HTML5的history模式：go" class="headerlink" title="HTML5的history模式：go"></a>HTML5的history模式：go</h3><ul><li>history.<strong>go</strong>()</li></ul><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220517155935331.png" alt="image-20220517155935331"></p><ul><li>补充</li><li>因为 history.back() 等价于 history.go(-1)</li><li>history.forward() 则等价于 history.go(1)</li><li>这三个接口等同于浏览器界面的前进后退。 </li></ul>]]></content>
      
      
      <categories>
          
          <category> Vue 知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> ES6 </tag>
            
            <tag> Webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue2知识总结(一)</title>
      <link href="2021/06/19/Vue2%E7%AC%94%E8%AE%B0-%E4%B8%80/"/>
      <url>2021/06/19/Vue2%E7%AC%94%E8%AE%B0-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue2知识总结（一）"><a href="#Vue2知识总结（一）" class="headerlink" title="Vue2知识总结（一）"></a>Vue2知识总结（一）</h1><h2 id="理解-Vue中的MVVM"><a href="#理解-Vue中的MVVM" class="headerlink" title="(理解)Vue中的MVVM"></a>(理解)Vue中的MVVM</h2><h3 id="Vue中的MVVM"><a href="#Vue中的MVVM" class="headerlink" title="Vue中的MVVM"></a>Vue中的MVVM</h3><ul><li>什么是MVVM呢？<ul><li>通常我们学习一个概念，最好的方式是去看维基百科(对，千万别看成了百度百科)</li><li><a href="https://zh.wikipedia.org/wiki/MVVM">https://zh.wikipedia.org/wiki/MVVM</a></li><li>维基百科的官方解释，我们这里不再赘述。</li></ul></li><li>我们直接来看Vue的MVVM（Model-View-ViewModel）</li></ul><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/20210711133503675.png" alt="img"></p><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/20190218151600647.jpeg" alt="img"></p><ul><li><strong>View层</strong>：<ul><li>视图层</li><li>在我们前端开发中，通常就是DOM层。</li><li>主要的作用是给用户展示各种信息。</li></ul></li><li><strong>Model层</strong>：<ul><li>数据层</li><li>数据可能是我们固定的死数据，更多的是来自我们服务器，从网络上请求下来的数据。</li><li>在我们计数器的案例中，就是后面抽取出来的obj，当然，里面的数据可能没有这么简单。</li></ul></li><li><strong>VueModel层:</strong><ul><li>视图模型层</li><li>视图模型层是View和Model沟通的桥梁。</li><li>一方面它实现了Data Binding，也就是数据绑定，将Model的改变实时的反应到View中</li><li>另一方面它实现了DOM Listener，也就是DOM监听，当DOM发生一些事件(点击、滚动、touch等)时，可以监听到，并在需要的情况下改变对应的Data。</li></ul></li></ul><p>MVVM的实现原理：MVVM的实现主要是三个核心点：</p><ul><li>响应式：vue如何监听data的属性变化</li><li>模板解析：vue的模板是如何被解析的、</li><li>渲染：vue模板是如何被渲染成HTML的</li></ul><h2 id="Vue的生命周期"><a href="#Vue的生命周期" class="headerlink" title="Vue的生命周期"></a>Vue的生命周期</h2><p>图一</p><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/20210711142920351.png" alt="img"></p><p>图二</p><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/2021071114294270.png" alt="img"></p><p>调用beforMount， 也就是说实际从creted到beforeMount之间，最主要的工作就是将模板或者el转换为render函数。不管是用el，还是用template, 或者是用我们最常用的.vue文件(如果是.vue文件，他其实是会先编译成为template)，最终他都是会被转换为render函数的。</p><p>beforeMount调用后，我们是不是要开始渲染render函数了，首先我们会先生产一个虚拟dom（用于后续数据发生变化时，新老虚拟dom对比计算），进行保存，然后再开始将render渲染成为真实的dom。</p><p>只有当我们状态数据发生变化时,我们在触发beforeUpdate，要开始将我们变化后的数据渲染到页面上了（实际上这里是有个判断的，判断当前的_isMounted是不是为ture并且isDestroyed是不是为false，也就是说，保证dom已经被挂载的情况下，且当前组件并未被销毁，才会走update流程）</p><p>然后再执行updated，所以updated里面也可以操作dom，并拿到最新更新后的dom。不过这里我要插一句话了，mouted和updated的执行，并不会等待所有子组件都被挂载完成后再执行，所以如果你希望所有视图都更新完毕后再做些什么事情，那么你最好在mouted或者updated中加一个$nextTick（），然后把要做的事情放在$netTick()中去做（至于为什么，以后讲到$nextTick再说吧    </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">        &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt;</span><br><span class="line">        &lt;button @click=&quot;changeMsg&quot;&gt;改变&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">        el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">        data: &#123;</span><br><span class="line">            message: <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            changeMsg () &#123;</span><br><span class="line">                <span class="keyword">this</span>.message = <span class="string">&#x27;goodbye world&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        beforeCreate() &#123;</span><br><span class="line">            console.log(<span class="string">&#x27;------初始化前------&#x27;</span>)</span><br><span class="line">            console.log(<span class="keyword">this</span>.message)</span><br><span class="line">            console.log(<span class="keyword">this</span>.$el)</span><br><span class="line">        &#125;,</span><br><span class="line">        created () &#123;</span><br><span class="line">            console.log(<span class="string">&#x27;------初始化完成------&#x27;</span>)</span><br><span class="line">            console.log(<span class="keyword">this</span>.message)</span><br><span class="line">            console.log(<span class="keyword">this</span>.$el)</span><br><span class="line">        &#125;,</span><br><span class="line">        beforeMount () &#123;</span><br><span class="line">            console.log(<span class="string">&#x27;------挂载前---------&#x27;</span>)</span><br><span class="line">            console.log(<span class="keyword">this</span>.message)</span><br><span class="line">            console.log(<span class="keyword">this</span>.$el)</span><br><span class="line">        &#125;,</span><br><span class="line">        mounted () &#123;</span><br><span class="line">            console.log(<span class="string">&#x27;------挂载完成---------&#x27;</span>)</span><br><span class="line">            console.log(<span class="keyword">this</span>.message)</span><br><span class="line">            console.log(<span class="keyword">this</span>.$el)</span><br><span class="line">        &#125;,</span><br><span class="line">        beforeUpdate () &#123;</span><br><span class="line">            console.log(<span class="string">&#x27;------更新前---------&#x27;</span>)</span><br><span class="line">            console.log(<span class="keyword">this</span>.message)</span><br><span class="line">            console.log(<span class="keyword">this</span>.$el)</span><br><span class="line">        &#125;,</span><br><span class="line">        updated() &#123;</span><br><span class="line">            console.log(<span class="string">&#x27;------更新后---------&#x27;</span>)</span><br><span class="line">            console.log(<span class="keyword">this</span>.message)</span><br><span class="line">            console.log(<span class="keyword">this</span>.$el)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220511210858387.png" alt="image-20220511210858387"></p><ul><li><p>beforeMount中，我们可以看出，我们拿到了$el，而mounted中，我们也拿到了$el， 不过好像有点不一样是吧。一个好像是渲染前的，一个是渲染后的。</p></li><li><p>会把我们的这个el（#app）编译成template模板啊，再转换为render函数，最后将render函数渲染成为真实dom，渲染成真实dom后，我们是不是会用这个渲染出来的dom去替换原来的vm.$el啊。这也就是我们前面所说到的替换$el是什么意思了。</p></li><li><p>所以， 在mounted中，我们所得到的渲染完成后的$el。</p></li></ul><p>加入了template变化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">        el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">        data: &#123;</span><br><span class="line">            message: <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        template: <span class="string">&#x27;&lt;div&gt;我是模板内的&#123;&#123;message&#125;&#125;&lt;/div&gt;&#x27;</span>,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            changeMsg () &#123;</span><br><span class="line">                <span class="keyword">this</span>.message = <span class="string">&#x27;goodbye world&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        beforeCreate() &#123;</span><br><span class="line">            console.log(<span class="string">&#x27;------初始化前------&#x27;</span>)</span><br><span class="line">            console.log(<span class="keyword">this</span>.message)</span><br><span class="line">            console.log(<span class="keyword">this</span>.$el)</span><br><span class="line">        &#125;,</span><br><span class="line">        created () &#123;</span><br><span class="line">            console.log(<span class="string">&#x27;------初始化完成------&#x27;</span>)</span><br><span class="line">            console.log(<span class="keyword">this</span>.message)</span><br><span class="line">            console.log(<span class="keyword">this</span>.$el)</span><br><span class="line">        &#125;,</span><br><span class="line">        beforeMount () &#123;</span><br><span class="line">            console.log(<span class="string">&#x27;------挂载前---------&#x27;</span>)</span><br><span class="line">            console.log(<span class="keyword">this</span>.message)</span><br><span class="line">            console.log(<span class="keyword">this</span>.$el)</span><br><span class="line">        &#125;,</span><br><span class="line">        mounted () &#123;</span><br><span class="line">            console.log(<span class="string">&#x27;------挂载完成---------&#x27;</span>)</span><br><span class="line">            console.log(<span class="keyword">this</span>.message)</span><br><span class="line">            console.log(<span class="keyword">this</span>.$el)</span><br><span class="line">        &#125;,</span><br><span class="line">        beforeUpdate () &#123;</span><br><span class="line">            console.log(<span class="string">&#x27;------更新前---------&#x27;</span>)</span><br><span class="line">            console.log(<span class="keyword">this</span>.message)</span><br><span class="line">            console.log(<span class="keyword">this</span>.$el)</span><br><span class="line">        &#125;,</span><br><span class="line">        updated() &#123;</span><br><span class="line">            console.log(<span class="string">&#x27;------更新后---------&#x27;</span>)</span><br><span class="line">            console.log(<span class="keyword">this</span>.message)</span><br><span class="line">            console.log(<span class="keyword">this</span>.$el)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220511210842424.png" alt="image-20220511210842424"  /><p>在beforeMount的时候，$el还是#app， 但是在mounted的时候就变成模板的div了，是不是因为我们传了个template啊，所以，他直接将这个template转换成render函数啦。再渲染成真实dom后，用渲染出来的真<strong>实dom替换了原来的$el</strong>。</p><p>删除了el属性</p><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220511211432792.png" alt="image-20220511211432792"></p><p>是不是只走了前面两个生命周期啊，后面就没走了，这个时候其实就是在等$mount被调用了，那我们加个按钮，点击按钮，手动调用一下$mount看会怎样</p><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220511211529670.png" alt="image-20220511211529670"></p><p>因此有些vue项目是手动触发mount</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">export <span class="keyword">default</span> new <span class="title">Vue</span><span class="params">(&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  el: <span class="string">&#x27;#app&#x27;</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  router,</span></span></span><br><span class="line"><span class="function"><span class="params">  store,</span></span></span><br><span class="line"><span class="function"><span class="params">  i18n,</span></span></span><br><span class="line"><span class="function"><span class="params">  render: h =&gt; h(App)</span></span></span><br><span class="line"><span class="function">&#125;)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">export <span class="keyword">default</span> new <span class="title">Vue</span><span class="params">(&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  router,</span></span></span><br><span class="line"><span class="function"><span class="params">  store,</span></span></span><br><span class="line"><span class="function"><span class="params">  i18n,</span></span></span><br><span class="line"><span class="function"><span class="params">  render: h =&gt; h(App)</span></span></span><br><span class="line"><span class="function">&#125;).$<span class="title">mount</span><span class="params">(<span class="string">&#x27;#app&#x27;</span>)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">就很出现两种写法</span></span><br></pre></td></tr></table></figure><h2 id="特殊语法"><a href="#特殊语法" class="headerlink" title="特殊语法"></a>特殊语法</h2><h3 id="v-pre"><a href="#v-pre" class="headerlink" title="v-pre"></a>v-pre</h3><ul><li>v-pre用于跳过这个元素和它子元素的编译过程，用于显示原本的Mustache语法。</li><li>比如下面的代码：<ul><li>第一个h2元素中的内容会被编译解析出来对应的内容</li><li>第二个h2元素中会直接显示</li></ul></li><li><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220511212739069.png" alt="image-20220511212739069"></li></ul><h3 id="v-cloak"><a href="#v-cloak" class="headerlink" title="v-cloak"></a>v-cloak</h3><ul><li>在某些情况下，我们浏览器可能会直接显然出未编译的Mustache标签。</li><li>应对延迟dom形成</li><li>cloak: 斗篷</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    [v-cloak] &#123;</span><br><span class="line">      display: none;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"> </span><br><span class="line">  &lt;div id=<span class="string">&quot;app&quot;</span> v-cloak&gt;</span><br><span class="line">    &lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"><span class="comment">/*v-cloak 指令用法</span></span><br><span class="line"><span class="comment">（1）插值表达式存在的问题：“闪动”</span></span><br><span class="line"><span class="comment">（2）如何解决该问题：使用v-cloak指令</span></span><br><span class="line"><span class="comment">（3）解决该问题的原理：先隐藏，替换好值之后再显示最终的值*/</span></span><br><span class="line"> &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    <span class="comment">// 在vue解析之前, div中有一个属性v-cloak</span></span><br><span class="line">    <span class="comment">// 在vue解析之后, div中没有一个属性v-cloak</span></span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">      <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">        el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">        data: &#123;</span><br><span class="line">          message: <span class="string">&#x27;你好啊&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="v-bind语法糖"><a href="#v-bind语法糖" class="headerlink" title="v-bind语法糖"></a><strong>v-bind语法糖</strong></h3><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220511213111891.png" alt="image-20220511213111891"></p><p>绑定class</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">用法二：也可以通过判断，传入多个值</span><br><span class="line">&lt;h2 :class=&quot;&#123;&#x27;active&#x27;: isActive, &#x27;line&#x27;: isLine&#125;&quot;&gt;Hello World&lt;/h2&gt;</span><br><span class="line">    </span><br><span class="line">用法三：和普通的类同时存在，并不冲突</span><br><span class="line">注：如果isActive和isLine都为<span class="keyword">true</span>，那么会有title/active/line三个类</span><br><span class="line">&lt;h2 class=&quot;title&quot; :class=&quot;&#123;&#x27;active&#x27;: isActive, &#x27;line&#x27;: isLine&#125;&quot;&gt;Hello World&lt;/h2&gt;</span><br><span class="line">    </span><br><span class="line">用法四：如果过于复杂，可以放在一个methods或者computed中</span><br><span class="line">注：classes是一个计算属性</span><br><span class="line">&lt;h2 class=&quot;title&quot; :class=&quot;classes&quot;&gt;Hello World&lt;/h2&gt;</span><br></pre></td></tr></table></figure><h3 id="v-bind和v-for结合"><a href="#v-bind和v-for结合" class="headerlink" title="v-bind和v-for结合"></a>v-bind和v-for结合</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &lt;li v-<span class="keyword">for</span>=<span class="string">&quot;(m, index) in movies&quot;</span> </span><br><span class="line">      :<span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;&#123;active:index==currentIndex&#125;&quot;</span> </span><br><span class="line">      <span class="meta">@click</span>=<span class="string">&quot;itemClick(index)&quot;</span>&gt;</span><br><span class="line">        &#123;&#123;index&#125;&#125;-&#123;&#123;m&#125;&#125;</span><br><span class="line">      &lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"> </span><br><span class="line">  &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">      el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">      data: &#123;</span><br><span class="line">        movies: [<span class="string">&#x27;海王&#x27;</span>, <span class="string">&#x27;海尔兄弟&#x27;</span>, <span class="string">&#x27;火影忍者&#x27;</span>, <span class="string">&#x27;进击的巨人&#x27;</span>],</span><br><span class="line">        currentIndex: <span class="number">0</span></span><br><span class="line">      &#125;,</span><br><span class="line">      methods: &#123;</span><br><span class="line">        itemClick(index) &#123;</span><br><span class="line">          <span class="keyword">this</span>.currentIndex = index;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><h3 id="v-bind-css"><a href="#v-bind-css" class="headerlink" title="v-bind css"></a>v-bind css</h3><ul><li><p>在写CSS属性名的时候</p></li><li><p>比如font-size</p><ul><li>我们可以使用驼峰式 (camelCase)  fontSize</li><li>或短横线分隔 (kebab-case，记得用单引号括起来) ‘font-size’</li></ul></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;h2 :style=&quot;&#123;color: currentColor, fontSize: fontSize + &#x27;px&#x27;&#125;&quot;&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;</span><br><span class="line"><span class="comment">//也可以调用方法</span></span><br><span class="line">&lt;h2 :style=&quot;getStyles()&quot;&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; </span><br></pre></td></tr></table></figure><h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &#123;&#123;&#125;&#125; 里面也可以调用方法，需要加()  </span></span><br><span class="line">    &lt;h2&gt;&#123;&#123;getFullName()&#125;&#125;&lt;/h2&gt;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;&#123;&#125;&#125; 里面一般用的是变量名，方法有个() 可能有点别扭，这时候就能使用计算属性 </span></span><br><span class="line">    &lt;!-- ！！计算属性不用加括号 --&gt;</span><br><span class="line">    &lt;h2&gt;&#123;&#123;fullName&#125;&#125;&lt;/h2&gt;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//对应方法</span></span><br><span class="line">  computed: &#123;</span><br><span class="line">          <span class="comment">// computed里面定义的也是函数，但是函数名一般不加类似于get的动词 </span></span><br><span class="line">          <span class="comment">//  但是它叫计算属性，所以一般起类似于属性的名字</span></span><br><span class="line">        fullName: function () &#123; </span><br><span class="line">          <span class="comment">// 这样写其实也是一个语法糖 里面有setter和getter 这个是getter</span></span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">&#x27; &#x27;</span> + <span class="keyword">this</span>.lastName</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//高阶函数计算</span></span><br><span class="line">      <span class="comment">// 算书本的总价   里面传一个回调函数 箭头函数</span></span><br><span class="line">      totalPrice: function () &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">this</span>.books.reduce((preValue, book) =&gt; &#123;</span><br><span class="line">          <span class="keyword">return</span> preValue + book.price * book.count</span><br><span class="line">        &#125;, <span class="number">0</span>)</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      methods: &#123;</span><br><span class="line">        getFullName() &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">&#x27; &#x27;</span> + <span class="keyword">this</span>.lastName</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h3 id="计算属性和methods的对比"><a href="#计算属性和methods的对比" class="headerlink" title="计算属性和methods的对比"></a>计算属性和methods的对比</h3><p>计算属性会进行缓存，如果多次使用时，计算属性只会调用一次。</p><h2 id="ES6拓展"><a href="#ES6拓展" class="headerlink" title="ES6拓展"></a>ES6拓展</h2><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btns = document.getElementsByTagName(<span class="string">&#x27;button&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; btns.length; i++) &#123;</span><br><span class="line">      (function (num) &#123; <span class="comment">// 0</span></span><br><span class="line">        btns[i].addEventListener(<span class="string">&#x27;click&#x27;</span>, function () &#123;</span><br><span class="line">          console.log(<span class="string">&#x27;第&#x27;</span> + num + <span class="string">&#x27;个按钮被点击&#x27;</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>立即函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 立即执行函数</span></span><br><span class="line">    (function () &#123;</span><br><span class="line"> </span><br><span class="line">    &#125;())</span><br><span class="line">    (function () &#123;</span><br><span class="line"> </span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><ul><li><strong>总结</strong><ul><li>ES5之前因为if和for都没有块级作用域的概念, 所以在很多时候, 我们都必须借助于function的作用域来解决应用外面变量的问题.</li><li>ES6中,加入了let, let它是有if和for的块级作用</li><li>总之，记住<ul><li>ES5中的var是没有块级作用域的(if/for) </li><li>ES6中的let是由块级作用的(if/for)</li></ul></li></ul></li></ul><h3 id="ES6对象字面量的增强写法"><a href="#ES6对象字面量的增强写法" class="headerlink" title="ES6对象字面量的增强写法"></a>ES6对象字面量的增强写法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> Object()</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">const</span> obj = &#123;  <span class="comment">// 这个&#123;&#125; 就是对象的字面量</span></span><br><span class="line">    name: <span class="string">&#x27;why&#x27;</span>,</span><br><span class="line">    age: <span class="number">18</span>,</span><br><span class="line">    run: function () &#123;</span><br><span class="line">      console.log(<span class="string">&#x27;在奔跑&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    eat: function () &#123;</span><br><span class="line">      console.log(<span class="string">&#x27;在次东西&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//ES5</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    run: function () &#123;</span><br><span class="line">    &#125;,</span><br><span class="line">    eat: function () &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line">  <span class="keyword">const</span> obj = &#123;</span><br><span class="line">    run() &#123;</span><br><span class="line">    &#125;,</span><br><span class="line">    eat() </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h2><h3 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h3><ul><li>缩写@</li><li>绑定事件</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 在调用方式, 如何手动的获取到浏览器参数的event对象: $event--&gt;</span><br><span class="line"><span class="meta">@click</span> = <span class="string">&quot;btn(abc, $event)&quot;</span></span><br></pre></td></tr></table></figure><h3 id="click-特殊事件处理"><a href="#click-特殊事件处理" class="headerlink" title="click 特殊事件处理"></a>click 特殊事件处理</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">  &lt;!--<span class="number">1.</span> .stop修饰符的使用  停止冒泡--&gt;</span><br><span class="line">  &lt;div @click=<span class="string">&quot;divClick&quot;</span>&gt;</span><br><span class="line">    aaaaaaa</span><br><span class="line">    &lt;button @click.stop=<span class="string">&quot;btnClick&quot;</span>&gt;按钮&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"> </span><br><span class="line">  &lt;!--<span class="number">2.</span> .prevent修饰符的使用 阻止默认行为--&gt;</span><br><span class="line">  &lt;br&gt;</span><br><span class="line">  &lt;form action=<span class="string">&quot;baidu&quot;</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;提交&quot;</span> @click.prevent=<span class="string">&quot;submitClick&quot;</span>&gt;</span><br><span class="line">  &lt;/form&gt;</span><br><span class="line"> </span><br><span class="line">  &lt;!--<span class="number">3.</span> .监听某个键盘的键帽--&gt;</span><br><span class="line">  &lt;input type=<span class="string">&quot;text&quot;</span> @keyup.enter=<span class="string">&quot;keyUp&quot;</span>&gt;</span><br><span class="line"> </span><br><span class="line">  &lt;!--<span class="number">4.</span> .once修饰符的使用 点击回调只会触发一次--&gt;</span><br><span class="line">  &lt;button @click.once=<span class="string">&quot;btn2Click&quot;</span>&gt;按钮<span class="number">2</span>&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h3 id="v-if-、v-else-if和v-else-的使用"><a href="#v-if-、v-else-if和v-else-的使用" class="headerlink" title="v-if 、v-else-if和v-else 的使用"></a>v-if 、v-else-if和v-else 的使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;h2 v-if=&quot;score&gt;=90&quot;&gt;优秀&lt;/h2&gt;</span><br><span class="line">&lt;h2 v-else-if=&quot;score&gt;=80&quot;&gt;良好&lt;/h2&gt;</span><br><span class="line">&lt;h2 v-else-if=&quot;score&gt;=60&quot;&gt;及格&lt;/h2&gt;</span><br><span class="line">&lt;h2 v-else&gt;不及格&lt;/h2&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="复用元素"><a href="#复用元素" class="headerlink" title="复用元素"></a>复用元素</h3><ul><li>如果我们不希望Vue出现类似重复利用的问题，可以给对应的input添加key</li><li>并且我们需要保证key的不同</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;span v-<span class="keyword">if</span>=<span class="string">&quot;isUser&quot;</span>&gt;</span><br><span class="line">   &lt;label for=&quot;username&quot;&gt;用户账号&lt;/label&gt;</span><br><span class="line">   &lt;input type=<span class="string">&quot;text&quot;</span> id=<span class="string">&quot;username&quot;</span> placeholder=<span class="string">&quot;用户账号&quot;</span> key=<span class="string">&quot;username&quot;</span>&gt;</span><br><span class="line"> &lt;/span&gt;</span><br><span class="line"> &lt;span v-<span class="keyword">else</span>&gt;</span><br><span class="line">   &lt;label for=&quot;email&quot;&gt;用户邮箱&lt;/label&gt;</span><br><span class="line">   &lt;input type=<span class="string">&quot;text&quot;</span> id=<span class="string">&quot;email&quot;</span> placeholder=<span class="string">&quot;用户邮箱&quot;</span> key=<span class="string">&quot;email&quot;</span>&gt;</span><br><span class="line"> &lt;/span&gt;</span><br><span class="line"> &lt;button @click=&quot;isUser = !isUser&quot;&gt;切换类型&lt;/button&gt;</span><br></pre></td></tr></table></figure><h3 id="v-show和v-if"><a href="#v-show和v-if" class="headerlink" title="v-show和v-if"></a>v-show和v-if</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;!--v-<span class="keyword">if</span>: 当条件为<span class="keyword">false</span>时, 包含v-<span class="keyword">if</span>指令的元素, 根本就不会存在dom中--&gt;</span><br><span class="line">&lt;h2 v-if=&quot;isShow&quot; id=&quot;aaa&quot;&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;</span><br><span class="line"> </span><br><span class="line">&lt;!--v-show: 当条件为<span class="keyword">false</span>时, v-show只是给我们的元素添加一个行内样式: display: none--&gt;</span><br><span class="line">&lt;h2 v-show=&quot;isShow&quot; id=&quot;bbb&quot;&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//value 是对象的值 key作为唯一标识 index是索引</span></span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li v-for=&quot;(value, key, index) in info&quot;&gt;&#123;&#123;value&#125;&#125;-&#123;&#123;key&#125;&#125;-&#123;&#123;index&#125;&#125;&lt;/li&gt;</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220511222541718.png" alt="image-20220511222541718"></p><ul><li>当某一层有很多相同的节点时，也就是列表节点时，我们希望插入一个新的节点<ul><li>我们希望可以在B和C之间加一个F，Diff算法默认执行起来是这样的。</li><li>即把C更新成F，D更新成C，E更新成D，最后再插入E，是不是很没有效率？</li></ul></li><li>所以我们需要使用key来给每个节点做一个唯一标识<ul><li>Diff算法就可以正确的识别此节点</li><li>找到正确的位置区插入新的节点。</li></ul></li><li>所以一句话，key的作用主要是为了高效的更新虚拟DOM。</li></ul><h2 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 1.push方法 </span></span><br><span class="line">   <span class="keyword">this</span>.letters.push(<span class="string">&#x27;aaa&#x27;</span>)</span><br><span class="line">   <span class="keyword">this</span>.letters.push(<span class="string">&#x27;aaaa&#x27;</span>, <span class="string">&#x27;bbbb&#x27;</span>, <span class="string">&#x27;cccc&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 2.pop(): 删除数组中的最后一个元素</span></span><br><span class="line">   <span class="keyword">this</span>.letters.pop();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 3.shift(): 删除数组中的第一个元素</span></span><br><span class="line">    <span class="keyword">this</span>.letters.shift();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 4.unshift(): 在数组最前面添加元素</span></span><br><span class="line">    <span class="keyword">this</span>.letters.unshift()</span><br><span class="line">    <span class="keyword">this</span>.letters.unshift(<span class="string">&#x27;aaa&#x27;</span>, <span class="string">&#x27;bbb&#x27;</span>, <span class="string">&#x27;ccc&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 5.splice作用: 删除元素/插入元素/替换元素</span></span><br><span class="line">          <span class="comment">// 删除元素: 第二个参数传入你要删除几个元素(如果没有传,就删除后面所有的元素)</span></span><br><span class="line">          <span class="comment">// 替换元素: 第二个参数, 表示我们要替换几个元素, 后面是用于替换前面的元素</span></span><br><span class="line">          <span class="comment">// 插入元素: 第二个参数, 传入0, 并且后面跟上要插入的元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.letters.splice(<span class="number">1</span>, <span class="number">3</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line"><span class="comment">// 排序</span></span><br><span class="line">    <span class="keyword">this</span>.letters.sort()</span><br><span class="line"><span class="comment">// 翻转</span></span><br><span class="line">    <span class="keyword">this</span>.letters.reverse()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果对数组内部进行修改，是不能做到双向绑定的</span></span><br><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="keyword">this</span>.letters.splice(<span class="number">0</span>, <span class="number">1</span>, <span class="string">&#x27;bbbbbb&#x27;</span>) </span><br><span class="line"><span class="comment">// 方法二        </span></span><br><span class="line">Vue.set(<span class="keyword">this</span>.letters, <span class="number">0</span>, <span class="string">&#x27;bbbbbb&#x27;</span>)     </span><br></pre></td></tr></table></figure><h2 id="过滤器filter"><a href="#过滤器filter" class="headerlink" title="过滤器filter"></a>过滤器filter</h2><ul><li><strong>过滤器可以用在两个地方：双花括号插值 或 v-bind表达式。</strong></li><li><strong><em>模板中文本后边需要添加管道符号（ | ）作为分隔，管道符 | 后边是文本的处理函数，处理函数的第一个参数是：管道符前边的——文本内容，如果处理函数上边传递参数，则从第二个参数依次往后是传递的参数。</em></strong></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//局部filter</span></span><br><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">    &lt;p&gt;电脑价格：&#123;&#123;price | addPriceIcon&#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line"> let vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">&quot;#app&quot;</span>,</span><br><span class="line">    data:&#123;</span><br><span class="line">        price:<span class="number">200</span></span><br><span class="line">    &#125;,</span><br><span class="line">    filters:&#123;</span><br><span class="line">        <span class="comment">//处理函数</span></span><br><span class="line">        addPriceIcon(value)&#123;</span><br><span class="line">            console.log(value)<span class="comment">//200</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;¥&#x27;</span> + value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">// 全局过滤器</span></span><br><span class="line"> &lt;h3&gt;&#123;&#123;viewContent | addNamePrefix&#125;&#125;&lt;/h3&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    Vue.filter(<span class="string">&quot;addNamePrefix&quot;</span>,(value)=&gt;&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;my name is&quot;</span> + value</span><br><span class="line">    &#125;)</span><br><span class="line"> </span><br><span class="line">    let vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">        el:<span class="string">&quot;#app&quot;</span>,</span><br><span class="line">        data:&#123;</span><br><span class="line">            viewContent:<span class="string">&quot;吕星辰&quot;</span> </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>全局过滤器</p><ul><li><strong>参数一：是过滤器的名字，也就是管道符后边的处理函数；</strong></li><li><strong>参数二：处理函数，处理函数的参数同上</strong></li></ul><p>实际开发是要放到js文件上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//filter.js 文件</span></span><br><span class="line">let filter_price = function (val,...params)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;¥&quot;</span> + val</span><br><span class="line">&#125;</span><br><span class="line">let filter_date = function ()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;2019/10/20&quot;</span> + val</span><br><span class="line">&#125;</span><br><span class="line">export &#123;filter_price,filter_date&#125; <span class="comment">//导出过滤函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//main.js</span></span><br><span class="line"><span class="comment">//下边是2种导入方式，推荐第一种</span></span><br><span class="line"><span class="keyword">import</span> * as _filter from <span class="string">&#x27;./filters/filter&#x27;</span></span><br><span class="line"><span class="comment">// import &#123;filter_price,filter_date&#125; from &#x27;./filters/filter&#x27;</span></span><br><span class="line"> </span><br><span class="line">console.log(_filter)</span><br><span class="line">    </span><br><span class="line"><span class="comment">//使用Object.keys（）方法，得到一个由key组成的数组，遍历数据，让key作为全局过滤器的名字，后边的是key对应的处理函数，这样在任何一个组件中都可以使用全局过滤器了</span></span><br><span class="line">Object.keys(_filter).forEach(item=&gt;&#123;</span><br><span class="line">  Vue.filter(item,_filter[item])</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  router,store,</span><br><span class="line">  render: h =&gt; h(App),</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span></span><br></pre></td></tr></table></figure><p>通过全局过滤器讲一个别的小知识点：当我们引用vue框架时，vue会被自动添加到window全局对象上边，而Vue正是一个构造函数，里边定义的是一些静态方法和静态属性，我们知道在ES6类中有静态方法，只有类可以调用！这样也就不难理解了，filter全局过滤器可以被Vue所调用，因为它是一个静态方法</p><h2 id="js高阶函数"><a href="#js高阶函数" class="headerlink" title="js高阶函数"></a>js高阶函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编程范式: 命令式编程/声明式编程</span></span><br><span class="line"><span class="comment">// 编程范式: 面向对象编程(第一公民:对象)/函数式编程(第一公民:函数)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="comment">// filter中的回调函数有一个要求: 必须返回一个boolean值</span></span><br><span class="line"><span class="comment">// true: 当返回true时, 函数内部会自动将这次回调的n加入到新的数组中</span></span><br><span class="line"><span class="comment">// false: 当返回false时, 函数内部会过滤掉这次的n</span></span><br><span class="line"><span class="keyword">const</span> nums = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">111</span>, <span class="number">222</span>, <span class="number">444</span>, <span class="number">40</span>, <span class="number">50</span>]</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 高阶函数 本身参数也是一个函数</span></span><br><span class="line"><span class="comment">// let total = nums.filter(n =&gt; n &lt; 100).map(n =&gt; n * 2).reduce((pre, n) =&gt; pre + n);</span></span><br><span class="line"><span class="comment">// console.log(total);</span></span><br><span class="line">let total = nums.filter(function (n) &#123;</span><br><span class="line">  <span class="keyword">return</span> n &lt; <span class="number">100</span></span><br><span class="line">&#125;).map(function (n) &#123;</span><br><span class="line">  <span class="keyword">return</span> n * <span class="number">2</span></span><br><span class="line">&#125;).reduce(function (prevValue, n) &#123;</span><br><span class="line">  <span class="keyword">return</span> prevValue + n</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line">console.log(total);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.filter函数的使用</span></span><br><span class="line"><span class="comment">// 10, 20, 40, 50</span></span><br><span class="line">let newNums = nums.filter(function (n) &#123;</span><br><span class="line">  <span class="keyword">return</span> n &lt; <span class="number">100</span></span><br><span class="line">&#125;)</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 2.map函数的使用</span></span><br><span class="line"><span class="comment">// 20, 40, 80, 100</span></span><br><span class="line">let new2Nums = newNums.map(function (n) &#123; <span class="comment">// 20</span></span><br><span class="line">  <span class="keyword">return</span> n * <span class="number">2</span></span><br><span class="line">&#125;)</span><br><span class="line">console.log(new2Nums);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.reduce函数的使用</span></span><br><span class="line"><span class="comment">// reduce 作用对数组中所有的内容进行汇总</span></span><br><span class="line">let total = new2Nums.reduce(function (preValue, n) &#123;</span><br><span class="line">  <span class="keyword">return</span> preValue + n</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line">console.log(total);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 第一次: preValue 0 n 20</span></span><br><span class="line"><span class="comment">// 第二次: preValue 20 n 40</span></span><br><span class="line"><span class="comment">// 第二次: preValue 60 n 80</span></span><br><span class="line"><span class="comment">// 第二次: preValue 140 n 100</span></span><br><span class="line"><span class="comment">// 240</span></span><br><span class="line"><span class="comment">// preValue是 预备值</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="表单绑定v-model"><a href="#表单绑定v-model" class="headerlink" title="表单绑定v-model"></a>表单绑定v-model</h2><ul><li>当我们在输入框输入内容时</li><li>因为input中的v-model绑定了message，所以会实时将输入的内容传递给message，message发生改变。</li><li>当message发生改变时，因为上面我们使用Mustache语法，将message的值插入到DOM中，所以DOM会发生响应的改变,实现了双向绑定</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">  &lt;input type=<span class="string">&quot;text&quot;</span> v-model=<span class="string">&quot;message&quot;</span>&gt;</span><br><span class="line">  &#123;&#123;message&#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">      message: <span class="string">&#x27;你好啊&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="v-model原理"><a href="#v-model原理" class="headerlink" title="v-model原理"></a>v-model原理</h3><ul><li>v-model其实是一个语法糖，它的背后本质上是包含两个操作：<ul><li>1.v-bind绑定一个value属性</li><li>2.v-on指令给当前元素绑定input事件</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> &lt;!--<span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;message&quot;</span>&gt;</span>--&gt;</span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- 上面等同于 --&gt;</span></span></span><br><span class="line">&lt;!--&lt;input type=&quot;text&quot; :value=&quot;message&quot; @input=&quot;valueChange&quot;&gt;--&gt;</span><br><span class="line"> </span><br><span class="line">&lt;!-- 也就是 --&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; :value=&quot;message&quot; @input=&quot;message = $event.target.value&quot;&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="v-model结合radio类型使用"><a href="#v-model结合radio类型使用" class="headerlink" title="v-model结合radio类型使用"></a>v-model结合radio类型使用</h3><ul><li><strong>单选按钮radio的value会影响v-model的值</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 需要加相同的name 否则可以多选 --&gt;</span><br><span class="line">&lt;!-- <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">id</span>=<span class="string">&quot;male&quot;</span> <span class="attr">value</span>=<span class="string">&quot;男&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span>&gt;</span>男 --&gt;</span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- 一旦v-moddel绑定的是同一个变量，name可以不用写 --&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line">&lt;input type=&quot;radio&quot; id=&quot;male&quot; value=&quot;男&quot; v-model=&quot;sex&quot;&gt;男</span><br><span class="line">&lt;input type=&quot;radio&quot; id=&quot;female&quot; value=&quot;女&quot; v-model=&quot;sex&quot;&gt;女</span><br><span class="line">    </span><br><span class="line">    const app = new Vue(&#123;</span><br><span class="line">      el: &#x27;#app&#x27;,</span><br><span class="line">      data: &#123;</span><br><span class="line">        message: &#x27;你好啊&#x27;,</span><br><span class="line">        sex: &#x27;女&#x27; // 可以给radio默认值</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><h3 id="v-model结合checkbox类型使用"><a href="#v-model结合checkbox类型使用" class="headerlink" title="v-model结合checkbox类型使用"></a>v-model结合checkbox类型使用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">  &lt;!--<span class="number">1.</span>checkbox单选框 --&gt;</span><br><span class="line">    &lt;!--  v-model即为布尔值<span class="literal">true</span>/<span class="literal">false</span>。此时input的value并不影响v-model的值--&gt;</span><br><span class="line">    &lt;label <span class="keyword">for</span>=<span class="string">&quot;agree&quot;</span>&gt;</span><br><span class="line">      &lt;input type=<span class="string">&quot;checkbox&quot;</span> id=<span class="string">&quot;agree&quot;</span> v-model=<span class="string">&quot;isAgree&quot;</span>&gt;同意协议</span><br><span class="line">    &lt;/label&gt;</span><br><span class="line"></span><br><span class="line"> &lt;!--<span class="number">2.</span>checkbox多选框--&gt;</span><br><span class="line">    &lt;!--  当是多个复选框时，因为可以选中多个，所以对应的data中属性是一个数组。当选中某一个时，就会将input的value添加到数组中。--&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;checkbox&quot;</span> value=<span class="string">&quot;篮球&quot;</span> v-model=<span class="string">&quot;hobbies&quot;</span>&gt;篮球</span><br><span class="line">    &lt;input type=<span class="string">&quot;checkbox&quot;</span> value=<span class="string">&quot;足球&quot;</span> v-model=<span class="string">&quot;hobbies&quot;</span>&gt;足球</span><br><span class="line">    &lt;input type=<span class="string">&quot;checkbox&quot;</span> value=<span class="string">&quot;乒乓球&quot;</span> v-model=<span class="string">&quot;hobbies&quot;</span>&gt;乒乓球</span><br><span class="line">    &lt;input type=<span class="string">&quot;checkbox&quot;</span> value=<span class="string">&quot;羽毛球&quot;</span> v-model=<span class="string">&quot;hobbies&quot;</span>&gt;羽毛球</span><br><span class="line">    &lt;h2&gt;您的爱好是: &#123;&#123;hobbies&#125;&#125;&lt;/h2&gt;</span><br><span class="line"> </span><br><span class="line">     &lt;!-- 值绑定 动态的给value赋值 --&gt;</span><br><span class="line">     &lt;!-- <span class="keyword">for</span> 标签的解释 label中的<span class="keyword">for</span>属性规定了label与哪个表单元素绑定。<span class="keyword">for</span>属性的值和表单元素的id值一样，即可完成该label标签与该表单元素的绑定。 --&gt;   </span><br><span class="line">    &lt;label <span class="keyword">for</span>=<span class="string">&quot;test&quot;</span>&gt;label标签&lt;/label&gt;</span><br><span class="line"></span><br><span class="line">    &lt;label v-<span class="keyword">for</span>=<span class="string">&quot;item in originHobbies&quot;</span> :<span class="keyword">for</span>=<span class="string">&quot;item&quot;</span>&gt;</span><br><span class="line">      &lt;input type=<span class="string">&quot;checkbox&quot;</span> :value=<span class="string">&quot;item&quot;</span> :id=<span class="string">&quot;item&quot;</span> v-model=<span class="string">&quot;hobbies&quot;</span>&gt;&#123;&#123;item&#125;&#125; &lt;/label&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//js</span></span><br><span class="line">   <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">      el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">      data: &#123;</span><br><span class="line">        message: <span class="string">&#x27;你好啊&#x27;</span>,</span><br><span class="line">        isAgree: <span class="literal">false</span>, <span class="comment">// 单选框</span></span><br><span class="line">        hobbies: [], <span class="comment">// 多选框,</span></span><br><span class="line">        originHobbies: [<span class="string">&#x27;篮球&#x27;</span>, <span class="string">&#x27;足球&#x27;</span>, <span class="string">&#x27;乒乓球&#x27;</span>, <span class="string">&#x27;羽毛球&#x27;</span>, <span class="string">&#x27;台球&#x27;</span>, <span class="string">&#x27;高尔夫球&#x27;</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><h3 id="v-model结合select类型使用"><a href="#v-model结合select类型使用" class="headerlink" title="v-model结合select类型使用"></a>v-model结合select类型使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单选   </span></span><br><span class="line">&lt;select name=<span class="string">&quot;abc&quot;</span> v-model=<span class="string">&quot;fruit&quot;</span>&gt;</span><br><span class="line">      &lt;option value=&quot;苹果&quot;&gt;苹果&lt;/option&gt;</span><br><span class="line">      &lt;option value=&quot;香蕉&quot;&gt;香蕉&lt;/option&gt;</span><br><span class="line">      &lt;option value=&quot;榴莲&quot;&gt;榴莲&lt;/option&gt;</span><br><span class="line">      &lt;option value=&quot;葡萄&quot;&gt;葡萄&lt;/option&gt;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">    &lt;h2&gt;您选择的水果是: &#123;&#123;fruit&#125;&#125;&lt;/h2&gt;</span><br><span class="line"></span><br><span class="line">&lt;select name=<span class="string">&quot;abc&quot;</span> v-model=<span class="string">&quot;fruits&quot;</span> multiple&gt;</span><br><span class="line">      &lt;option value=&quot;苹果&quot;&gt;苹果&lt;/option&gt;</span><br><span class="line">      &lt;option value=&quot;香蕉&quot;&gt;香蕉&lt;/option&gt;</span><br><span class="line">      &lt;option value=&quot;榴莲&quot;&gt;榴莲&lt;/option&gt;</span><br><span class="line">      &lt;option value=&quot;葡萄&quot;&gt;葡萄&lt;/option&gt;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">        </span><br><span class="line"> <span class="comment">//js</span></span><br><span class="line"> <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">      el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">      data: &#123;</span><br><span class="line">        message: <span class="string">&#x27;你好啊&#x27;</span>,</span><br><span class="line">        fruit: <span class="string">&#x27;香蕉&#x27;</span>,</span><br><span class="line">        fruits: []</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><h3 id="v-model-修饰符的使用"><a href="#v-model-修饰符的使用" class="headerlink" title="v-model 修饰符的使用"></a>v-model 修饰符的使用</h3><ul><li>lazy修饰符：<ul><li>默认情况下，v-model默认是在input事件中同步输入框的数据的。</li><li>也就是说，一旦有数据发生改变对应的data中的数据就会自动发生改变。</li><li>lazy修饰符可以让数据在失去焦点或者回车时才会更新</li></ul></li><li>number修饰符：<ul><li>默认情况下，在输入框中无论我们输入的是字母还是数字，都会被当做字符串类型进行处理。</li><li>但是如果我们希望处理的是数字类型，那么最好直接将内容当做数字处理。</li><li>number修饰符可以让在输入框中输入的内容自动转成数字类型</li></ul></li><li>trim修饰符：<ul><li>如果输入的内容首尾有很多空格，通常我们希望将其去除</li><li>trim修饰符可以过滤内容左右两边的空格</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--<span class="number">1.</span>修饰符: lazy 让数据在失去焦点或者回车时才会更新--&gt;</span><br><span class="line">  &lt;input type=<span class="string">&quot;text&quot;</span> v-model.lazy=<span class="string">&quot;message&quot;</span>&gt;</span><br><span class="line">  &lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">  &lt;!--<span class="number">2.</span>修饰符: number 让在输入框中输入的内容自动转成数字类型--&gt;</span><br><span class="line">  &lt;input type=<span class="string">&quot;number&quot;</span> v-model.number=<span class="string">&quot;age&quot;</span>&gt;</span><br><span class="line">  &lt;h2&gt;&#123;&#123;age&#125;&#125;-&#123;&#123;<span class="keyword">typeof</span> age&#125;&#125;&lt;/h2&gt;</span><br><span class="line"> </span><br><span class="line">  &lt;!--<span class="number">3.</span>修饰符: trim 过滤内容左右两边的空格--&gt;</span><br><span class="line">  &lt;input type=<span class="string">&quot;text&quot;</span> v-model.trim=<span class="string">&quot;name&quot;</span>&gt;</span><br><span class="line">  &lt;h2&gt;您输入的名字:&#123;&#123;name&#125;&#125;&lt;/h2&gt;</span><br></pre></td></tr></table></figure><h1 id="Vue组件化思想"><a href="#Vue组件化思想" class="headerlink" title="Vue组件化思想"></a>Vue组件化思想</h1><ul><li><p>组件化是Vue.js中的重要思想</p><ul><li>它提供了一种抽象，让我们可以开发出一个个独立可复用的小组件来构造我们的应用。</li><li>任何的应用都会被抽象成一颗组件树。</li></ul></li><li><p>组件的使用分成三个步骤：</p><ul><li>创建组件构造器</li><li>注册组件</li><li>使用组件。</li></ul></li></ul><p>组件注册实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 1.创建组件构造器对象  extend() 没有s</span></span><br><span class="line">    <span class="keyword">const</span> cpnC = Vue.extend(&#123;</span><br><span class="line">      <span class="comment">// 自定义组件的模板 使用到组件的地方，要显示的HTML代码</span></span><br><span class="line">      <span class="comment">// *最外需要一个div包裹</span></span><br><span class="line">      template: <span class="string">`</span></span><br><span class="line"><span class="string">      &lt;div&gt;</span></span><br><span class="line"><span class="string">        &lt;h2&gt;我是标题&lt;/h2&gt;</span></span><br><span class="line"><span class="string">        &lt;p&gt;我是内容, 哈哈哈哈&lt;/p&gt;</span></span><br><span class="line"><span class="string">        &lt;p&gt;我是内容, 呵呵呵呵&lt;/p&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;`</span></span><br><span class="line">    &#125;)</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 2.注册组件(全局注册) </span></span><br><span class="line">    <span class="comment">// 需要传递两个参数：</span></span><br><span class="line">    <span class="comment">// 1、注册组件的标签名 (必须加引号)</span></span><br><span class="line">    <span class="comment">// 2、组件构造器</span></span><br><span class="line">    Vue.component(<span class="string">&#x27;my-cpn&#x27;</span>, cpnC)</span><br><span class="line">   </span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">&lt;my-cpn&gt;&lt;/my-cpn&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>如果我们<strong>注册的组件是挂载在某个实例中, 那么就是一个局部组件</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">      message: <span class="string">&#x27;你好啊&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">      <span class="comment">// 使用组件时的标签名:组件构造器</span></span><br><span class="line">      <span class="comment">// &#x27;cpn&#x27;: cpnC  局部组件的标签名有无引号都可以</span></span><br><span class="line">      cpn: cpnC</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//区分 这是全局</span></span><br><span class="line">  Vue.component(<span class="string">&#x27;my-cpn&#x27;</span>, cpnC)</span><br></pre></td></tr></table></figure><h2 id="父组件和子组件"><a href="#父组件和子组件" class="headerlink" title="父组件和子组件"></a>父组件和子组件</h2><p> 前面我们看到了组件树：</p><ul><li>组件和组件之间存在层级关系</li><li>而其中一种非常重要的关系就是父子组件的关系</li></ul><p>语法糖组件注册</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;!--<span class="number">1.</span>script标签, 注意:类型必须是text/x-template 然后给它设置一个id --&gt;</span><br><span class="line">&lt;script type=<span class="string">&quot;text/x-template&quot;</span> id=<span class="string">&quot;cpn&quot;</span>&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h2&gt;我是标题&lt;/h2&gt;</span><br><span class="line">    &lt;p&gt;我是内容,哈哈哈&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"> </span><br><span class="line">&lt;!--<span class="number">2.</span>template标签--&gt;</span><br><span class="line">&lt;template id=<span class="string">&quot;cpn&quot;</span>&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h2&gt;我是标题&lt;/h2&gt;</span><br><span class="line">    &lt;p&gt;我是内容,呵呵呵&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1.注册一个全局组件</span></span><br><span class="line">  Vue.component(<span class="string">&#x27;cpn&#x27;</span>, &#123;</span><br><span class="line">    template: <span class="string">&#x27;#cpn&#x27;</span> <span class="comment">// 需要加上选择器</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><h2 id="数据存放"><a href="#数据存放" class="headerlink" title="数据存放"></a>数据存放</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      title: <span class="string">&#x27;abc&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>组件自己的数据存放在哪里呢?<ul><li>组件对象也有一个data属性(也可以有methods等属性，下面我们有用到)</li><li>只是这个data属性必须是一个函数</li><li>而且这个函数返回一个对象，对象内部保存着数据</li></ul></li></ul><h3 id="解释为什么要一个函数呢"><a href="#解释为什么要一个函数呢" class="headerlink" title="解释为什么要一个函数呢"></a>解释为什么要一个函数呢</h3><ul><li>为什么data在组件中必须是一个函数呢?<ul><li>首先，如果不是一个函数，Vue直接就会报错。</li><li>其次，原因是在于Vue让每个组件对象都返回一个新的对象，因为如果是同一个对象的，组件在多次使用后会相互影响。</li></ul></li></ul><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220512144302775.png" alt="image-20220512144302775"></p><h2 id="父子组件的通信"><a href="#父子组件的通信" class="headerlink" title="父子组件的通信"></a>父子组件的通信</h2><ul><li>通过<strong>props</strong>向子组件传递数据（<strong>父传子</strong>） 婆婆</li><li>通过<strong>事件</strong>向父组件发送消息（<strong>子传父</strong>）  报告</li></ul><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220512144400430.png" alt="image-20220512144400430"></p><h3 id="props基本用法"><a href="#props基本用法" class="headerlink" title="props基本用法"></a>props基本用法</h3><ul><li><strong>在组件中，使用选项props来声明需要从父级接收到的数据</strong>。</li><li>props的值有两种方式：<ul><li>方式一：<strong>字符串数组</strong>，数组中的字符串就是传递时的名称。</li><li>方式二：<strong>对象</strong>，对象可以设置传递时的类型，也可以设置默认值等。</li></ul></li></ul><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220512144547640.png" alt="image-20220512144547640"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- </span><br><span class="line">  步骤：</span><br><span class="line">  <span class="number">1.</span>在子组件里写props</span><br><span class="line">  <span class="number">2.</span>在子组件的标签加上v-bind  </span><br><span class="line">   &lt;cpn v-bind:props里定义的名称=<span class="string">&quot;父组件data数据名称&quot;</span>&gt;&lt;/cpn&gt;</span><br><span class="line">  <span class="number">3.</span>将props中的值显示在子组件中</span><br><span class="line"> --&gt;</span><br></pre></td></tr></table></figure><h3 id="props数据验证—对象写法"><a href="#props数据验证—对象写法" class="headerlink" title="props数据验证—对象写法"></a>props数据验证—对象写法</h3><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220512144814501.png" alt="image-20220512144814501"></p><p><strong>这里要注意</strong></p><ul><li> 提供一些默认值, 以及必传值</li><li> 类型是对象或者数组时, 默认值必须是一个工厂函数</li></ul><h3 id="props中的驼峰标识"><a href="#props中的驼峰标识" class="headerlink" title="props中的驼峰标识"></a>props中的驼峰标识</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">    &lt;!-- v-bind 不支持驼峰 需要换成 -  --&gt;</span><br><span class="line">    &lt;cpn :c-info=<span class="string">&quot;info&quot;</span> :child-my-message=<span class="string">&quot;message&quot;</span> v-bind:<span class="class"><span class="keyword">class</span>&gt;&lt;/<span class="title">cpn</span>&gt;</span></span><br><span class="line"><span class="class">  &lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="class"> </span></span><br><span class="line"><span class="class">  &lt;<span class="title">template</span> <span class="title">id</span></span>=<span class="string">&quot;cpn&quot;</span>&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h2&gt;&#123;&#123;cInfo&#125;&#125;&lt;/h2&gt;</span><br><span class="line">      &lt;h2&gt;&#123;&#123;childMyMessage&#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line"> </span><br><span class="line">  &lt;script src=<span class="string">&quot;../js/vue.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    <span class="keyword">const</span> cpn = &#123;</span><br><span class="line">      template: <span class="string">&#x27;#cpn&#x27;</span>,</span><br><span class="line">      props: &#123;</span><br><span class="line">        <span class="comment">// 在这里使用驼峰 :c-info=&quot;info&quot; 那里要用 -</span></span><br><span class="line">        cInfo: &#123;</span><br><span class="line">          type: <span class="built_in">Object</span>,</span><br><span class="line">          <span class="keyword">default</span> () &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        childMyMessage: &#123;</span><br><span class="line">          type: <span class="built_in">String</span>,</span><br><span class="line">          <span class="keyword">default</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">      el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">      data: &#123;</span><br><span class="line">        info: &#123;</span><br><span class="line">          name: <span class="string">&#x27;why&#x27;</span>,</span><br><span class="line">          age: <span class="number">18</span>,</span><br><span class="line">          height: <span class="number">1.88</span></span><br><span class="line">        &#125;,</span><br><span class="line">        message: <span class="string">&#x27;aaaaaa&#x27;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      components: &#123;</span><br><span class="line">        cpn</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="子级向父级传递—自定义事件-emit"><a href="#子级向父级传递—自定义事件-emit" class="headerlink" title="子级向父级传递—自定义事件 $emit()"></a>子级向父级传递—自定义事件 $emit()</h3><ul><li><p>子组件往父组件传递数据或者事件 </p></li><li><p>自定义事件的流程：</p><ul><li>在子组件中，通过$emit()来触发事件。</li><li>在父组件中，通过v-on来监听子组件事件。v-on的语法糖是@</li></ul></li></ul><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220512145433045.png" alt="image-20220512145433045"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发射事件: 自定义事件</span></span><br><span class="line"><span class="comment">// 2.在子组件中，通过$emit()来触发事件</span></span><br><span class="line"><span class="built_in">this</span>.$emit(<span class="string">&#x27;item-click&#x27;</span>, item)</span><br><span class="line"><span class="comment">// 注意！！！！这里的$emit事件名不要写成驼峰！！！脚手架里可以，会先编译成一个组件对象render函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//子组件调用自定义函数的时候，父组件就会监听并触发传过来的形参方法</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure><h3 id="父传子–结合双向绑定案例-数据访问"><a href="#父传子–结合双向绑定案例-数据访问" class="headerlink" title="父传子–结合双向绑定案例 数据访问"></a>父传子–结合双向绑定案例 数据访问</h3><ul><li>需求</li><li>子组件input绑定v-model，input改变,props里的number1、number2跟着改变，vue实例data里的num1,num2也跟着变</li><li>子组件data的dnumber1一改变，dnumber2就 *100, dnumber2一改变,dumber/100</li></ul><ul><li>分析</li><li>之前的v-model是绑定vue实例data里面的数据</li><li><strong>如果v-model绑定了props里的值，会报错（props里的值最好是通过父组件修改）</strong></li><li>v-model不要绑定props里的值用data或computed代替把number1,number2分别赋值给data的dnumber1,dnumber2</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 父组件 --&gt;</span><br><span class="line">  &lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">    &lt;h3&gt;父组件&lt;/h3&gt;</span><br><span class="line">    &lt;h3&gt;-----num1----&lt;/h3&gt;</span><br><span class="line">    &lt;h3&gt;&#123;&#123;num1&#125;&#125;&lt;/h3&gt;</span><br><span class="line">    &lt;h3&gt; -----num2----&lt;/h3&gt;</span><br><span class="line"> </span><br><span class="line">    &lt;h3&gt;&#123;&#123;num2&#125;&#125;&lt;/h3&gt;</span><br><span class="line">    &lt;hr&gt;</span><br><span class="line">    &lt;cpn :number1=<span class="string">&quot;num1&quot;</span> :number2=<span class="string">&quot;num2&quot;</span> @num1change=<span class="string">&quot;num1change&quot;</span> @num2change=<span class="string">&quot;num2change&quot;</span> /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"> </span><br><span class="line">  &lt;!-- 子组件 --&gt;</span><br><span class="line">  &lt;template id=<span class="string">&quot;cpn&quot;</span>&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;!-- 这样写会报错 应该是由父组件修改它，避免直接修改props的值 --&gt;</span><br><span class="line">      &lt;!--  <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;number1&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> /&gt;</span></span> --&gt;</span><br><span class="line">      &lt;!--  <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;number2&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> /&gt;</span></span> --&gt;</span><br><span class="line">     </span><br><span class="line"> </span><br><span class="line">      &lt;h3&gt;子组件&lt;/h3&gt;</span><br><span class="line"> </span><br><span class="line">      &lt;h3&gt; -----number1----&lt;/h3&gt;</span><br><span class="line">      &lt;!-- 为什么props也会跟着一起变? -&gt; number1绑定的是父组件num1 --&gt;</span><br><span class="line">      &lt;h2&gt;props:&#123;&#123;number1&#125;&#125;&lt;/h2&gt;</span><br><span class="line">      &lt;h2&gt;data:&#123;&#123;dnumber1&#125;&#125;&lt;/h2&gt;</span><br><span class="line"> </span><br><span class="line">      &lt;!--<span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;dnumber1&quot;</span>&gt;</span>--&gt;</span></span><br><span class="line"><span class="xml">      <span class="comment">&lt;!-- v-model的本质 用@input来传值 --&gt;</span></span></span><br><span class="line">      &lt;input type=&quot;text&quot; :value=&quot;dnumber1&quot; @input=&quot;num1Input&quot;&gt;</span><br><span class="line"> </span><br><span class="line">      &lt;h3&gt;-----number2----&lt;/h3&gt;</span><br><span class="line"> </span><br><span class="line">      &lt;h2&gt;props:&#123;&#123;number2&#125;&#125;&lt;/h2&gt;</span><br><span class="line">      &lt;h2&gt;data:&#123;&#123;dnumber2&#125;&#125;&lt;/h2&gt;</span><br><span class="line">      &lt;!--&lt;input type=&quot;text&quot; v-model=&quot;dnumber2&quot;&gt;--&gt;</span><br><span class="line">      &lt;input type=&quot;text&quot; :value=&quot;dnumber2&quot; @input=&quot;num2Input&quot;&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line"> </span><br><span class="line">  &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    // 子组件</span><br><span class="line">    const cpn = &#123;</span><br><span class="line">      template: &#x27;#cpn&#x27;,</span><br><span class="line">      props: &#123;</span><br><span class="line">        number1: Number,</span><br><span class="line">        number2: Number</span><br><span class="line">      &#125;,</span><br><span class="line">      data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">          dnumber1: this.number1,</span><br><span class="line">          dnumber2: this.number2</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      //方法一 用methods</span><br><span class="line">      methods: &#123;</span><br><span class="line">        num1Input(event) &#123;</span><br><span class="line">   //event代表事件的状态，例如触发event对象的元素、鼠标的位置及状态、按下的键等等。</span><br><span class="line">   // 1.将input中的value赋值到dnumber中</span><br><span class="line">          this.dnumber1 = event.target.value;</span><br><span class="line"> </span><br><span class="line">          // 2.为了让父组件可以修改值, 发出一个事件</span><br><span class="line">          this.$emit(&#x27;num1change&#x27;, this.dnumber1)</span><br><span class="line"> </span><br><span class="line">          // 3.同时修饰dnumber2的值</span><br><span class="line">          this.dnumber2 = this.dnumber1 * 100;</span><br><span class="line">          this.$emit(&#x27;num2change&#x27;, this.dnumber2);</span><br><span class="line">        &#125;,</span><br><span class="line">        num2Input(event) &#123;</span><br><span class="line">          this.dnumber2 = event.target.value;</span><br><span class="line">          this.$emit(&#x27;num2change&#x27;, this.dnumber2)</span><br><span class="line"> </span><br><span class="line">          // 同时修饰dnumber1的值</span><br><span class="line">          this.dnumber1 = this.dnumber2 / 100;</span><br><span class="line">          this.$emit(&#x27;num1change&#x27;, this.dnumber1);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      //方法2 用watch实现 监听数值 </span><br><span class="line">      watch: &#123;</span><br><span class="line">          dnumber1(newValue) &#123;</span><br><span class="line">            this.dnumber2 = newValue * 100;</span><br><span class="line">            this.$emit(&#x27;num1change&#x27;, newValue);</span><br><span class="line">          &#125;,</span><br><span class="line">          dnumber2(newValue) &#123;</span><br><span class="line">            this.number1 = newValue / 100;</span><br><span class="line">            this.$emit(&#x27;num2change&#x27;, newValue);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    // 父组件</span><br><span class="line">    const app = new Vue(&#123;</span><br><span class="line">      el: &#x27;#app&#x27;,</span><br><span class="line">      data: &#123;</span><br><span class="line">        num1: 1,</span><br><span class="line">        num2: 0</span><br><span class="line">      &#125;,</span><br><span class="line">      methods: &#123;</span><br><span class="line">        num1change(value) &#123;</span><br><span class="line">          // value传过来的是string类型,需要转换成数字</span><br><span class="line">          this.num1 = parseFloat(value)</span><br><span class="line">        &#125;,</span><br><span class="line">        num2change(value) &#123;</span><br><span class="line">          this.num2 = parseFloat(value)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      components: &#123;</span><br><span class="line">        cpn</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h3 id="watch选项"><a href="#watch选项" class="headerlink" title="watch选项"></a>watch选项</h3><p> watch选项能够监听值的变化。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- watch选项能够监听值的变化 --&gt;</span><br><span class="line">    &lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">        &lt;input type=<span class="string">&quot;text&quot;</span> v-model=<span class="string">&quot;number&quot;</span>&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;script src=<span class="string">&#x27;../js/vue.js&#x27;</span>&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">            el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">            data: &#123;</span><br><span class="line">                number: <span class="number">1</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            watch: &#123;</span><br><span class="line">                <span class="comment">// 监听number变量，当它有变化执行</span></span><br><span class="line">                <span class="comment">/* number(newValue, oldValue) &#123; // newValue新值，oldValue旧值 参数只写newValue也可以</span></span><br><span class="line"><span class="comment">                    console.log(&#x27;newVal&#x27;, newValue);</span></span><br><span class="line"><span class="comment">                    console.log(&#x27;oldVal&#x27;, oldValue);</span></span><br><span class="line"><span class="comment">                &#125; */</span></span><br><span class="line">                <span class="comment">// 也可以这样写</span></span><br><span class="line">                number: &#123;</span><br><span class="line">                    <span class="function"><span class="title">handler</span>(<span class="params">newValue, oldValue</span>)</span> &#123; <span class="comment">//handler方法就是你watch中需要具体执行的方法</span></span><br><span class="line">                        <span class="built_in">console</span>.log(<span class="string">&#x27;newVal&#x27;</span>, newValue);</span><br><span class="line">                        <span class="built_in">console</span>.log(<span class="string">&#x27;oldVal&#x27;</span>, oldValue);</span><br><span class="line">                    &#125;,</span><br><span class="line">                    immediate: <span class="literal">true</span></span><br><span class="line">                    <span class="comment">//immediate为true时则立即触发回调函数；如果为false，则和上面的例子一样，不会立即执行回调。</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h3 id="父子组件的访问"><a href="#父子组件的访问" class="headerlink" title="父子组件的访问"></a>父子组件的访问</h3><ul><li><strong>父</strong>组件访问<strong>子</strong>组件：使用**$children或$refs**</li><li><strong>子</strong>组件访问<strong>父</strong>组件：使用**$parent**</li></ul><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220512151605000.png" alt="image-20220512151605000"></p><h3 id="父子组件的访问方式：-refs（父访问子）"><a href="#父子组件的访问方式：-refs（父访问子）" class="headerlink" title="父子组件的访问方式： $refs（父访问子）"></a>父子组件的访问方式： $refs（父访问子）</h3><ul><li><p>children的缺陷:</p></li><li><p>通过$children访问子组件时，是一个<strong>数组类型</strong>，访问其中的子组件必须通过索引值。</p></li><li><p>但是当子组件过多，我们需要拿到其中一个时，往往不能确定它的索引值，甚至还可能会发生变化。</p></li><li><p>有时候，我们想明确获取其中一个特定的组件，这个时候就可以使用$refs</p></li><li><p>$refs的使用：</p><ul><li>$refs和ref指令通常是一起使用的。</li><li>首先，我们通过ref给某一个子组件绑定一个特定的ID。</li><li>其次，通过this.$refs.ID就可以访问到该组件了。</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在引用子组件的时候加入ref的特定id</span></span><br><span class="line">&lt;cpn ref=<span class="string">&quot;aaa&quot;</span>&gt;&lt;/cpn&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.$children得到数组,并进行调用方法</span></span><br><span class="line"><span class="built_in">this</span>.$children[<span class="number">0</span>].showMessage();</span><br><span class="line"></span><br><span class="line"><span class="comment">//父组件调用时用this.$refs.ID</span></span><br><span class="line"><span class="comment">// 2.$refs reference(引用)  =&gt; 对象类型, 默认是一个空的对象 ref=&#x27;bbb&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.$refs.aaa.name);</span><br></pre></td></tr></table></figure><h3 id="父子组件的访问方式：-parent-子访问父-、-root-根组件"><a href="#父子组件的访问方式：-parent-子访问父-、-root-根组件" class="headerlink" title="父子组件的访问方式： $parent(子访问父)、$root(根组件)"></a>父子组件的访问方式： $parent(子访问父)、$root(根组件)</h3><ul><li>如果我们想在子组件中直接访问父组件，可以通过$parent  <strong>但不建议使用</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子组件调用</span></span><br><span class="line">  <span class="function"><span class="title">btnClick</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">     <span class="comment">// 1.访问父组件$parent 里面的数据变量</span></span><br><span class="line">     <span class="comment">// console.log(this.$parent);</span></span><br><span class="line">     <span class="comment">// console.log(this.$parent.name);</span></span><br><span class="line"> </span><br><span class="line">     <span class="comment">// 2.访问根组件$root</span></span><br><span class="line">     <span class="built_in">console</span>.log(<span class="built_in">this</span>.$root);</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="built_in">this</span>.$root.message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h1><p>组件的插槽：</p><ul><li>组件的插槽也是为了让我们封装的组件更加具有扩展性。</li></ul><h3 id="slot基本使用"><a href="#slot基本使用" class="headerlink" title="slot基本使用"></a>slot基本使用</h3><ul><li><p>当子组件的功能复杂时，子组件的插槽可能并非是一个。</p><ul><li>比如我们封装一个导航栏的子组件，可能就需要三个插槽，分别代表左边、中间、右边。</li><li>那么，外面在给插槽插入内容时，如何区分插入的是哪一个呢？</li><li>这个时候，我们就需要给插槽起一个名字</li></ul><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220512152649747.png" alt="image-20220512152649747"></p></li></ul><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220512152838740.png" alt="image-20220512152838740"></p><h3 id="2-6-版本迭代"><a href="#2-6-版本迭代" class="headerlink" title="2.6+版本迭代"></a>2.6+版本迭代</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">cpn</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--任何没有被包裹在带有 v-slot 的 &lt;template&gt; 中的内容都会被视为默认插槽的内容。或者可以给他起名default--&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--&lt;template v-slot:default&gt;我是内容&lt;/template&gt;--&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- v-slot:center --&gt;</span></span><br><span class="line">        &lt; template v-slot:center &gt;</span><br><span class="line">                <span class="tag">&lt;<span class="name">span</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span>&gt;</span>替换没有名字的插槽<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line"></span><br><span class="line">//语法糖 #。。。</span><br><span class="line"><span class="tag">&lt;<span class="name">cpn</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- 跟 v-on 和 v-bind 一样，v-slot 也有缩写，即把参数之前的所有内容 (v-slot:) 替换为字符 #。例如 v-slot:header 可以被重写为 #header：，前提是必须要有插槽名！！！--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">template</span> #<span class="attr">right</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">span</span>&gt;</span>替换后的右边<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;cpn&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;left&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>左边<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;center&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>中间<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;right&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>右边<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">slot</span>&gt;</span>默认插槽内容<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure><h3 id="编译作用域"><a href="#编译作用域" class="headerlink" title="编译作用域"></a>编译作用域</h3><ul><li><strong>父组件模板的所有东西都会在父级作用域内编译；子组件模板的所有东西都会在子级作用域内编译。</strong></li><li>那么他的作用域就是父组件，使用的属性也是属于父组件的属性。</li><li>因此，isShow使用的是Vue实例中的属性，而不是子组件的属性。</li><li>子归子 父归父</li></ul><h3 id="作用域插槽：使用"><a href="#作用域插槽：使用" class="headerlink" title="作用域插槽：使用"></a>作用域插槽：使用</h3><ul><li>子组件定义的数据传到父组件上，并使用</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cpn</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--  v-slot:slot1=&#x27;props1&#x27; slot1是具名插槽的名字 props1是定义名字接受数据 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:slot1</span>=<span class="string">&#x27;props1&#x27;</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">                &lt;span&gt;</span></span><br><span class="line"><span class="comment">                    &#123;&#123;props1&#125;&#125;</span></span><br><span class="line"><span class="comment">                &lt;/span&gt; --&gt;</span></span><br><span class="line"> </span><br><span class="line">                <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;props1.data1.join(&#x27;-&#x27;)&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h3</span>&gt;</span></span><br><span class="line">                    &#123;&#123;props1.msg&#125;&#125;</span><br><span class="line">                <span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;cpn&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- 可以传多个值 所有的值会包含在一个对象中 在父组件中v-slot=&quot;&quot;中定义名字接收 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">slot</span> <span class="attr">:data1</span>=<span class="string">&#x27;movies&#x27;</span> <span class="attr">:msg</span>=<span class="string">&#x27;message&#x27;</span> <span class="attr">name</span>=<span class="string">&#x27;slot1&#x27;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(item, index) in movies&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span>&gt;</span></span><br><span class="line">                        &#123;&#123;item&#125;&#125;</span><br><span class="line">                    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">slot</span> <span class="attr">:data2</span>=<span class="string">&#x27;name&#x27;</span> <span class="attr">name</span>=<span class="string">&#x27;slot2&#x27;</span>&gt;</span></span><br><span class="line">                &#123;&#123;name&#125;&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">slot</span> <span class="attr">:data3</span>=<span class="string">&#x27;defult&#x27;</span>&gt;</span>默认插槽<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">&lt;!-- 子组件定义的数据 --&gt;</span></span><br><span class="line">        const cpn = &#123;</span><br><span class="line">            template: &#x27;#cpn&#x27;,</span><br><span class="line">            data() &#123;</span><br><span class="line">                return &#123;</span><br><span class="line">                    movies: [&#x27;战狼&#x27;, &#x27;鬼吹灯&#x27;, &#x27;盗墓笔记&#x27;],</span><br><span class="line">                    message: &#x27;你好呀&#x27;,</span><br><span class="line">                    name: &#x27;yangyanyan&#x27;,</span><br><span class="line">                    defult: &#x27;我是默认的数据&#x27;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h1 id="前端模块化"><a href="#前端模块化" class="headerlink" title="前端模块化"></a>前端模块化</h1><h2 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h2><ul><li><p>模块化有两个核心：导出和导入</p></li><li><p>CommonJS的导出：</p></li></ul><p><img src= "/img/loading1.gif" data-lazy-src="https://img-blog.csdnimg.cn/20210720175046818.png" alt="img"></p><ul><li><p>CommonJS的导入</p><p><img src= "/img/loading1.gif" data-lazy-src="https://img-blog.csdnimg.cn/20210720175121523.png" alt="img"></p></li></ul><h2 id="ES6的export指令"><a href="#ES6的export指令" class="headerlink" title="ES6的export指令"></a>ES6的export指令</h2><ul><li>export指令用于导出变量、</li><li>比如下面的代码：</li></ul><p><img src= "/img/loading1.gif" data-lazy-src="https://img-blog.csdnimg.cn/20210720212242467.png" alt="img"></p><ul><li>上面的代码还有另外一种写法：</li></ul><p><img src= "/img/loading1.gif" data-lazy-src="https://img-blog.csdnimg.cn/20210720212302731.png" alt="img"></p><h3 id="导出函数或类"><a href="#导出函数或类" class="headerlink" title="导出函数或类"></a>导出函数或类</h3><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220512155601483.png" alt="image-20220512155601483"></p><h3 id="export-default"><a href="#export-default" class="headerlink" title="export default"></a>export default</h3><ul><li><p>某些情况下，一个模块中包含某个的功能，我们并不希望给这个功能命名，而且让导入者可以自己来命名</p><ul><li>这个时候就可以使用export default </li></ul><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220512155647377.png" alt="image-20220512155647377"></p></li><li><p>我们来到main.js中，这样使用就可以了</p><ul><li>这里的myFunc是我自己命名的，你可以根据需要命名它对应的名字 </li></ul><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220512155722019.png" alt="image-20220512155722019"></p></li><li><p><strong>export default在同一个模块中，不允许同时存在多个</strong>。</p></li></ul><h2 id="ES6的import指令"><a href="#ES6的import指令" class="headerlink" title="ES6的import指令"></a>ES6的import指令</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.导入的&#123;&#125;中定义的变量和函数</span></span><br><span class="line"><span class="keyword">import</span> &#123;flag, sum&#125; <span class="keyword">from</span> <span class="string">&quot;./aaa.js&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (flag) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;小明是天才, 哈哈哈&#x27;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(sum(<span class="number">20</span>, <span class="number">30</span>));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 2.直接导入export定义的变量</span></span><br><span class="line"><span class="keyword">import</span> &#123;num1, height&#125; <span class="keyword">from</span> <span class="string">&quot;./aaa.js&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num1);</span><br><span class="line"><span class="built_in">console</span>.log(height);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 3.导入 export的function/class</span></span><br><span class="line"><span class="keyword">import</span> &#123;mul, Person&#125; <span class="keyword">from</span> <span class="string">&quot;./aaa.js&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(mul(<span class="number">30</span>, <span class="number">50</span>));</span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> Person();</span><br><span class="line">p.run()</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 4.导入 export default中的内容 可以根据需要命名它对应的名字</span></span><br><span class="line"><span class="keyword">import</span> addr <span class="keyword">from</span> <span class="string">&quot;./aaa.js&quot;</span>;</span><br><span class="line"> </span><br><span class="line">addr(<span class="string">&#x27;你好啊&#x27;</span>);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 5.统一全部导入 </span></span><br><span class="line"><span class="comment">// import &#123;flag, num, num1, height, Person, mul, sum&#125; from &quot;./aaa.js&quot;;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 通过*可以导入模块中所有的export变量</span></span><br><span class="line"><span class="comment">// 但是通常情况下我们需要给*起一个别名，方便后续的使用</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> aaa <span class="keyword">from</span> <span class="string">&#x27;./aaa.js&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(aaa.flag);</span><br><span class="line"><span class="built_in">console</span>.log(aaa.height);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Vue 知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> ES6 </tag>
            
            <tag> Webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>知识碎片  SpringMVC、 Servlet 、序列和反序列</title>
      <link href="2021/03/08/%E7%9F%A5%E8%AF%86%E7%A2%8E%E7%89%87-SpringMVC%E3%80%81-Servlet-%E3%80%81%E5%BA%8F%E5%88%97%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97/"/>
      <url>2021/03/08/%E7%9F%A5%E8%AF%86%E7%A2%8E%E7%89%87-SpringMVC%E3%80%81-Servlet-%E3%80%81%E5%BA%8F%E5%88%97%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="springMVC"><a href="#springMVC" class="headerlink" title="springMVC"></a><strong>springMVC</strong></h1><h2 id="1、springmvc工作原理图"><a href="#1、springmvc工作原理图" class="headerlink" title="1、springmvc工作原理图"></a>1、springmvc工作原理图</h2><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/1121080-20190509202147059-745656946.jpg"></p><h2 id="2、springmvc工作流程"><a href="#2、springmvc工作流程" class="headerlink" title="2、springmvc工作流程"></a>2、springmvc工作流程</h2><p>1、 用户向服务端发送一次请求，这个请求会先到前端控制器DispatcherServlet(也叫中央控制器)。<br>2、DispatcherServlet接收到请求后会调用HandlerMapping处理器映射器。由此得知，该请求该由哪个Controller来处理（并未调用Controller，只是得知）<br>3、DispatcherServlet调用HandlerAdapter处理器适配器，告诉处理器适配器应该要去执行哪个Controller<br>4、HandlerAdapter处理器适配器去执行Controller并得到ModelAndView(数据和视图)，并层层返回给DispatcherServlet<br>5、DispatcherServlet将ModelAndView交给ViewReslover视图解析器解析，然后返回真正的视图。<br>6、DispatcherServlet将模型数据填充到视图中<br>7、DispatcherServlet将结果响应给用户</p><h2 id="3、组件说明"><a href="#3、组件说明" class="headerlink" title="3、组件说明"></a>3、组件说明</h2><ul><li>DispatcherServlet：前端控制器，也称为中央控制器，它是整个请求响应的控制中心，组件的调用由它统一调度。</li><li>HandlerMapping：处理器映射器，它根据用户访问的 URL 映射到对应的后端处理器 Handler。也就是说它知道处理用户请求的后端处理器，但是它并不执行后端处理器，而是将处理器告诉给中央处理器。</li><li>HandlerAdapter：处理器适配器，它调用后端处理器中的方法，返回逻辑视图 ModelAndView 对象。</li><li>ViewResolver：视图解析器，将 ModelAndView 逻辑视图解析为具体的视图（如 JSP）。</li><li>Handler：后端处理器，对用户具体请求进行处理，也就是我们编写的 Controller 类。</li></ul><h2 id="4、-接口说明"><a href="#4、-接口说明" class="headerlink" title="4、 接口说明"></a>4、 接口说明</h2><p>HandlerMapping接口 – 处理请求的映射<br>HandlerMapping接口的实现类：<br>SimpleUrlHandlerMapping 通过配置文件，把一个URL映射到Controller<br>DefaultAnnotationHandlerMapping 通过注解，把一个URL映射到Controller类上</p><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/c6b474c8-91fa-3009-a0e9-c868ca52baf2.jpg"></p><p>HandlerAdapter接口 – 处理请求的映射<br>AnnotationMethodHandlerAdapter类，通过注解，把一个URL映射到Controller类的方法上</p><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/8475318e-d2e2-3dd2-81e9-036090f0aad1-16556034249644.jpg"></p><p>Controller接口 – 控制器<br>由于我们使用了@Controller注解，添加了@Controller注解注解的类就可以担任控制器（Action）的职责,</p><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/67b19bd0-e44c-311a-8d05-80d013cf44ae.jpg" alt="67b19bd0-e44c-311a-8d05-80d013cf44ae"></p><h2 id="5、为什么要选springMVC"><a href="#5、为什么要选springMVC" class="headerlink" title="5、为什么要选springMVC"></a>5、为什么要选springMVC</h2><p>Spring MVC是当前最优秀的MVC框架，自从Spring 2.5版本发布后，由于支持注解配置，易用性有了大幅度的提高。Spring 3.0更加完善，<strong>实现了对Struts 2的超越</strong>。现在越来越多的开发团队选择了<strong>Spring MVC</strong>。</p><p><strong>Struts2</strong>也是非常优秀的MVC构架，优点非常多比如良好的结构，拦截器的思想，丰富的功能。但这里想说的是缺点，Struts2由于采用了==值栈==、OGNL表达式、struts2标签库等，会导致应用的==性能下降==，应避免使用这些功能。而Struts2的多层拦截器、多实例action性能都很好。</p><h1 id="Servlet工作原理"><a href="#Servlet工作原理" class="headerlink" title="Servlet工作原理"></a>Servlet工作原理</h1><p>介绍：Servlet是sun公司提供的一门用于开发动态web资源的技术。</p><p>​       Sun公司在其API中提供了一个servlet接口，用户若想用发一个动态web资源(即开发一个Java程序向浏览器输出数据)，需要完成以下2个步骤：<br>　　1、编写一个<strong>Java类</strong>，实现<strong>servlet</strong>接口。<br>　　2、把开发好的Java类部署到web服务器中。<br>　　按照一种约定俗成的称呼习惯，通常我们也把<strong>实现了servlet接口的java程序</strong>，称之为Servlet.</p><h2 id="Servlet的运行过程"><a href="#Servlet的运行过程" class="headerlink" title="Servlet的运行过程"></a>Servlet的运行过程</h2><p>Servlet程序是由WEB服务器调用，web服务器收到客户端的Servlet访问请求后：<br>　　①Web服务器首先<strong>检查</strong>是否已经==装载并创建了该Servlet的实例对象==。如果是，则直接执行第④步，否则，执行第②步。<br>　　②装载并创建该Servlet的一个实例对象。<br>　　③调用Servlet实例对象的**init()**方法。<br>　　④创建一个用于封装HTTP请求消息的HttpServletRequest对象和一个代表HTTP响应消息的HttpServletResponse对象，然后调用Servlet的service()方法并将请求和响应对象作为参数传递进去。<br>　　⑤WEB应用程序被停止或重新启动之前，Servlet引擎将卸载Servlet，并在卸载之前调用Servlet的destroy()方法。 </p><h2 id="Servlet接口实现类"><a href="#Servlet接口实现类" class="headerlink" title="Servlet接口实现类"></a>Servlet接口实现类</h2><p>　   Servlet接口SUN公司定义了两个默认实现类，分别为：<strong>GenericServlet</strong>、<strong>HttpServlet</strong>。</p><p>　　HttpServlet指能够处理HTTP请求的servlet，它在原有Servlet接口上添加了==一些与HTTP协议处理方法==，它比Servlet接口的功能更为强大。因此开发人员在编写Servlet时，通常应继承这个类，而避免直接去实现Servlet接口。<br>　　HttpServlet在实现Servlet接口时，==覆写了service方法==，该方法体内的代码会自动判断用户的请求方式，如为<strong>GET请求</strong>，则调用HttpServlet的<strong>doGet</strong>方法，如为<strong>Post</strong>请求，则调用<strong>doPost</strong>方法。因此，开发人员在编写Servlet时，通常只需要覆写doGet或doPost方法，而不要去覆写service方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloServlet</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">super</span>();  </span><br><span class="line">    &#125;  </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">super</span>.destroy(); <span class="comment">// Just puts &quot;destroy&quot; string in log  </span></span><br><span class="line">    &#125;  </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span>  </span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ServletException, IOException </span>&#123;  </span><br><span class="line">  </span><br><span class="line">          </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span>  </span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ServletException, IOException </span>&#123;  </span><br><span class="line"></span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;servlet init&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h2 id="关于servlet并发问题"><a href="#关于servlet并发问题" class="headerlink" title="关于servlet并发问题"></a>关于servlet并发问题</h2><h3 id="Servlet的线程安全问题"><a href="#Servlet的线程安全问题" class="headerlink" title="Servlet的线程安全问题"></a>Servlet的线程安全问题</h3><p>   　当多个客户端并发访问同一个Servlet时，web服务器会为每一个客户端的访问请求创建一个线程，并在这个线程上调用Servlet的service方法，因此service方法内如果访问了同一个资源的话，就有可能引发线程安全问题。例如下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletDemo3</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>;   <span class="comment">//当存在有公共变量的时候，会发现并发期间数据不能够一致的问题</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span>  </span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ServletException, IOException </span>&#123;  </span><br><span class="line">          </span><br><span class="line">        i++;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            Thread.sleep(<span class="number">1000</span>*<span class="number">4</span>);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">        response.getWriter().write(i+<span class="string">&quot;&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span>  </span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ServletException, IOException </span>&#123;  </span><br><span class="line">        doGet(request, response);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h3 id="Servlet解决方法"><a href="#Servlet解决方法" class="headerlink" title="Servlet解决方法"></a>Servlet解决方法</h3><blockquote><p>如果直接引用<strong>synchronized</strong> (<strong>this</strong>) 进行锁对象的话，可能会导致多线程访问的时候会出现堵塞情况，处理不了高并发的问题</p></blockquote><p>​       <strong>让Servlet去实现一个SingleThreadModel接口，如果某个Servlet实现了==SingleThreadModel==接口，那么Servlet引擎将以单线程模式来调用其service方法。</strong><br>　　查看Sevlet的API可以看到，SingleThreadModel接口中没有定义任何方法和常量。</p><blockquote><p>在Java中，把没有定义任何方法和常量的接口称之为标记接口</p></blockquote><p>​       经常看到的一个最典型的标记接口就是”<strong>Serializable</strong>“，这个接口也是没有定义任何方法和常量的，标记接口在Java中有什么用呢？主要作用就是给某个对象打上一个标志，告诉JVM，这个对象可以做什么，比如实现了”<strong>Serializable</strong>“接口的类的对象就可以被序列化，还有一个”Cloneable”接口，这个也是一个标记接口，在默认情况下，Java中的对象是不允许被克隆的，就像现实生活中的人一样，不允许克隆，但是只要实现了”Cloneable”接口，那么对象就可以被克隆了。</p><p>​      但是实现了SingleThreadModel接口并<strong>不能真正解决的Servlet的线程安全问题</strong>，因为Servlet的引擎会创建多个Servlet的实例对象，而真正意义上解决多线程安全问题是指一个<strong>Servlet实例对象被多线程同时调用</strong>的问题。事实上，在Servlet API 2.4中，已经将SingleThreadModel标记为Deprecated（过时的）那么防止线程安全的问题就是避免使用<strong>实例变量</strong>，采用<strong>局部变量</strong>的形式。</p><h1 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h1><blockquote><p>序列说白了就是方便传输，传输时要拆解为二进制 ，传完后再重组，序列化能保证重组的准确性</p></blockquote><h2 id="序列化定义"><a href="#序列化定义" class="headerlink" title="序列化定义"></a>序列化定义</h2><p><strong>序列化</strong>：<code>Java</code>中的序列化机制能够将一个实例对象信息写入到一个字节流中（<strong>只序列化对象的属性值，而不会去序列化方法</strong>），序列化后的对象可用于网络传输，或者持久化到数据库、磁盘中。</p><p><strong>反序列化</strong>：需要对象的时候，再通过字节流中的信息来重构一个相同的对象。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><ul><li>一个对象序列化的接口，一个类只有实现了==Serializable==接口，它的对象才是==可序列化==的。因此如果要序列化某些类的对象，这些类就必须实现Serializable接口。而实际上，==Serializable是一个空接口==，==没有什么具体内容==，它的目的只是简单的标识一个类的对象可以被序列化。</li><li>String<code>已经内部实现了</code>Serializable</li></ul><h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><ol><li>比如说你的内存不够用了，那计算机就要将内存里面的一部分对象==暂时==的保存到硬盘中，等到要用的时候再读入到内存中，硬盘的那部分存储空间就是所谓的==虚拟内存==。在比如过你要将某个特定的对象保存到文件中，我隔几天在把它拿出来用，那么这时候就要实现Serializable接口</li><li>在进行java的Socket编程的时候，你有时候可能要传输某一类的对象，那么也就要实现Serializable接口；最常见的你传输一个字符串，它是JDK里面的类，也实现了Serializable接口，所以可以在网络上传输。</li></ol><h2 id="serialVersionUID-关键字"><a href="#serialVersionUID-关键字" class="headerlink" title="serialVersionUID 关键字"></a>serialVersionUID 关键字</h2><p>示例代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public final class String</span><br><span class="line">    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    &#x2F;** The value is used for character storage. *&#x2F;</span><br><span class="line">    private final char value[];</span><br><span class="line">    </span><br><span class="line">    &#x2F;** Cache the hash code for the string *&#x2F;</span><br><span class="line">    private int hash; &#x2F;&#x2F; Default to 0</span><br><span class="line"></span><br><span class="line">    &#x2F;** use serialVersionUID from JDK 1.0.2 for interoperability *&#x2F;</span><br><span class="line">    private static final long serialVersionUID &#x3D; -6849794470754667710L; &#x2F;&#x2F;这里有序列化id</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="serialVersionUID-作用"><a href="#serialVersionUID-作用" class="headerlink" title="serialVersionUID 作用"></a>serialVersionUID 作用</h2><p>因为序列化对象时，如果不显示的设置<code>serialVersionUID</code>，Java在序列化时会根据对象属性==自动==的生成一个<code>serialVersionUID</code>，再进行==存储或用作网络传输==。</p><p>在反序列化时，会根据对象属性自动再生成一个新的<code>serialVersionUID</code>，和序列化时生成的<code>serialVersionUID</code>进行==比对==，两个<code>serialVersionUID</code>相同则==反序列化==成功，否则就会抛异常。</p><p>而当显示的设置<code>serialVersionUID</code>后，Java在==序列化和反序列化==对象时，生成的<code>serialVersionUID</code>都为我们设定的<code>serialVersionUID</code>，这样就保证了==反序列化==的成功。</p><h2 id="transient-关键字"><a href="#transient-关键字" class="headerlink" title="transient 关键字"></a>transient 关键字</h2><p>序列化对象时如果希望哪个属性不被序列化，则用<code>transient</code>关键字修饰即可</p><p>可以看到字段<code>name</code>的值没有被保存到磁盘中，一旦变量被<code>transient</code>修饰，变量将不再是对象持久化的一部分，该变量内容在序列化后==无法获得访问==。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> String name; <span class="comment">//transient 在这里进行修饰</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Java序列化前的结果: User(name=fufu, age=<span class="number">18</span>)</span><br><span class="line">Java反序列化的结果:User(name=<span class="keyword">null</span>, age=<span class="number">18</span>)</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>一个静态变量不管是否被<code>transient</code>修饰，均不能被序列化。 因为<code>static</code>修饰的属性是属于类，而非对象。</p>]]></content>
      
      
      <categories>
          
          <category> Java 知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣习题 105. 从前序与中序遍历序列构造二叉树 解析</title>
      <link href="2021/02/03/%E5%8A%9B%E6%89%A3%E4%B9%A0%E9%A2%98-105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91-%E8%A7%A3%E6%9E%90/"/>
      <url>2021/02/03/%E5%8A%9B%E6%89%A3%E4%B9%A0%E9%A2%98-105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91-%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="力扣-105"><a href="#力扣-105" class="headerlink" title="力扣 105"></a>力扣 105</h1><h2 id="Q：从前序与中序遍历序列构造二叉树"><a href="#Q：从前序与中序遍历序列构造二叉树" class="headerlink" title="Q：从前序与中序遍历序列构造二叉树"></a>Q：从前序与中序遍历序列构造二叉树</h2><h2 id="1-解题"><a href="#1-解题" class="headerlink" title="1. 解题"></a>1. 解题</h2><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2. 解题思路"></a>2. 解题思路</h3><ul><li>通过前序遍历的数组找到树的根节点</li><li>通过中序遍历的数组找到左右子树</li><li>使用遍历手段或者HaspMap键值对来实现找根过程</li></ul><h3 id="3-相关图解"><a href="#3-相关图解" class="headerlink" title="3. 相关图解"></a>3. 相关图解</h3><ul><li><p>第一步初始化<br><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20210203154853182.png"></p></li><li><p>第二步通过前序遍历找到树根，划分左右子树，通过HashMap找到中序遍历里面的树根<br><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20210203155913663.png"></p></li><li><p>移动位置，然后同时找到相对的地方进行递归</p></li></ul><h3 id="3-代码分析"><a href="#3-代码分析" class="headerlink" title="3. 代码分析"></a>3. 代码分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> sun.reflect.generics.tree.Tree;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">tree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        TreeNode() &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">            <span class="keyword">this</span>.left = left;</span><br><span class="line">            <span class="keyword">this</span>.right = right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> preOrder 前序遍历数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inOrder  中序遍历数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preOrder, <span class="keyword">int</span>[] inOrder)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inOrder.length; i++) &#123;</span><br><span class="line">            map.put(inOrder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> buildTreeHelper(preOrder,<span class="number">0</span>,preOrder.length,inOrder,<span class="number">0</span>,inOrder.length,map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> preOrder 前序遍历数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> p_start 前序开始位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> p_end 前序结束位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inOrder 中序遍历数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i_start 中序开始位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i_end 中序结束位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map 键值对</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> root 树根</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTreeHelper</span><span class="params">(<span class="keyword">int</span>[] preOrder, <span class="keyword">int</span> p_start, <span class="keyword">int</span> p_end,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">int</span>[] inOrder, <span class="keyword">int</span> i_start, <span class="keyword">int</span> i_end,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    HashMap&lt;Integer, Integer&gt; map)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p_start == p_end) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> root_val = preOrder[p_start];</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(root_val);</span><br><span class="line">        <span class="keyword">int</span> root_index = map.get(root_val);</span><br><span class="line">        <span class="keyword">int</span> moveNum = root_index - i_start;</span><br><span class="line">        root.left = buildTreeHelper(preOrder, p_start+<span class="number">1</span>, p_start+moveNum+<span class="number">1</span>, inOrder, i_start, root_index, map);</span><br><span class="line">        root.right = buildTreeHelper(preOrder, p_start+moveNum+<span class="number">1</span>, p_end, inOrder, root_index+<span class="number">1</span>, i_end, map);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历数组</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printTree</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        System.out.print(root.val + <span class="string">&quot;  &quot;</span>);</span><br><span class="line">        printTree(root.left);</span><br><span class="line">        printTree(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] preOrder = &#123;<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="number">15</span>,<span class="number">7</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] inOrder = &#123;<span class="number">9</span>,<span class="number">3</span>,<span class="number">15</span>,<span class="number">20</span>,<span class="number">7</span>&#125;;</span><br><span class="line">        TreeNode root = buildTree(preOrder,inOrder);</span><br><span class="line"></span><br><span class="line">        printTree(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>1.优化多次使用for循环进行查找根操作</li><li>2.内部时间复杂度可以进一步优化</li><li>3.通过hashMap来快速存储，做到快速定位</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> LC </tag>
            
            <tag> 算法与数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试</title>
      <link href="2021/02/01/firstpost/"/>
      <url>2021/02/01/firstpost/</url>
      
        <content type="html"><![CDATA[<h1 id="第一次发布"><a href="#第一次发布" class="headerlink" title="第一次发布"></a>第一次发布</h1><ul><li>test</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test</span><br><span class="line">    <span class="comment">//ddd</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
