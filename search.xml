<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>力扣习题 105. 从前序与中序遍历序列构造二叉树 解析</title>
      <link href="2021/02/03/%E5%8A%9B%E6%89%A3%E4%B9%A0%E9%A2%98-105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91-%E8%A7%A3%E6%9E%90/"/>
      <url>2021/02/03/%E5%8A%9B%E6%89%A3%E4%B9%A0%E9%A2%98-105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91-%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="力扣-105"><a href="#力扣-105" class="headerlink" title="力扣 105"></a>力扣 105</h1><h2 id="Q：从前序与中序遍历序列构造二叉树"><a href="#Q：从前序与中序遍历序列构造二叉树" class="headerlink" title="Q：从前序与中序遍历序列构造二叉树"></a>Q：从前序与中序遍历序列构造二叉树</h2><h2 id="1-解题"><a href="#1-解题" class="headerlink" title="1. 解题"></a>1. 解题</h2><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2. 解题思路"></a>2. 解题思路</h3><ul><li>通过前序遍历的数组找到树的根节点</li><li>通过中序遍历的数组找到左右子树</li><li>使用遍历手段或者HaspMap键值对来实现找根过程</li></ul><h3 id="3-相关图解"><a href="#3-相关图解" class="headerlink" title="3. 相关图解"></a>3. 相关图解</h3><ul><li><p>第一步初始化</p><p><img src= "/img/loading1.gif" data-lazy-src="https://gitee.com/lu_sir0329/picture/raw/master/img/image-20210203154853182.png" alt="image-20210203154853182"></p></li><li><p>第二步通过前序遍历找到树根，划分左右子树，通过HashMap找到中序遍历里面的树根</p><p><img src= "/img/loading1.gif" data-lazy-src="https://gitee.com/lu_sir0329/picture/raw/master/img/image-20210203155913663.png" alt="image-20210203155913663"></p></li><li><p>移动位置，然后同时找到相对的地方进行递归</p></li></ul><h3 id="3-代码分析"><a href="#3-代码分析" class="headerlink" title="3. 代码分析"></a>3. 代码分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> sun.reflect.generics.tree.Tree;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">tree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        TreeNode() &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">            <span class="keyword">this</span>.left = left;</span><br><span class="line">            <span class="keyword">this</span>.right = right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> preOrder 前序遍历数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inOrder  中序遍历数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preOrder, <span class="keyword">int</span>[] inOrder)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inOrder.length; i++) &#123;</span><br><span class="line">            map.put(inOrder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> buildTreeHelper(preOrder,<span class="number">0</span>,preOrder.length,inOrder,<span class="number">0</span>,inOrder.length,map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> preOrder 前序遍历数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> p_start 前序开始位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> p_end 前序结束位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inOrder 中序遍历数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i_start 中序开始位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i_end 中序结束位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map 键值对</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> root 树根</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTreeHelper</span><span class="params">(<span class="keyword">int</span>[] preOrder, <span class="keyword">int</span> p_start, <span class="keyword">int</span> p_end,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">int</span>[] inOrder, <span class="keyword">int</span> i_start, <span class="keyword">int</span> i_end,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    HashMap&lt;Integer, Integer&gt; map)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p_start == p_end) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> root_val = preOrder[p_start];</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(root_val);</span><br><span class="line">        <span class="keyword">int</span> root_index = map.get(root_val);</span><br><span class="line">        <span class="keyword">int</span> moveNum = root_index - i_start;</span><br><span class="line">        root.left = buildTreeHelper(preOrder, p_start+<span class="number">1</span>, p_start+moveNum+<span class="number">1</span>, inOrder, i_start, root_index, map);</span><br><span class="line">        root.right = buildTreeHelper(preOrder, p_start+moveNum+<span class="number">1</span>, p_end, inOrder, root_index+<span class="number">1</span>, i_end, map);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历数组</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printTree</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        System.out.print(root.val + <span class="string">&quot;  &quot;</span>);</span><br><span class="line">        printTree(root.left);</span><br><span class="line">        printTree(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] preOrder = &#123;<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="number">15</span>,<span class="number">7</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] inOrder = &#123;<span class="number">9</span>,<span class="number">3</span>,<span class="number">15</span>,<span class="number">20</span>,<span class="number">7</span>&#125;;</span><br><span class="line">        TreeNode root = buildTree(preOrder,inOrder);</span><br><span class="line"></span><br><span class="line">        printTree(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>1.优化多次使用for循环进行查找根操作</li><li>2.内部时间复杂度可以进一步优化</li><li>3.通过hashMap来快速存储，做到快速定位</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> LC </tag>
            
            <tag> 算法与数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试</title>
      <link href="2021/02/01/firstpost/"/>
      <url>2021/02/01/firstpost/</url>
      
        <content type="html"><![CDATA[<h1 id="第一次发布"><a href="#第一次发布" class="headerlink" title="第一次发布"></a>第一次发布</h1><ul><li>test</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test</span><br><span class="line">    <span class="comment">//ddd</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
