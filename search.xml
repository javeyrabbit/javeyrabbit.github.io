<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Vue2知识总结</title>
      <link href="2021/06/19/Vue2%E7%AC%94%E8%AE%B0/"/>
      <url>2021/06/19/Vue2%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue2知识大全"><a href="#Vue2知识大全" class="headerlink" title="Vue2知识大全"></a>Vue2知识大全</h1><p>[TOC]</p><h2 id="理解-Vue中的MVVM"><a href="#理解-Vue中的MVVM" class="headerlink" title="(理解)Vue中的MVVM"></a>(理解)Vue中的MVVM</h2><h3 id="Vue中的MVVM"><a href="#Vue中的MVVM" class="headerlink" title="Vue中的MVVM"></a>Vue中的MVVM</h3><ul><li>什么是MVVM呢？<ul><li>通常我们学习一个概念，最好的方式是去看维基百科(对，千万别看成了百度百科)</li><li><a href="https://zh.wikipedia.org/wiki/MVVM">https://zh.wikipedia.org/wiki/MVVM</a></li><li>维基百科的官方解释，我们这里不再赘述。</li></ul></li><li>我们直接来看Vue的MVVM（Model-View-ViewModel）</li></ul><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/20210711133503675.png" alt="img"></p><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/20190218151600647.jpeg" alt="img"></p><ul><li><strong>View层</strong>：<ul><li>视图层</li><li>在我们前端开发中，通常就是DOM层。</li><li>主要的作用是给用户展示各种信息。</li></ul></li><li><strong>Model层</strong>：<ul><li>数据层</li><li>数据可能是我们固定的死数据，更多的是来自我们服务器，从网络上请求下来的数据。</li><li>在我们计数器的案例中，就是后面抽取出来的obj，当然，里面的数据可能没有这么简单。</li></ul></li><li><strong>VueModel层:</strong><ul><li>视图模型层</li><li>视图模型层是View和Model沟通的桥梁。</li><li>一方面它实现了Data Binding，也就是数据绑定，将Model的改变实时的反应到View中</li><li>另一方面它实现了DOM Listener，也就是DOM监听，当DOM发生一些事件(点击、滚动、touch等)时，可以监听到，并在需要的情况下改变对应的Data。</li></ul></li></ul><p>MVVM的实现原理：MVVM的实现主要是三个核心点：</p><ul><li>响应式：vue如何监听data的属性变化</li><li>模板解析：vue的模板是如何被解析的、</li><li>渲染：vue模板是如何被渲染成HTML的</li></ul><h2 id="Vue的生命周期"><a href="#Vue的生命周期" class="headerlink" title="Vue的生命周期"></a>Vue的生命周期</h2><p>图一</p><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/20210711142920351.png" alt="img"></p><p>图二</p><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/2021071114294270.png" alt="img"></p><p>调用beforMount， 也就是说实际从creted到beforeMount之间，最主要的工作就是将模板或者el转换为render函数。不管是用el，还是用template, 或者是用我们最常用的.vue文件(如果是.vue文件，他其实是会先编译成为template)，最终他都是会被转换为render函数的。</p><p>beforeMount调用后，我们是不是要开始渲染render函数了，首先我们会先生产一个虚拟dom（用于后续数据发生变化时，新老虚拟dom对比计算），进行保存，然后再开始将render渲染成为真实的dom。</p><p>只有当我们状态数据发生变化时,我们在触发beforeUpdate，要开始将我们变化后的数据渲染到页面上了（实际上这里是有个判断的，判断当前的_isMounted是不是为ture并且isDestroyed是不是为false，也就是说，保证dom已经被挂载的情况下，且当前组件并未被销毁，才会走update流程）</p><p>然后再执行updated，所以updated里面也可以操作dom，并拿到最新更新后的dom。不过这里我要插一句话了，mouted和updated的执行，并不会等待所有子组件都被挂载完成后再执行，所以如果你希望所有视图都更新完毕后再做些什么事情，那么你最好在mouted或者updated中加一个$nextTick（），然后把要做的事情放在$netTick()中去做（至于为什么，以后讲到$nextTick再说吧    </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">        &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt;</span><br><span class="line">        &lt;button @click=&quot;changeMsg&quot;&gt;改变&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">        el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">        data: &#123;</span><br><span class="line">            message: <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            changeMsg () &#123;</span><br><span class="line">                <span class="keyword">this</span>.message = <span class="string">&#x27;goodbye world&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        beforeCreate() &#123;</span><br><span class="line">            console.log(<span class="string">&#x27;------初始化前------&#x27;</span>)</span><br><span class="line">            console.log(<span class="keyword">this</span>.message)</span><br><span class="line">            console.log(<span class="keyword">this</span>.$el)</span><br><span class="line">        &#125;,</span><br><span class="line">        created () &#123;</span><br><span class="line">            console.log(<span class="string">&#x27;------初始化完成------&#x27;</span>)</span><br><span class="line">            console.log(<span class="keyword">this</span>.message)</span><br><span class="line">            console.log(<span class="keyword">this</span>.$el)</span><br><span class="line">        &#125;,</span><br><span class="line">        beforeMount () &#123;</span><br><span class="line">            console.log(<span class="string">&#x27;------挂载前---------&#x27;</span>)</span><br><span class="line">            console.log(<span class="keyword">this</span>.message)</span><br><span class="line">            console.log(<span class="keyword">this</span>.$el)</span><br><span class="line">        &#125;,</span><br><span class="line">        mounted () &#123;</span><br><span class="line">            console.log(<span class="string">&#x27;------挂载完成---------&#x27;</span>)</span><br><span class="line">            console.log(<span class="keyword">this</span>.message)</span><br><span class="line">            console.log(<span class="keyword">this</span>.$el)</span><br><span class="line">        &#125;,</span><br><span class="line">        beforeUpdate () &#123;</span><br><span class="line">            console.log(<span class="string">&#x27;------更新前---------&#x27;</span>)</span><br><span class="line">            console.log(<span class="keyword">this</span>.message)</span><br><span class="line">            console.log(<span class="keyword">this</span>.$el)</span><br><span class="line">        &#125;,</span><br><span class="line">        updated() &#123;</span><br><span class="line">            console.log(<span class="string">&#x27;------更新后---------&#x27;</span>)</span><br><span class="line">            console.log(<span class="keyword">this</span>.message)</span><br><span class="line">            console.log(<span class="keyword">this</span>.$el)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220511210858387.png" alt="image-20220511210858387"></p><ul><li><p>beforeMount中，我们可以看出，我们拿到了$el，而mounted中，我们也拿到了$el， 不过好像有点不一样是吧。一个好像是渲染前的，一个是渲染后的。</p></li><li><p>会把我们的这个el（#app）编译成template模板啊，再转换为render函数，最后将render函数渲染成为真实dom，渲染成真实dom后，我们是不是会用这个渲染出来的dom去替换原来的vm.$el啊。这也就是我们前面所说到的替换$el是什么意思了。</p></li><li><p>所以， 在mounted中，我们所得到的渲染完成后的$el。</p></li></ul><p>加入了template变化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">        el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">        data: &#123;</span><br><span class="line">            message: <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        template: <span class="string">&#x27;&lt;div&gt;我是模板内的&#123;&#123;message&#125;&#125;&lt;/div&gt;&#x27;</span>,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            changeMsg () &#123;</span><br><span class="line">                <span class="keyword">this</span>.message = <span class="string">&#x27;goodbye world&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        beforeCreate() &#123;</span><br><span class="line">            console.log(<span class="string">&#x27;------初始化前------&#x27;</span>)</span><br><span class="line">            console.log(<span class="keyword">this</span>.message)</span><br><span class="line">            console.log(<span class="keyword">this</span>.$el)</span><br><span class="line">        &#125;,</span><br><span class="line">        created () &#123;</span><br><span class="line">            console.log(<span class="string">&#x27;------初始化完成------&#x27;</span>)</span><br><span class="line">            console.log(<span class="keyword">this</span>.message)</span><br><span class="line">            console.log(<span class="keyword">this</span>.$el)</span><br><span class="line">        &#125;,</span><br><span class="line">        beforeMount () &#123;</span><br><span class="line">            console.log(<span class="string">&#x27;------挂载前---------&#x27;</span>)</span><br><span class="line">            console.log(<span class="keyword">this</span>.message)</span><br><span class="line">            console.log(<span class="keyword">this</span>.$el)</span><br><span class="line">        &#125;,</span><br><span class="line">        mounted () &#123;</span><br><span class="line">            console.log(<span class="string">&#x27;------挂载完成---------&#x27;</span>)</span><br><span class="line">            console.log(<span class="keyword">this</span>.message)</span><br><span class="line">            console.log(<span class="keyword">this</span>.$el)</span><br><span class="line">        &#125;,</span><br><span class="line">        beforeUpdate () &#123;</span><br><span class="line">            console.log(<span class="string">&#x27;------更新前---------&#x27;</span>)</span><br><span class="line">            console.log(<span class="keyword">this</span>.message)</span><br><span class="line">            console.log(<span class="keyword">this</span>.$el)</span><br><span class="line">        &#125;,</span><br><span class="line">        updated() &#123;</span><br><span class="line">            console.log(<span class="string">&#x27;------更新后---------&#x27;</span>)</span><br><span class="line">            console.log(<span class="keyword">this</span>.message)</span><br><span class="line">            console.log(<span class="keyword">this</span>.$el)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220511210842424.png" alt="image-20220511210842424"  /><p>在beforeMount的时候，$el还是#app， 但是在mounted的时候就变成模板的div了，是不是因为我们传了个template啊，所以，他直接将这个template转换成render函数啦。再渲染成真实dom后，用渲染出来的真<strong>实dom替换了原来的$el</strong>。</p><p>删除了el属性</p><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220511211432792.png" alt="image-20220511211432792"></p><p>是不是只走了前面两个生命周期啊，后面就没走了，这个时候其实就是在等$mount被调用了，那我们加个按钮，点击按钮，手动调用一下$mount看会怎样</p><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220511211529670.png" alt="image-20220511211529670"></p><p>因此有些vue项目是手动触发mount</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">export <span class="keyword">default</span> new <span class="title">Vue</span><span class="params">(&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  el: <span class="string">&#x27;#app&#x27;</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  router,</span></span></span><br><span class="line"><span class="function"><span class="params">  store,</span></span></span><br><span class="line"><span class="function"><span class="params">  i18n,</span></span></span><br><span class="line"><span class="function"><span class="params">  render: h =&gt; h(App)</span></span></span><br><span class="line"><span class="function">&#125;)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">export <span class="keyword">default</span> new <span class="title">Vue</span><span class="params">(&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  router,</span></span></span><br><span class="line"><span class="function"><span class="params">  store,</span></span></span><br><span class="line"><span class="function"><span class="params">  i18n,</span></span></span><br><span class="line"><span class="function"><span class="params">  render: h =&gt; h(App)</span></span></span><br><span class="line"><span class="function">&#125;).$<span class="title">mount</span><span class="params">(<span class="string">&#x27;#app&#x27;</span>)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">就很出现两种写法</span></span><br></pre></td></tr></table></figure><h2 id="特殊语法"><a href="#特殊语法" class="headerlink" title="特殊语法"></a>特殊语法</h2><h3 id="v-pre"><a href="#v-pre" class="headerlink" title="v-pre"></a>v-pre</h3><ul><li>v-pre用于跳过这个元素和它子元素的编译过程，用于显示原本的Mustache语法。</li><li>比如下面的代码：<ul><li>第一个h2元素中的内容会被编译解析出来对应的内容</li><li>第二个h2元素中会直接显示</li></ul></li><li><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220511212739069.png" alt="image-20220511212739069"></li></ul><h3 id="v-cloak"><a href="#v-cloak" class="headerlink" title="v-cloak"></a>v-cloak</h3><ul><li>在某些情况下，我们浏览器可能会直接显然出未编译的Mustache标签。</li><li>应对延迟dom形成</li><li>cloak: 斗篷</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    [v-cloak] &#123;</span><br><span class="line">      display: none;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"> </span><br><span class="line">  &lt;div id=<span class="string">&quot;app&quot;</span> v-cloak&gt;</span><br><span class="line">    &lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"><span class="comment">/*v-cloak 指令用法</span></span><br><span class="line"><span class="comment">（1）插值表达式存在的问题：“闪动”</span></span><br><span class="line"><span class="comment">（2）如何解决该问题：使用v-cloak指令</span></span><br><span class="line"><span class="comment">（3）解决该问题的原理：先隐藏，替换好值之后再显示最终的值*/</span></span><br><span class="line"> &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    <span class="comment">// 在vue解析之前, div中有一个属性v-cloak</span></span><br><span class="line">    <span class="comment">// 在vue解析之后, div中没有一个属性v-cloak</span></span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">      <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">        el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">        data: &#123;</span><br><span class="line">          message: <span class="string">&#x27;你好啊&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="v-bind语法糖"><a href="#v-bind语法糖" class="headerlink" title="v-bind语法糖"></a><strong>v-bind语法糖</strong></h3><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220511213111891.png" alt="image-20220511213111891"></p><p>绑定class</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">用法二：也可以通过判断，传入多个值</span><br><span class="line">&lt;h2 :class=&quot;&#123;&#x27;active&#x27;: isActive, &#x27;line&#x27;: isLine&#125;&quot;&gt;Hello World&lt;/h2&gt;</span><br><span class="line">    </span><br><span class="line">用法三：和普通的类同时存在，并不冲突</span><br><span class="line">注：如果isActive和isLine都为<span class="keyword">true</span>，那么会有title/active/line三个类</span><br><span class="line">&lt;h2 class=&quot;title&quot; :class=&quot;&#123;&#x27;active&#x27;: isActive, &#x27;line&#x27;: isLine&#125;&quot;&gt;Hello World&lt;/h2&gt;</span><br><span class="line">    </span><br><span class="line">用法四：如果过于复杂，可以放在一个methods或者computed中</span><br><span class="line">注：classes是一个计算属性</span><br><span class="line">&lt;h2 class=&quot;title&quot; :class=&quot;classes&quot;&gt;Hello World&lt;/h2&gt;</span><br></pre></td></tr></table></figure><h3 id="v-bind和v-for结合"><a href="#v-bind和v-for结合" class="headerlink" title="v-bind和v-for结合"></a>v-bind和v-for结合</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &lt;li v-<span class="keyword">for</span>=<span class="string">&quot;(m, index) in movies&quot;</span> </span><br><span class="line">      :<span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;&#123;active:index==currentIndex&#125;&quot;</span> </span><br><span class="line">      <span class="meta">@click</span>=<span class="string">&quot;itemClick(index)&quot;</span>&gt;</span><br><span class="line">        &#123;&#123;index&#125;&#125;-&#123;&#123;m&#125;&#125;</span><br><span class="line">      &lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"> </span><br><span class="line">  &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">      el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">      data: &#123;</span><br><span class="line">        movies: [<span class="string">&#x27;海王&#x27;</span>, <span class="string">&#x27;海尔兄弟&#x27;</span>, <span class="string">&#x27;火影忍者&#x27;</span>, <span class="string">&#x27;进击的巨人&#x27;</span>],</span><br><span class="line">        currentIndex: <span class="number">0</span></span><br><span class="line">      &#125;,</span><br><span class="line">      methods: &#123;</span><br><span class="line">        itemClick(index) &#123;</span><br><span class="line">          <span class="keyword">this</span>.currentIndex = index;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><h3 id="v-bind-css"><a href="#v-bind-css" class="headerlink" title="v-bind css"></a>v-bind css</h3><ul><li><p>在写CSS属性名的时候</p></li><li><p>比如font-size</p><ul><li>我们可以使用驼峰式 (camelCase)  fontSize</li><li>或短横线分隔 (kebab-case，记得用单引号括起来) ‘font-size’</li></ul></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;h2 :style=&quot;&#123;color: currentColor, fontSize: fontSize + &#x27;px&#x27;&#125;&quot;&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;</span><br><span class="line"><span class="comment">//也可以调用方法</span></span><br><span class="line">&lt;h2 :style=&quot;getStyles()&quot;&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; </span><br></pre></td></tr></table></figure><h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &#123;&#123;&#125;&#125; 里面也可以调用方法，需要加()  </span></span><br><span class="line">    &lt;h2&gt;&#123;&#123;getFullName()&#125;&#125;&lt;/h2&gt;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;&#123;&#125;&#125; 里面一般用的是变量名，方法有个() 可能有点别扭，这时候就能使用计算属性 </span></span><br><span class="line">    &lt;!-- ！！计算属性不用加括号 --&gt;</span><br><span class="line">    &lt;h2&gt;&#123;&#123;fullName&#125;&#125;&lt;/h2&gt;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//对应方法</span></span><br><span class="line">  computed: &#123;</span><br><span class="line">          <span class="comment">// computed里面定义的也是函数，但是函数名一般不加类似于get的动词 </span></span><br><span class="line">          <span class="comment">//  但是它叫计算属性，所以一般起类似于属性的名字</span></span><br><span class="line">        fullName: function () &#123; </span><br><span class="line">          <span class="comment">// 这样写其实也是一个语法糖 里面有setter和getter 这个是getter</span></span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">&#x27; &#x27;</span> + <span class="keyword">this</span>.lastName</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//高阶函数计算</span></span><br><span class="line">      <span class="comment">// 算书本的总价   里面传一个回调函数 箭头函数</span></span><br><span class="line">      totalPrice: function () &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">this</span>.books.reduce((preValue, book) =&gt; &#123;</span><br><span class="line">          <span class="keyword">return</span> preValue + book.price * book.count</span><br><span class="line">        &#125;, <span class="number">0</span>)</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      methods: &#123;</span><br><span class="line">        getFullName() &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">&#x27; &#x27;</span> + <span class="keyword">this</span>.lastName</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h3 id="计算属性和methods的对比"><a href="#计算属性和methods的对比" class="headerlink" title="计算属性和methods的对比"></a>计算属性和methods的对比</h3><p>计算属性会进行缓存，如果多次使用时，计算属性只会调用一次。</p><h2 id="ES6拓展"><a href="#ES6拓展" class="headerlink" title="ES6拓展"></a>ES6拓展</h2><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btns = document.getElementsByTagName(<span class="string">&#x27;button&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; btns.length; i++) &#123;</span><br><span class="line">      (function (num) &#123; <span class="comment">// 0</span></span><br><span class="line">        btns[i].addEventListener(<span class="string">&#x27;click&#x27;</span>, function () &#123;</span><br><span class="line">          console.log(<span class="string">&#x27;第&#x27;</span> + num + <span class="string">&#x27;个按钮被点击&#x27;</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>立即函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 立即执行函数</span></span><br><span class="line">    (function () &#123;</span><br><span class="line"> </span><br><span class="line">    &#125;())</span><br><span class="line">    (function () &#123;</span><br><span class="line"> </span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><ul><li><strong>总结</strong><ul><li>ES5之前因为if和for都没有块级作用域的概念, 所以在很多时候, 我们都必须借助于function的作用域来解决应用外面变量的问题.</li><li>ES6中,加入了let, let它是有if和for的块级作用</li><li>总之，记住<ul><li>ES5中的var是没有块级作用域的(if/for) </li><li>ES6中的let是由块级作用的(if/for)</li></ul></li></ul></li></ul><h3 id="ES6对象字面量的增强写法"><a href="#ES6对象字面量的增强写法" class="headerlink" title="ES6对象字面量的增强写法"></a>ES6对象字面量的增强写法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> Object()</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">const</span> obj = &#123;  <span class="comment">// 这个&#123;&#125; 就是对象的字面量</span></span><br><span class="line">    name: <span class="string">&#x27;why&#x27;</span>,</span><br><span class="line">    age: <span class="number">18</span>,</span><br><span class="line">    run: function () &#123;</span><br><span class="line">      console.log(<span class="string">&#x27;在奔跑&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    eat: function () &#123;</span><br><span class="line">      console.log(<span class="string">&#x27;在次东西&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//ES5</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    run: function () &#123;</span><br><span class="line">    &#125;,</span><br><span class="line">    eat: function () &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line">  <span class="keyword">const</span> obj = &#123;</span><br><span class="line">    run() &#123;</span><br><span class="line">    &#125;,</span><br><span class="line">    eat() </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h2><h3 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h3><ul><li>缩写@</li><li>绑定事件</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 在调用方式, 如何手动的获取到浏览器参数的event对象: $event--&gt;</span><br><span class="line"><span class="meta">@click</span> = <span class="string">&quot;btn(abc, $event)&quot;</span></span><br></pre></td></tr></table></figure><h3 id="click-特殊事件处理"><a href="#click-特殊事件处理" class="headerlink" title="click 特殊事件处理"></a>click 特殊事件处理</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">  &lt;!--<span class="number">1.</span> .stop修饰符的使用  停止冒泡--&gt;</span><br><span class="line">  &lt;div @click=<span class="string">&quot;divClick&quot;</span>&gt;</span><br><span class="line">    aaaaaaa</span><br><span class="line">    &lt;button @click.stop=<span class="string">&quot;btnClick&quot;</span>&gt;按钮&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"> </span><br><span class="line">  &lt;!--<span class="number">2.</span> .prevent修饰符的使用 阻止默认行为--&gt;</span><br><span class="line">  &lt;br&gt;</span><br><span class="line">  &lt;form action=<span class="string">&quot;baidu&quot;</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;提交&quot;</span> @click.prevent=<span class="string">&quot;submitClick&quot;</span>&gt;</span><br><span class="line">  &lt;/form&gt;</span><br><span class="line"> </span><br><span class="line">  &lt;!--<span class="number">3.</span> .监听某个键盘的键帽--&gt;</span><br><span class="line">  &lt;input type=<span class="string">&quot;text&quot;</span> @keyup.enter=<span class="string">&quot;keyUp&quot;</span>&gt;</span><br><span class="line"> </span><br><span class="line">  &lt;!--<span class="number">4.</span> .once修饰符的使用 点击回调只会触发一次--&gt;</span><br><span class="line">  &lt;button @click.once=<span class="string">&quot;btn2Click&quot;</span>&gt;按钮<span class="number">2</span>&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h3 id="v-if-、v-else-if和v-else-的使用"><a href="#v-if-、v-else-if和v-else-的使用" class="headerlink" title="v-if 、v-else-if和v-else 的使用"></a>v-if 、v-else-if和v-else 的使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;h2 v-if=&quot;score&gt;=90&quot;&gt;优秀&lt;/h2&gt;</span><br><span class="line">&lt;h2 v-else-if=&quot;score&gt;=80&quot;&gt;良好&lt;/h2&gt;</span><br><span class="line">&lt;h2 v-else-if=&quot;score&gt;=60&quot;&gt;及格&lt;/h2&gt;</span><br><span class="line">&lt;h2 v-else&gt;不及格&lt;/h2&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="复用元素"><a href="#复用元素" class="headerlink" title="复用元素"></a>复用元素</h3><ul><li>如果我们不希望Vue出现类似重复利用的问题，可以给对应的input添加key</li><li>并且我们需要保证key的不同</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;span v-<span class="keyword">if</span>=<span class="string">&quot;isUser&quot;</span>&gt;</span><br><span class="line">   &lt;label for=&quot;username&quot;&gt;用户账号&lt;/label&gt;</span><br><span class="line">   &lt;input type=<span class="string">&quot;text&quot;</span> id=<span class="string">&quot;username&quot;</span> placeholder=<span class="string">&quot;用户账号&quot;</span> key=<span class="string">&quot;username&quot;</span>&gt;</span><br><span class="line"> &lt;/span&gt;</span><br><span class="line"> &lt;span v-<span class="keyword">else</span>&gt;</span><br><span class="line">   &lt;label for=&quot;email&quot;&gt;用户邮箱&lt;/label&gt;</span><br><span class="line">   &lt;input type=<span class="string">&quot;text&quot;</span> id=<span class="string">&quot;email&quot;</span> placeholder=<span class="string">&quot;用户邮箱&quot;</span> key=<span class="string">&quot;email&quot;</span>&gt;</span><br><span class="line"> &lt;/span&gt;</span><br><span class="line"> &lt;button @click=&quot;isUser = !isUser&quot;&gt;切换类型&lt;/button&gt;</span><br></pre></td></tr></table></figure><h3 id="v-show和v-if"><a href="#v-show和v-if" class="headerlink" title="v-show和v-if"></a>v-show和v-if</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;!--v-<span class="keyword">if</span>: 当条件为<span class="keyword">false</span>时, 包含v-<span class="keyword">if</span>指令的元素, 根本就不会存在dom中--&gt;</span><br><span class="line">&lt;h2 v-if=&quot;isShow&quot; id=&quot;aaa&quot;&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;</span><br><span class="line"> </span><br><span class="line">&lt;!--v-show: 当条件为<span class="keyword">false</span>时, v-show只是给我们的元素添加一个行内样式: display: none--&gt;</span><br><span class="line">&lt;h2 v-show=&quot;isShow&quot; id=&quot;bbb&quot;&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//value 是对象的值 key作为唯一标识 index是索引</span></span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li v-for=&quot;(value, key, index) in info&quot;&gt;&#123;&#123;value&#125;&#125;-&#123;&#123;key&#125;&#125;-&#123;&#123;index&#125;&#125;&lt;/li&gt;</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220511222541718.png" alt="image-20220511222541718"></p><ul><li>当某一层有很多相同的节点时，也就是列表节点时，我们希望插入一个新的节点<ul><li>我们希望可以在B和C之间加一个F，Diff算法默认执行起来是这样的。</li><li>即把C更新成F，D更新成C，E更新成D，最后再插入E，是不是很没有效率？</li></ul></li><li>所以我们需要使用key来给每个节点做一个唯一标识<ul><li>Diff算法就可以正确的识别此节点</li><li>找到正确的位置区插入新的节点。</li></ul></li><li>所以一句话，key的作用主要是为了高效的更新虚拟DOM。</li></ul><h2 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 1.push方法 </span></span><br><span class="line">   <span class="keyword">this</span>.letters.push(<span class="string">&#x27;aaa&#x27;</span>)</span><br><span class="line">   <span class="keyword">this</span>.letters.push(<span class="string">&#x27;aaaa&#x27;</span>, <span class="string">&#x27;bbbb&#x27;</span>, <span class="string">&#x27;cccc&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 2.pop(): 删除数组中的最后一个元素</span></span><br><span class="line">   <span class="keyword">this</span>.letters.pop();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 3.shift(): 删除数组中的第一个元素</span></span><br><span class="line">    <span class="keyword">this</span>.letters.shift();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 4.unshift(): 在数组最前面添加元素</span></span><br><span class="line">    <span class="keyword">this</span>.letters.unshift()</span><br><span class="line">    <span class="keyword">this</span>.letters.unshift(<span class="string">&#x27;aaa&#x27;</span>, <span class="string">&#x27;bbb&#x27;</span>, <span class="string">&#x27;ccc&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 5.splice作用: 删除元素/插入元素/替换元素</span></span><br><span class="line">          <span class="comment">// 删除元素: 第二个参数传入你要删除几个元素(如果没有传,就删除后面所有的元素)</span></span><br><span class="line">          <span class="comment">// 替换元素: 第二个参数, 表示我们要替换几个元素, 后面是用于替换前面的元素</span></span><br><span class="line">          <span class="comment">// 插入元素: 第二个参数, 传入0, 并且后面跟上要插入的元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.letters.splice(<span class="number">1</span>, <span class="number">3</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line"><span class="comment">// 排序</span></span><br><span class="line">    <span class="keyword">this</span>.letters.sort()</span><br><span class="line"><span class="comment">// 翻转</span></span><br><span class="line">    <span class="keyword">this</span>.letters.reverse()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果对数组内部进行修改，是不能做到双向绑定的</span></span><br><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="keyword">this</span>.letters.splice(<span class="number">0</span>, <span class="number">1</span>, <span class="string">&#x27;bbbbbb&#x27;</span>) </span><br><span class="line"><span class="comment">// 方法二        </span></span><br><span class="line">Vue.set(<span class="keyword">this</span>.letters, <span class="number">0</span>, <span class="string">&#x27;bbbbbb&#x27;</span>)     </span><br></pre></td></tr></table></figure><h2 id="过滤器filter"><a href="#过滤器filter" class="headerlink" title="过滤器filter"></a>过滤器filter</h2><ul><li><strong>过滤器可以用在两个地方：双花括号插值 或 v-bind表达式。</strong></li><li><strong><em>模板中文本后边需要添加管道符号（ | ）作为分隔，管道符 | 后边是文本的处理函数，处理函数的第一个参数是：管道符前边的——文本内容，如果处理函数上边传递参数，则从第二个参数依次往后是传递的参数。</em></strong></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//局部filter</span></span><br><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">    &lt;p&gt;电脑价格：&#123;&#123;price | addPriceIcon&#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line"> let vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">&quot;#app&quot;</span>,</span><br><span class="line">    data:&#123;</span><br><span class="line">        price:<span class="number">200</span></span><br><span class="line">    &#125;,</span><br><span class="line">    filters:&#123;</span><br><span class="line">        <span class="comment">//处理函数</span></span><br><span class="line">        addPriceIcon(value)&#123;</span><br><span class="line">            console.log(value)<span class="comment">//200</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;¥&#x27;</span> + value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">// 全局过滤器</span></span><br><span class="line"> &lt;h3&gt;&#123;&#123;viewContent | addNamePrefix&#125;&#125;&lt;/h3&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    Vue.filter(<span class="string">&quot;addNamePrefix&quot;</span>,(value)=&gt;&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;my name is&quot;</span> + value</span><br><span class="line">    &#125;)</span><br><span class="line"> </span><br><span class="line">    let vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">        el:<span class="string">&quot;#app&quot;</span>,</span><br><span class="line">        data:&#123;</span><br><span class="line">            viewContent:<span class="string">&quot;吕星辰&quot;</span> </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>全局过滤器</p><ul><li><strong>参数一：是过滤器的名字，也就是管道符后边的处理函数；</strong></li><li><strong>参数二：处理函数，处理函数的参数同上</strong></li></ul><p>实际开发是要放到js文件上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//filter.js 文件</span></span><br><span class="line">let filter_price = function (val,...params)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;¥&quot;</span> + val</span><br><span class="line">&#125;</span><br><span class="line">let filter_date = function ()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;2019/10/20&quot;</span> + val</span><br><span class="line">&#125;</span><br><span class="line">export &#123;filter_price,filter_date&#125; <span class="comment">//导出过滤函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//main.js</span></span><br><span class="line"><span class="comment">//下边是2种导入方式，推荐第一种</span></span><br><span class="line"><span class="keyword">import</span> * as _filter from <span class="string">&#x27;./filters/filter&#x27;</span></span><br><span class="line"><span class="comment">// import &#123;filter_price,filter_date&#125; from &#x27;./filters/filter&#x27;</span></span><br><span class="line"> </span><br><span class="line">console.log(_filter)</span><br><span class="line">    </span><br><span class="line"><span class="comment">//使用Object.keys（）方法，得到一个由key组成的数组，遍历数据，让key作为全局过滤器的名字，后边的是key对应的处理函数，这样在任何一个组件中都可以使用全局过滤器了</span></span><br><span class="line">Object.keys(_filter).forEach(item=&gt;&#123;</span><br><span class="line">  Vue.filter(item,_filter[item])</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  router,store,</span><br><span class="line">  render: h =&gt; h(App),</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span></span><br></pre></td></tr></table></figure><p>通过全局过滤器讲一个别的小知识点：当我们引用vue框架时，vue会被自动添加到window全局对象上边，而Vue正是一个构造函数，里边定义的是一些静态方法和静态属性，我们知道在ES6类中有静态方法，只有类可以调用！这样也就不难理解了，filter全局过滤器可以被Vue所调用，因为它是一个静态方法</p><h2 id="js高阶函数"><a href="#js高阶函数" class="headerlink" title="js高阶函数"></a>js高阶函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编程范式: 命令式编程/声明式编程</span></span><br><span class="line"><span class="comment">// 编程范式: 面向对象编程(第一公民:对象)/函数式编程(第一公民:函数)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="comment">// filter中的回调函数有一个要求: 必须返回一个boolean值</span></span><br><span class="line"><span class="comment">// true: 当返回true时, 函数内部会自动将这次回调的n加入到新的数组中</span></span><br><span class="line"><span class="comment">// false: 当返回false时, 函数内部会过滤掉这次的n</span></span><br><span class="line"><span class="keyword">const</span> nums = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">111</span>, <span class="number">222</span>, <span class="number">444</span>, <span class="number">40</span>, <span class="number">50</span>]</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 高阶函数 本身参数也是一个函数</span></span><br><span class="line"><span class="comment">// let total = nums.filter(n =&gt; n &lt; 100).map(n =&gt; n * 2).reduce((pre, n) =&gt; pre + n);</span></span><br><span class="line"><span class="comment">// console.log(total);</span></span><br><span class="line">let total = nums.filter(function (n) &#123;</span><br><span class="line">  <span class="keyword">return</span> n &lt; <span class="number">100</span></span><br><span class="line">&#125;).map(function (n) &#123;</span><br><span class="line">  <span class="keyword">return</span> n * <span class="number">2</span></span><br><span class="line">&#125;).reduce(function (prevValue, n) &#123;</span><br><span class="line">  <span class="keyword">return</span> prevValue + n</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line">console.log(total);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.filter函数的使用</span></span><br><span class="line"><span class="comment">// 10, 20, 40, 50</span></span><br><span class="line">let newNums = nums.filter(function (n) &#123;</span><br><span class="line">  <span class="keyword">return</span> n &lt; <span class="number">100</span></span><br><span class="line">&#125;)</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 2.map函数的使用</span></span><br><span class="line"><span class="comment">// 20, 40, 80, 100</span></span><br><span class="line">let new2Nums = newNums.map(function (n) &#123; <span class="comment">// 20</span></span><br><span class="line">  <span class="keyword">return</span> n * <span class="number">2</span></span><br><span class="line">&#125;)</span><br><span class="line">console.log(new2Nums);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.reduce函数的使用</span></span><br><span class="line"><span class="comment">// reduce 作用对数组中所有的内容进行汇总</span></span><br><span class="line">let total = new2Nums.reduce(function (preValue, n) &#123;</span><br><span class="line">  <span class="keyword">return</span> preValue + n</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line">console.log(total);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 第一次: preValue 0 n 20</span></span><br><span class="line"><span class="comment">// 第二次: preValue 20 n 40</span></span><br><span class="line"><span class="comment">// 第二次: preValue 60 n 80</span></span><br><span class="line"><span class="comment">// 第二次: preValue 140 n 100</span></span><br><span class="line"><span class="comment">// 240</span></span><br><span class="line"><span class="comment">// preValue是 预备值</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="表单绑定v-model"><a href="#表单绑定v-model" class="headerlink" title="表单绑定v-model"></a>表单绑定v-model</h2><ul><li>当我们在输入框输入内容时</li><li>因为input中的v-model绑定了message，所以会实时将输入的内容传递给message，message发生改变。</li><li>当message发生改变时，因为上面我们使用Mustache语法，将message的值插入到DOM中，所以DOM会发生响应的改变,实现了双向绑定</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">  &lt;input type=<span class="string">&quot;text&quot;</span> v-model=<span class="string">&quot;message&quot;</span>&gt;</span><br><span class="line">  &#123;&#123;message&#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">      message: <span class="string">&#x27;你好啊&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="v-model原理"><a href="#v-model原理" class="headerlink" title="v-model原理"></a>v-model原理</h3><ul><li>v-model其实是一个语法糖，它的背后本质上是包含两个操作：<ul><li>1.v-bind绑定一个value属性</li><li>2.v-on指令给当前元素绑定input事件</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> &lt;!--<span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;message&quot;</span>&gt;</span>--&gt;</span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- 上面等同于 --&gt;</span></span></span><br><span class="line">&lt;!--&lt;input type=&quot;text&quot; :value=&quot;message&quot; @input=&quot;valueChange&quot;&gt;--&gt;</span><br><span class="line"> </span><br><span class="line">&lt;!-- 也就是 --&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; :value=&quot;message&quot; @input=&quot;message = $event.target.value&quot;&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="v-model结合radio类型使用"><a href="#v-model结合radio类型使用" class="headerlink" title="v-model结合radio类型使用"></a>v-model结合radio类型使用</h3><ul><li><strong>单选按钮radio的value会影响v-model的值</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 需要加相同的name 否则可以多选 --&gt;</span><br><span class="line">&lt;!-- <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">id</span>=<span class="string">&quot;male&quot;</span> <span class="attr">value</span>=<span class="string">&quot;男&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span>&gt;</span>男 --&gt;</span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- 一旦v-moddel绑定的是同一个变量，name可以不用写 --&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line">&lt;input type=&quot;radio&quot; id=&quot;male&quot; value=&quot;男&quot; v-model=&quot;sex&quot;&gt;男</span><br><span class="line">&lt;input type=&quot;radio&quot; id=&quot;female&quot; value=&quot;女&quot; v-model=&quot;sex&quot;&gt;女</span><br><span class="line">    </span><br><span class="line">    const app = new Vue(&#123;</span><br><span class="line">      el: &#x27;#app&#x27;,</span><br><span class="line">      data: &#123;</span><br><span class="line">        message: &#x27;你好啊&#x27;,</span><br><span class="line">        sex: &#x27;女&#x27; // 可以给radio默认值</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><h3 id="v-model结合checkbox类型使用"><a href="#v-model结合checkbox类型使用" class="headerlink" title="v-model结合checkbox类型使用"></a>v-model结合checkbox类型使用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">  &lt;!--<span class="number">1.</span>checkbox单选框 --&gt;</span><br><span class="line">    &lt;!--  v-model即为布尔值<span class="literal">true</span>/<span class="literal">false</span>。此时input的value并不影响v-model的值--&gt;</span><br><span class="line">    &lt;label <span class="keyword">for</span>=<span class="string">&quot;agree&quot;</span>&gt;</span><br><span class="line">      &lt;input type=<span class="string">&quot;checkbox&quot;</span> id=<span class="string">&quot;agree&quot;</span> v-model=<span class="string">&quot;isAgree&quot;</span>&gt;同意协议</span><br><span class="line">    &lt;/label&gt;</span><br><span class="line"></span><br><span class="line"> &lt;!--<span class="number">2.</span>checkbox多选框--&gt;</span><br><span class="line">    &lt;!--  当是多个复选框时，因为可以选中多个，所以对应的data中属性是一个数组。当选中某一个时，就会将input的value添加到数组中。--&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;checkbox&quot;</span> value=<span class="string">&quot;篮球&quot;</span> v-model=<span class="string">&quot;hobbies&quot;</span>&gt;篮球</span><br><span class="line">    &lt;input type=<span class="string">&quot;checkbox&quot;</span> value=<span class="string">&quot;足球&quot;</span> v-model=<span class="string">&quot;hobbies&quot;</span>&gt;足球</span><br><span class="line">    &lt;input type=<span class="string">&quot;checkbox&quot;</span> value=<span class="string">&quot;乒乓球&quot;</span> v-model=<span class="string">&quot;hobbies&quot;</span>&gt;乒乓球</span><br><span class="line">    &lt;input type=<span class="string">&quot;checkbox&quot;</span> value=<span class="string">&quot;羽毛球&quot;</span> v-model=<span class="string">&quot;hobbies&quot;</span>&gt;羽毛球</span><br><span class="line">    &lt;h2&gt;您的爱好是: &#123;&#123;hobbies&#125;&#125;&lt;/h2&gt;</span><br><span class="line"> </span><br><span class="line">     &lt;!-- 值绑定 动态的给value赋值 --&gt;</span><br><span class="line">     &lt;!-- <span class="keyword">for</span> 标签的解释 label中的<span class="keyword">for</span>属性规定了label与哪个表单元素绑定。<span class="keyword">for</span>属性的值和表单元素的id值一样，即可完成该label标签与该表单元素的绑定。 --&gt;   </span><br><span class="line">    &lt;label <span class="keyword">for</span>=<span class="string">&quot;test&quot;</span>&gt;label标签&lt;/label&gt;</span><br><span class="line"></span><br><span class="line">    &lt;label v-<span class="keyword">for</span>=<span class="string">&quot;item in originHobbies&quot;</span> :<span class="keyword">for</span>=<span class="string">&quot;item&quot;</span>&gt;</span><br><span class="line">      &lt;input type=<span class="string">&quot;checkbox&quot;</span> :value=<span class="string">&quot;item&quot;</span> :id=<span class="string">&quot;item&quot;</span> v-model=<span class="string">&quot;hobbies&quot;</span>&gt;&#123;&#123;item&#125;&#125; &lt;/label&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//js</span></span><br><span class="line">   <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">      el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">      data: &#123;</span><br><span class="line">        message: <span class="string">&#x27;你好啊&#x27;</span>,</span><br><span class="line">        isAgree: <span class="literal">false</span>, <span class="comment">// 单选框</span></span><br><span class="line">        hobbies: [], <span class="comment">// 多选框,</span></span><br><span class="line">        originHobbies: [<span class="string">&#x27;篮球&#x27;</span>, <span class="string">&#x27;足球&#x27;</span>, <span class="string">&#x27;乒乓球&#x27;</span>, <span class="string">&#x27;羽毛球&#x27;</span>, <span class="string">&#x27;台球&#x27;</span>, <span class="string">&#x27;高尔夫球&#x27;</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><h3 id="v-model结合select类型使用"><a href="#v-model结合select类型使用" class="headerlink" title="v-model结合select类型使用"></a>v-model结合select类型使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单选   </span></span><br><span class="line">&lt;select name=<span class="string">&quot;abc&quot;</span> v-model=<span class="string">&quot;fruit&quot;</span>&gt;</span><br><span class="line">      &lt;option value=&quot;苹果&quot;&gt;苹果&lt;/option&gt;</span><br><span class="line">      &lt;option value=&quot;香蕉&quot;&gt;香蕉&lt;/option&gt;</span><br><span class="line">      &lt;option value=&quot;榴莲&quot;&gt;榴莲&lt;/option&gt;</span><br><span class="line">      &lt;option value=&quot;葡萄&quot;&gt;葡萄&lt;/option&gt;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">    &lt;h2&gt;您选择的水果是: &#123;&#123;fruit&#125;&#125;&lt;/h2&gt;</span><br><span class="line"></span><br><span class="line">&lt;select name=<span class="string">&quot;abc&quot;</span> v-model=<span class="string">&quot;fruits&quot;</span> multiple&gt;</span><br><span class="line">      &lt;option value=&quot;苹果&quot;&gt;苹果&lt;/option&gt;</span><br><span class="line">      &lt;option value=&quot;香蕉&quot;&gt;香蕉&lt;/option&gt;</span><br><span class="line">      &lt;option value=&quot;榴莲&quot;&gt;榴莲&lt;/option&gt;</span><br><span class="line">      &lt;option value=&quot;葡萄&quot;&gt;葡萄&lt;/option&gt;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">        </span><br><span class="line"> <span class="comment">//js</span></span><br><span class="line"> <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">      el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">      data: &#123;</span><br><span class="line">        message: <span class="string">&#x27;你好啊&#x27;</span>,</span><br><span class="line">        fruit: <span class="string">&#x27;香蕉&#x27;</span>,</span><br><span class="line">        fruits: []</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><h3 id="v-model-修饰符的使用"><a href="#v-model-修饰符的使用" class="headerlink" title="v-model 修饰符的使用"></a>v-model 修饰符的使用</h3><ul><li>lazy修饰符：<ul><li>默认情况下，v-model默认是在input事件中同步输入框的数据的。</li><li>也就是说，一旦有数据发生改变对应的data中的数据就会自动发生改变。</li><li>lazy修饰符可以让数据在失去焦点或者回车时才会更新</li></ul></li><li>number修饰符：<ul><li>默认情况下，在输入框中无论我们输入的是字母还是数字，都会被当做字符串类型进行处理。</li><li>但是如果我们希望处理的是数字类型，那么最好直接将内容当做数字处理。</li><li>number修饰符可以让在输入框中输入的内容自动转成数字类型</li></ul></li><li>trim修饰符：<ul><li>如果输入的内容首尾有很多空格，通常我们希望将其去除</li><li>trim修饰符可以过滤内容左右两边的空格</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--<span class="number">1.</span>修饰符: lazy 让数据在失去焦点或者回车时才会更新--&gt;</span><br><span class="line">  &lt;input type=<span class="string">&quot;text&quot;</span> v-model.lazy=<span class="string">&quot;message&quot;</span>&gt;</span><br><span class="line">  &lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">  &lt;!--<span class="number">2.</span>修饰符: number 让在输入框中输入的内容自动转成数字类型--&gt;</span><br><span class="line">  &lt;input type=<span class="string">&quot;number&quot;</span> v-model.number=<span class="string">&quot;age&quot;</span>&gt;</span><br><span class="line">  &lt;h2&gt;&#123;&#123;age&#125;&#125;-&#123;&#123;<span class="keyword">typeof</span> age&#125;&#125;&lt;/h2&gt;</span><br><span class="line"> </span><br><span class="line">  &lt;!--<span class="number">3.</span>修饰符: trim 过滤内容左右两边的空格--&gt;</span><br><span class="line">  &lt;input type=<span class="string">&quot;text&quot;</span> v-model.trim=<span class="string">&quot;name&quot;</span>&gt;</span><br><span class="line">  &lt;h2&gt;您输入的名字:&#123;&#123;name&#125;&#125;&lt;/h2&gt;</span><br></pre></td></tr></table></figure><h1 id="Vue组件化思想"><a href="#Vue组件化思想" class="headerlink" title="Vue组件化思想"></a>Vue组件化思想</h1><ul><li><p>组件化是Vue.js中的重要思想</p><ul><li>它提供了一种抽象，让我们可以开发出一个个独立可复用的小组件来构造我们的应用。</li><li>任何的应用都会被抽象成一颗组件树。</li></ul></li><li><p>组件的使用分成三个步骤：</p><ul><li>创建组件构造器</li><li>注册组件</li><li>使用组件。</li></ul></li></ul><p>组件注册实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 1.创建组件构造器对象  extend() 没有s</span></span><br><span class="line">    <span class="keyword">const</span> cpnC = Vue.extend(&#123;</span><br><span class="line">      <span class="comment">// 自定义组件的模板 使用到组件的地方，要显示的HTML代码</span></span><br><span class="line">      <span class="comment">// *最外需要一个div包裹</span></span><br><span class="line">      template: <span class="string">`</span></span><br><span class="line"><span class="string">      &lt;div&gt;</span></span><br><span class="line"><span class="string">        &lt;h2&gt;我是标题&lt;/h2&gt;</span></span><br><span class="line"><span class="string">        &lt;p&gt;我是内容, 哈哈哈哈&lt;/p&gt;</span></span><br><span class="line"><span class="string">        &lt;p&gt;我是内容, 呵呵呵呵&lt;/p&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;`</span></span><br><span class="line">    &#125;)</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 2.注册组件(全局注册) </span></span><br><span class="line">    <span class="comment">// 需要传递两个参数：</span></span><br><span class="line">    <span class="comment">// 1、注册组件的标签名 (必须加引号)</span></span><br><span class="line">    <span class="comment">// 2、组件构造器</span></span><br><span class="line">    Vue.component(<span class="string">&#x27;my-cpn&#x27;</span>, cpnC)</span><br><span class="line">   </span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">&lt;my-cpn&gt;&lt;/my-cpn&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>如果我们<strong>注册的组件是挂载在某个实例中, 那么就是一个局部组件</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">      message: <span class="string">&#x27;你好啊&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">      <span class="comment">// 使用组件时的标签名:组件构造器</span></span><br><span class="line">      <span class="comment">// &#x27;cpn&#x27;: cpnC  局部组件的标签名有无引号都可以</span></span><br><span class="line">      cpn: cpnC</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//区分 这是全局</span></span><br><span class="line">  Vue.component(<span class="string">&#x27;my-cpn&#x27;</span>, cpnC)</span><br></pre></td></tr></table></figure><h2 id="父组件和子组件"><a href="#父组件和子组件" class="headerlink" title="父组件和子组件"></a>父组件和子组件</h2><p> 前面我们看到了组件树：</p><ul><li>组件和组件之间存在层级关系</li><li>而其中一种非常重要的关系就是父子组件的关系</li></ul><p>语法糖组件注册</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;!--<span class="number">1.</span>script标签, 注意:类型必须是text/x-template 然后给它设置一个id --&gt;</span><br><span class="line">&lt;script type=<span class="string">&quot;text/x-template&quot;</span> id=<span class="string">&quot;cpn&quot;</span>&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h2&gt;我是标题&lt;/h2&gt;</span><br><span class="line">    &lt;p&gt;我是内容,哈哈哈&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"> </span><br><span class="line">&lt;!--<span class="number">2.</span>template标签--&gt;</span><br><span class="line">&lt;template id=<span class="string">&quot;cpn&quot;</span>&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h2&gt;我是标题&lt;/h2&gt;</span><br><span class="line">    &lt;p&gt;我是内容,呵呵呵&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1.注册一个全局组件</span></span><br><span class="line">  Vue.component(<span class="string">&#x27;cpn&#x27;</span>, &#123;</span><br><span class="line">    template: <span class="string">&#x27;#cpn&#x27;</span> <span class="comment">// 需要加上选择器</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><h2 id="数据存放"><a href="#数据存放" class="headerlink" title="数据存放"></a>数据存放</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      title: <span class="string">&#x27;abc&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>组件自己的数据存放在哪里呢?<ul><li>组件对象也有一个data属性(也可以有methods等属性，下面我们有用到)</li><li>只是这个data属性必须是一个函数</li><li>而且这个函数返回一个对象，对象内部保存着数据</li></ul></li></ul><h3 id="解释为什么要一个函数呢"><a href="#解释为什么要一个函数呢" class="headerlink" title="解释为什么要一个函数呢"></a>解释为什么要一个函数呢</h3><ul><li>为什么data在组件中必须是一个函数呢?<ul><li>首先，如果不是一个函数，Vue直接就会报错。</li><li>其次，原因是在于Vue让每个组件对象都返回一个新的对象，因为如果是同一个对象的，组件在多次使用后会相互影响。</li></ul></li></ul><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220512144302775.png" alt="image-20220512144302775"></p><h2 id="父子组件的通信"><a href="#父子组件的通信" class="headerlink" title="父子组件的通信"></a>父子组件的通信</h2><ul><li>通过<strong>props</strong>向子组件传递数据（<strong>父传子</strong>） 婆婆</li><li>通过<strong>事件</strong>向父组件发送消息（<strong>子传父</strong>）  报告</li></ul><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220512144400430.png" alt="image-20220512144400430"></p><h3 id="props基本用法"><a href="#props基本用法" class="headerlink" title="props基本用法"></a>props基本用法</h3><ul><li><strong>在组件中，使用选项props来声明需要从父级接收到的数据</strong>。</li><li>props的值有两种方式：<ul><li>方式一：<strong>字符串数组</strong>，数组中的字符串就是传递时的名称。</li><li>方式二：<strong>对象</strong>，对象可以设置传递时的类型，也可以设置默认值等。</li></ul></li></ul><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220512144547640.png" alt="image-20220512144547640"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- </span><br><span class="line">  步骤：</span><br><span class="line">  <span class="number">1.</span>在子组件里写props</span><br><span class="line">  <span class="number">2.</span>在子组件的标签加上v-bind  </span><br><span class="line">   &lt;cpn v-bind:props里定义的名称=<span class="string">&quot;父组件data数据名称&quot;</span>&gt;&lt;/cpn&gt;</span><br><span class="line">  <span class="number">3.</span>将props中的值显示在子组件中</span><br><span class="line"> --&gt;</span><br></pre></td></tr></table></figure><h3 id="props数据验证—对象写法"><a href="#props数据验证—对象写法" class="headerlink" title="props数据验证—对象写法"></a>props数据验证—对象写法</h3><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220512144814501.png" alt="image-20220512144814501"></p><p><strong>这里要注意</strong></p><ul><li> 提供一些默认值, 以及必传值</li><li> 类型是对象或者数组时, 默认值必须是一个工厂函数</li></ul><h3 id="props中的驼峰标识"><a href="#props中的驼峰标识" class="headerlink" title="props中的驼峰标识"></a>props中的驼峰标识</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">    &lt;!-- v-bind 不支持驼峰 需要换成 -  --&gt;</span><br><span class="line">    &lt;cpn :c-info=<span class="string">&quot;info&quot;</span> :child-my-message=<span class="string">&quot;message&quot;</span> v-bind:<span class="class"><span class="keyword">class</span>&gt;&lt;/<span class="title">cpn</span>&gt;</span></span><br><span class="line"><span class="class">  &lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="class"> </span></span><br><span class="line"><span class="class">  &lt;<span class="title">template</span> <span class="title">id</span></span>=<span class="string">&quot;cpn&quot;</span>&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h2&gt;&#123;&#123;cInfo&#125;&#125;&lt;/h2&gt;</span><br><span class="line">      &lt;h2&gt;&#123;&#123;childMyMessage&#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line"> </span><br><span class="line">  &lt;script src=<span class="string">&quot;../js/vue.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    <span class="keyword">const</span> cpn = &#123;</span><br><span class="line">      template: <span class="string">&#x27;#cpn&#x27;</span>,</span><br><span class="line">      props: &#123;</span><br><span class="line">        <span class="comment">// 在这里使用驼峰 :c-info=&quot;info&quot; 那里要用 -</span></span><br><span class="line">        cInfo: &#123;</span><br><span class="line">          type: <span class="built_in">Object</span>,</span><br><span class="line">          <span class="keyword">default</span> () &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        childMyMessage: &#123;</span><br><span class="line">          type: <span class="built_in">String</span>,</span><br><span class="line">          <span class="keyword">default</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">      el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">      data: &#123;</span><br><span class="line">        info: &#123;</span><br><span class="line">          name: <span class="string">&#x27;why&#x27;</span>,</span><br><span class="line">          age: <span class="number">18</span>,</span><br><span class="line">          height: <span class="number">1.88</span></span><br><span class="line">        &#125;,</span><br><span class="line">        message: <span class="string">&#x27;aaaaaa&#x27;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      components: &#123;</span><br><span class="line">        cpn</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="子级向父级传递—自定义事件-emit"><a href="#子级向父级传递—自定义事件-emit" class="headerlink" title="子级向父级传递—自定义事件 $emit()"></a>子级向父级传递—自定义事件 $emit()</h3><ul><li><p>子组件往父组件传递数据或者事件 </p></li><li><p>自定义事件的流程：</p><ul><li>在子组件中，通过$emit()来触发事件。</li><li>在父组件中，通过v-on来监听子组件事件。v-on的语法糖是@</li></ul></li></ul><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220512145433045.png" alt="image-20220512145433045"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发射事件: 自定义事件</span></span><br><span class="line"><span class="comment">// 2.在子组件中，通过$emit()来触发事件</span></span><br><span class="line"><span class="built_in">this</span>.$emit(<span class="string">&#x27;item-click&#x27;</span>, item)</span><br><span class="line"><span class="comment">// 注意！！！！这里的$emit事件名不要写成驼峰！！！脚手架里可以，会先编译成一个组件对象render函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//子组件调用自定义函数的时候，父组件就会监听并触发传过来的形参方法</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure><h3 id="父传子–结合双向绑定案例-数据访问"><a href="#父传子–结合双向绑定案例-数据访问" class="headerlink" title="父传子–结合双向绑定案例 数据访问"></a>父传子–结合双向绑定案例 数据访问</h3><ul><li>需求</li><li>子组件input绑定v-model，input改变,props里的number1、number2跟着改变，vue实例data里的num1,num2也跟着变</li><li>子组件data的dnumber1一改变，dnumber2就 *100, dnumber2一改变,dumber/100</li></ul><ul><li>分析</li><li>之前的v-model是绑定vue实例data里面的数据</li><li><strong>如果v-model绑定了props里的值，会报错（props里的值最好是通过父组件修改）</strong></li><li>v-model不要绑定props里的值用data或computed代替把number1,number2分别赋值给data的dnumber1,dnumber2</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 父组件 --&gt;</span><br><span class="line">  &lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">    &lt;h3&gt;父组件&lt;/h3&gt;</span><br><span class="line">    &lt;h3&gt;-----num1----&lt;/h3&gt;</span><br><span class="line">    &lt;h3&gt;&#123;&#123;num1&#125;&#125;&lt;/h3&gt;</span><br><span class="line">    &lt;h3&gt; -----num2----&lt;/h3&gt;</span><br><span class="line"> </span><br><span class="line">    &lt;h3&gt;&#123;&#123;num2&#125;&#125;&lt;/h3&gt;</span><br><span class="line">    &lt;hr&gt;</span><br><span class="line">    &lt;cpn :number1=<span class="string">&quot;num1&quot;</span> :number2=<span class="string">&quot;num2&quot;</span> @num1change=<span class="string">&quot;num1change&quot;</span> @num2change=<span class="string">&quot;num2change&quot;</span> /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"> </span><br><span class="line">  &lt;!-- 子组件 --&gt;</span><br><span class="line">  &lt;template id=<span class="string">&quot;cpn&quot;</span>&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;!-- 这样写会报错 应该是由父组件修改它，避免直接修改props的值 --&gt;</span><br><span class="line">      &lt;!--  <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;number1&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> /&gt;</span></span> --&gt;</span><br><span class="line">      &lt;!--  <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;number2&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> /&gt;</span></span> --&gt;</span><br><span class="line">     </span><br><span class="line"> </span><br><span class="line">      &lt;h3&gt;子组件&lt;/h3&gt;</span><br><span class="line"> </span><br><span class="line">      &lt;h3&gt; -----number1----&lt;/h3&gt;</span><br><span class="line">      &lt;!-- 为什么props也会跟着一起变? -&gt; number1绑定的是父组件num1 --&gt;</span><br><span class="line">      &lt;h2&gt;props:&#123;&#123;number1&#125;&#125;&lt;/h2&gt;</span><br><span class="line">      &lt;h2&gt;data:&#123;&#123;dnumber1&#125;&#125;&lt;/h2&gt;</span><br><span class="line"> </span><br><span class="line">      &lt;!--<span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;dnumber1&quot;</span>&gt;</span>--&gt;</span></span><br><span class="line"><span class="xml">      <span class="comment">&lt;!-- v-model的本质 用@input来传值 --&gt;</span></span></span><br><span class="line">      &lt;input type=&quot;text&quot; :value=&quot;dnumber1&quot; @input=&quot;num1Input&quot;&gt;</span><br><span class="line"> </span><br><span class="line">      &lt;h3&gt;-----number2----&lt;/h3&gt;</span><br><span class="line"> </span><br><span class="line">      &lt;h2&gt;props:&#123;&#123;number2&#125;&#125;&lt;/h2&gt;</span><br><span class="line">      &lt;h2&gt;data:&#123;&#123;dnumber2&#125;&#125;&lt;/h2&gt;</span><br><span class="line">      &lt;!--&lt;input type=&quot;text&quot; v-model=&quot;dnumber2&quot;&gt;--&gt;</span><br><span class="line">      &lt;input type=&quot;text&quot; :value=&quot;dnumber2&quot; @input=&quot;num2Input&quot;&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line"> </span><br><span class="line">  &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    // 子组件</span><br><span class="line">    const cpn = &#123;</span><br><span class="line">      template: &#x27;#cpn&#x27;,</span><br><span class="line">      props: &#123;</span><br><span class="line">        number1: Number,</span><br><span class="line">        number2: Number</span><br><span class="line">      &#125;,</span><br><span class="line">      data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">          dnumber1: this.number1,</span><br><span class="line">          dnumber2: this.number2</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      //方法一 用methods</span><br><span class="line">      methods: &#123;</span><br><span class="line">        num1Input(event) &#123;</span><br><span class="line">   //event代表事件的状态，例如触发event对象的元素、鼠标的位置及状态、按下的键等等。</span><br><span class="line">   // 1.将input中的value赋值到dnumber中</span><br><span class="line">          this.dnumber1 = event.target.value;</span><br><span class="line"> </span><br><span class="line">          // 2.为了让父组件可以修改值, 发出一个事件</span><br><span class="line">          this.$emit(&#x27;num1change&#x27;, this.dnumber1)</span><br><span class="line"> </span><br><span class="line">          // 3.同时修饰dnumber2的值</span><br><span class="line">          this.dnumber2 = this.dnumber1 * 100;</span><br><span class="line">          this.$emit(&#x27;num2change&#x27;, this.dnumber2);</span><br><span class="line">        &#125;,</span><br><span class="line">        num2Input(event) &#123;</span><br><span class="line">          this.dnumber2 = event.target.value;</span><br><span class="line">          this.$emit(&#x27;num2change&#x27;, this.dnumber2)</span><br><span class="line"> </span><br><span class="line">          // 同时修饰dnumber1的值</span><br><span class="line">          this.dnumber1 = this.dnumber2 / 100;</span><br><span class="line">          this.$emit(&#x27;num1change&#x27;, this.dnumber1);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      //方法2 用watch实现 监听数值 </span><br><span class="line">      watch: &#123;</span><br><span class="line">          dnumber1(newValue) &#123;</span><br><span class="line">            this.dnumber2 = newValue * 100;</span><br><span class="line">            this.$emit(&#x27;num1change&#x27;, newValue);</span><br><span class="line">          &#125;,</span><br><span class="line">          dnumber2(newValue) &#123;</span><br><span class="line">            this.number1 = newValue / 100;</span><br><span class="line">            this.$emit(&#x27;num2change&#x27;, newValue);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    // 父组件</span><br><span class="line">    const app = new Vue(&#123;</span><br><span class="line">      el: &#x27;#app&#x27;,</span><br><span class="line">      data: &#123;</span><br><span class="line">        num1: 1,</span><br><span class="line">        num2: 0</span><br><span class="line">      &#125;,</span><br><span class="line">      methods: &#123;</span><br><span class="line">        num1change(value) &#123;</span><br><span class="line">          // value传过来的是string类型,需要转换成数字</span><br><span class="line">          this.num1 = parseFloat(value)</span><br><span class="line">        &#125;,</span><br><span class="line">        num2change(value) &#123;</span><br><span class="line">          this.num2 = parseFloat(value)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      components: &#123;</span><br><span class="line">        cpn</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h3 id="watch选项"><a href="#watch选项" class="headerlink" title="watch选项"></a>watch选项</h3><p> watch选项能够监听值的变化。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- watch选项能够监听值的变化 --&gt;</span><br><span class="line">    &lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">        &lt;input type=<span class="string">&quot;text&quot;</span> v-model=<span class="string">&quot;number&quot;</span>&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;script src=<span class="string">&#x27;../js/vue.js&#x27;</span>&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">            el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">            data: &#123;</span><br><span class="line">                number: <span class="number">1</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            watch: &#123;</span><br><span class="line">                <span class="comment">// 监听number变量，当它有变化执行</span></span><br><span class="line">                <span class="comment">/* number(newValue, oldValue) &#123; // newValue新值，oldValue旧值 参数只写newValue也可以</span></span><br><span class="line"><span class="comment">                    console.log(&#x27;newVal&#x27;, newValue);</span></span><br><span class="line"><span class="comment">                    console.log(&#x27;oldVal&#x27;, oldValue);</span></span><br><span class="line"><span class="comment">                &#125; */</span></span><br><span class="line">                <span class="comment">// 也可以这样写</span></span><br><span class="line">                number: &#123;</span><br><span class="line">                    <span class="function"><span class="title">handler</span>(<span class="params">newValue, oldValue</span>)</span> &#123; <span class="comment">//handler方法就是你watch中需要具体执行的方法</span></span><br><span class="line">                        <span class="built_in">console</span>.log(<span class="string">&#x27;newVal&#x27;</span>, newValue);</span><br><span class="line">                        <span class="built_in">console</span>.log(<span class="string">&#x27;oldVal&#x27;</span>, oldValue);</span><br><span class="line">                    &#125;,</span><br><span class="line">                    immediate: <span class="literal">true</span></span><br><span class="line">                    <span class="comment">//immediate为true时则立即触发回调函数；如果为false，则和上面的例子一样，不会立即执行回调。</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h3 id="父子组件的访问"><a href="#父子组件的访问" class="headerlink" title="父子组件的访问"></a>父子组件的访问</h3><ul><li><strong>父</strong>组件访问<strong>子</strong>组件：使用**$children或$refs**</li><li><strong>子</strong>组件访问<strong>父</strong>组件：使用**$parent**</li></ul><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220512151605000.png" alt="image-20220512151605000"></p><h3 id="父子组件的访问方式：-refs（父访问子）"><a href="#父子组件的访问方式：-refs（父访问子）" class="headerlink" title="父子组件的访问方式： $refs（父访问子）"></a>父子组件的访问方式： $refs（父访问子）</h3><ul><li><p>children的缺陷:</p></li><li><p>通过$children访问子组件时，是一个<strong>数组类型</strong>，访问其中的子组件必须通过索引值。</p></li><li><p>但是当子组件过多，我们需要拿到其中一个时，往往不能确定它的索引值，甚至还可能会发生变化。</p></li><li><p>有时候，我们想明确获取其中一个特定的组件，这个时候就可以使用$refs</p></li><li><p>$refs的使用：</p><ul><li>$refs和ref指令通常是一起使用的。</li><li>首先，我们通过ref给某一个子组件绑定一个特定的ID。</li><li>其次，通过this.$refs.ID就可以访问到该组件了。</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在引用子组件的时候加入ref的特定id</span></span><br><span class="line">&lt;cpn ref=<span class="string">&quot;aaa&quot;</span>&gt;&lt;/cpn&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.$children得到数组,并进行调用方法</span></span><br><span class="line"><span class="built_in">this</span>.$children[<span class="number">0</span>].showMessage();</span><br><span class="line"></span><br><span class="line"><span class="comment">//父组件调用时用this.$refs.ID</span></span><br><span class="line"><span class="comment">// 2.$refs reference(引用)  =&gt; 对象类型, 默认是一个空的对象 ref=&#x27;bbb&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.$refs.aaa.name);</span><br></pre></td></tr></table></figure><h3 id="父子组件的访问方式：-parent-子访问父-、-root-根组件"><a href="#父子组件的访问方式：-parent-子访问父-、-root-根组件" class="headerlink" title="父子组件的访问方式： $parent(子访问父)、$root(根组件)"></a>父子组件的访问方式： $parent(子访问父)、$root(根组件)</h3><ul><li>如果我们想在子组件中直接访问父组件，可以通过$parent  <strong>但不建议使用</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子组件调用</span></span><br><span class="line">  <span class="function"><span class="title">btnClick</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">     <span class="comment">// 1.访问父组件$parent 里面的数据变量</span></span><br><span class="line">     <span class="comment">// console.log(this.$parent);</span></span><br><span class="line">     <span class="comment">// console.log(this.$parent.name);</span></span><br><span class="line"> </span><br><span class="line">     <span class="comment">// 2.访问根组件$root</span></span><br><span class="line">     <span class="built_in">console</span>.log(<span class="built_in">this</span>.$root);</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="built_in">this</span>.$root.message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h1><p>组件的插槽：</p><ul><li>组件的插槽也是为了让我们封装的组件更加具有扩展性。</li></ul><h3 id="slot基本使用"><a href="#slot基本使用" class="headerlink" title="slot基本使用"></a>slot基本使用</h3><ul><li><p>当子组件的功能复杂时，子组件的插槽可能并非是一个。</p><ul><li>比如我们封装一个导航栏的子组件，可能就需要三个插槽，分别代表左边、中间、右边。</li><li>那么，外面在给插槽插入内容时，如何区分插入的是哪一个呢？</li><li>这个时候，我们就需要给插槽起一个名字</li></ul><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220512152649747.png" alt="image-20220512152649747"></p></li></ul><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220512152838740.png" alt="image-20220512152838740"></p><h3 id="2-6-版本迭代"><a href="#2-6-版本迭代" class="headerlink" title="2.6+版本迭代"></a>2.6+版本迭代</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">cpn</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--任何没有被包裹在带有 v-slot 的 &lt;template&gt; 中的内容都会被视为默认插槽的内容。或者可以给他起名default--&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--&lt;template v-slot:default&gt;我是内容&lt;/template&gt;--&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- v-slot:center --&gt;</span></span><br><span class="line">        &lt; template v-slot:center &gt;</span><br><span class="line">                <span class="tag">&lt;<span class="name">span</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span>&gt;</span>替换没有名字的插槽<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line"></span><br><span class="line">//语法糖 #。。。</span><br><span class="line"><span class="tag">&lt;<span class="name">cpn</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- 跟 v-on 和 v-bind 一样，v-slot 也有缩写，即把参数之前的所有内容 (v-slot:) 替换为字符 #。例如 v-slot:header 可以被重写为 #header：，前提是必须要有插槽名！！！--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">template</span> #<span class="attr">right</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">span</span>&gt;</span>替换后的右边<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;cpn&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;left&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>左边<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;center&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>中间<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;right&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>右边<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">slot</span>&gt;</span>默认插槽内容<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure><h3 id="编译作用域"><a href="#编译作用域" class="headerlink" title="编译作用域"></a>编译作用域</h3><ul><li><strong>父组件模板的所有东西都会在父级作用域内编译；子组件模板的所有东西都会在子级作用域内编译。</strong></li><li>那么他的作用域就是父组件，使用的属性也是属于父组件的属性。</li><li>因此，isShow使用的是Vue实例中的属性，而不是子组件的属性。</li><li>子归子 父归父</li></ul><h3 id="作用域插槽：使用"><a href="#作用域插槽：使用" class="headerlink" title="作用域插槽：使用"></a>作用域插槽：使用</h3><ul><li>子组件定义的数据传到父组件上，并使用</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cpn</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--  v-slot:slot1=&#x27;props1&#x27; slot1是具名插槽的名字 props1是定义名字接受数据 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:slot1</span>=<span class="string">&#x27;props1&#x27;</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">                &lt;span&gt;</span></span><br><span class="line"><span class="comment">                    &#123;&#123;props1&#125;&#125;</span></span><br><span class="line"><span class="comment">                &lt;/span&gt; --&gt;</span></span><br><span class="line"> </span><br><span class="line">                <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;props1.data1.join(&#x27;-&#x27;)&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h3</span>&gt;</span></span><br><span class="line">                    &#123;&#123;props1.msg&#125;&#125;</span><br><span class="line">                <span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;cpn&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- 可以传多个值 所有的值会包含在一个对象中 在父组件中v-slot=&quot;&quot;中定义名字接收 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">slot</span> <span class="attr">:data1</span>=<span class="string">&#x27;movies&#x27;</span> <span class="attr">:msg</span>=<span class="string">&#x27;message&#x27;</span> <span class="attr">name</span>=<span class="string">&#x27;slot1&#x27;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(item, index) in movies&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span>&gt;</span></span><br><span class="line">                        &#123;&#123;item&#125;&#125;</span><br><span class="line">                    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">slot</span> <span class="attr">:data2</span>=<span class="string">&#x27;name&#x27;</span> <span class="attr">name</span>=<span class="string">&#x27;slot2&#x27;</span>&gt;</span></span><br><span class="line">                &#123;&#123;name&#125;&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">slot</span> <span class="attr">:data3</span>=<span class="string">&#x27;defult&#x27;</span>&gt;</span>默认插槽<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">&lt;!-- 子组件定义的数据 --&gt;</span></span><br><span class="line">        const cpn = &#123;</span><br><span class="line">            template: &#x27;#cpn&#x27;,</span><br><span class="line">            data() &#123;</span><br><span class="line">                return &#123;</span><br><span class="line">                    movies: [&#x27;战狼&#x27;, &#x27;鬼吹灯&#x27;, &#x27;盗墓笔记&#x27;],</span><br><span class="line">                    message: &#x27;你好呀&#x27;,</span><br><span class="line">                    name: &#x27;yangyanyan&#x27;,</span><br><span class="line">                    defult: &#x27;我是默认的数据&#x27;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h1 id="前端模块化"><a href="#前端模块化" class="headerlink" title="前端模块化"></a>前端模块化</h1><h2 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h2><ul><li><p>模块化有两个核心：导出和导入</p></li><li><p>CommonJS的导出：</p></li></ul><p><img src= "/img/loading1.gif" data-lazy-src="https://img-blog.csdnimg.cn/20210720175046818.png" alt="img"></p><ul><li><p>CommonJS的导入</p><p><img src= "/img/loading1.gif" data-lazy-src="https://img-blog.csdnimg.cn/20210720175121523.png" alt="img"></p></li></ul><h2 id="ES6的export指令"><a href="#ES6的export指令" class="headerlink" title="ES6的export指令"></a>ES6的export指令</h2><ul><li>export指令用于导出变量、</li><li>比如下面的代码：</li></ul><p><img src= "/img/loading1.gif" data-lazy-src="https://img-blog.csdnimg.cn/20210720212242467.png" alt="img"></p><ul><li>上面的代码还有另外一种写法：</li></ul><p><img src= "/img/loading1.gif" data-lazy-src="https://img-blog.csdnimg.cn/20210720212302731.png" alt="img"></p><h3 id="导出函数或类"><a href="#导出函数或类" class="headerlink" title="导出函数或类"></a>导出函数或类</h3><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220512155601483.png" alt="image-20220512155601483"></p><h3 id="export-default"><a href="#export-default" class="headerlink" title="export default"></a>export default</h3><ul><li><p>某些情况下，一个模块中包含某个的功能，我们并不希望给这个功能命名，而且让导入者可以自己来命名</p><ul><li>这个时候就可以使用export default </li></ul><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220512155647377.png" alt="image-20220512155647377"></p></li><li><p>我们来到main.js中，这样使用就可以了</p><ul><li>这里的myFunc是我自己命名的，你可以根据需要命名它对应的名字 </li></ul><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220512155722019.png" alt="image-20220512155722019"></p></li><li><p><strong>export default在同一个模块中，不允许同时存在多个</strong>。</p></li></ul><h2 id="ES6的import指令"><a href="#ES6的import指令" class="headerlink" title="ES6的import指令"></a>ES6的import指令</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.导入的&#123;&#125;中定义的变量和函数</span></span><br><span class="line"><span class="keyword">import</span> &#123;flag, sum&#125; <span class="keyword">from</span> <span class="string">&quot;./aaa.js&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (flag) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;小明是天才, 哈哈哈&#x27;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(sum(<span class="number">20</span>, <span class="number">30</span>));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 2.直接导入export定义的变量</span></span><br><span class="line"><span class="keyword">import</span> &#123;num1, height&#125; <span class="keyword">from</span> <span class="string">&quot;./aaa.js&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num1);</span><br><span class="line"><span class="built_in">console</span>.log(height);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 3.导入 export的function/class</span></span><br><span class="line"><span class="keyword">import</span> &#123;mul, Person&#125; <span class="keyword">from</span> <span class="string">&quot;./aaa.js&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(mul(<span class="number">30</span>, <span class="number">50</span>));</span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> Person();</span><br><span class="line">p.run()</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 4.导入 export default中的内容 可以根据需要命名它对应的名字</span></span><br><span class="line"><span class="keyword">import</span> addr <span class="keyword">from</span> <span class="string">&quot;./aaa.js&quot;</span>;</span><br><span class="line"> </span><br><span class="line">addr(<span class="string">&#x27;你好啊&#x27;</span>);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 5.统一全部导入 </span></span><br><span class="line"><span class="comment">// import &#123;flag, num, num1, height, Person, mul, sum&#125; from &quot;./aaa.js&quot;;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 通过*可以导入模块中所有的export变量</span></span><br><span class="line"><span class="comment">// 但是通常情况下我们需要给*起一个别名，方便后续的使用</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> aaa <span class="keyword">from</span> <span class="string">&#x27;./aaa.js&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(aaa.flag);</span><br><span class="line"><span class="built_in">console</span>.log(aaa.height);</span><br></pre></td></tr></table></figure><h1 id="WebPack使用"><a href="#WebPack使用" class="headerlink" title="WebPack使用"></a>WebPack使用</h1><ul><li><p>webpack是一个现代的JavaScript应用的静态<strong>模块打包</strong>工具。</p></li><li><p>我们从两个点来解释上面这句话：模块 和 打包</p></li></ul><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><ul><li>在ES6之前，我们要想进行模块化开发，就必须借助于其他的工具，让我们可以进行模块化开发。</li><li>并且在通过模块化开发完成了项目后，还需要<strong>处理模块间的各种依赖</strong>，并且将其进行<strong>整合打包</strong>。</li><li>而webpack其中一个核心就是让<strong>我们可能进行模块化开发</strong>，并且会帮助我<strong>们处理模块间的依赖关系</strong>。</li><li>而且不仅仅是JavaScript文件，我们的<strong>CSS、图片、json文件等等在webpack中都可以被当做模块来使用</strong>（在后续我们会看到）。</li><li>这就是<strong>webpack中模块化</strong>的概念。 </li></ul><h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><ul><li>理解了webpack可以帮助我们进行模块化，并且处理模块间的各种复杂关系后，打包的概念就非常好理解了。</li><li>就是将webpack中的各种资源模块进行<strong>打包</strong>合并成**一个或多个包(Bundle)**。</li><li>并且在打包的过程中，<strong>还可以对资源进行处理</strong>，比如<strong>压缩图片</strong>，<strong>将scss转成css</strong>，将<strong>ES6语法转成ES5语法</strong>，将TypeScript转成JavaScript等等操作。</li></ul><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><ul><li><p>所以，grunt/gulp和webpack有什么不同呢？</p><ul><li><p>grunt/gulp更加强调的是前端流程的自动化，模块化不是它的核心。</p></li><li><p>webpack更加强调<strong>模块化开发管理</strong>，而文件压缩合并、<strong>预处理等功能</strong>，是他附带的功能。</p></li></ul></li></ul><p><strong>webpack依赖node.js环境</strong></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack@<span class="number">3.6</span><span class="number">.0</span> -g  </span><br></pre></td></tr></table></figure><p>关于npm后面的疑惑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">npm install module_name -S 即 npm install module_name --save 写入dependencies</span><br><span class="line"></span><br><span class="line">npm install module_name -D 即（局部安装） npm install module_name --save-dev 写入devDependencies</span><br><span class="line"></span><br><span class="line">npm install module_name -g 全局安装(命令行使用)</span><br><span class="line"></span><br><span class="line">npm install module_name 本地安装(将安装包放在 ./node_modules 下)</span><br><span class="line"></span><br><span class="line">dependencies与devDependencies有什么区别呢？</span><br><span class="line">devDependencies 里面的插件只用于开发环境，不用于生产环境</span><br><span class="line">dependencies 是需要发布到生产环境的</span><br></pre></td></tr></table></figure><h3 id="局部安装"><a href="#局部安装" class="headerlink" title="局部安装"></a>局部安装</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--save-dev是开发时依赖，项目打包后不需要继续使用的。</span><br><span class="line">npm install webpack@<span class="number">3.6</span><span class="number">.0</span> --save-dev</span><br></pre></td></tr></table></figure><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220512161330080.png" alt="image-20220512161330080"></p><h3 id="js文件的打包"><a href="#js文件的打包" class="headerlink" title="js文件的打包"></a>js文件的打包</h3><ul><li><p>现在的js文件中使用了模块化的方式进行开发，他们可以直接使用吗？</p></li><li><p>不可以。在真实项目中当有许多这样的js文件时，我们一个个引用非常麻烦，并且后期非常不方便对它们进行管理。 </p></li><li><p>使用webpack工具 对多个js文件进行打包</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">打包命令</span><br><span class="line">webpack src/main.js dist/bundle.js</span><br></pre></td></tr></table></figure><h2 id="webpack配置"><a href="#webpack配置" class="headerlink" title="webpack配置"></a>webpack配置</h2></li></ul><h3 id="入口和出口"><a href="#入口和出口" class="headerlink" title="入口和出口"></a>入口和出口</h3><ul><li>webpack的命令都需要写上入口和出口作为参数</li><li>创建一个<strong>webpack.config.js</strong>文件，方便管理</li></ul><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220512161645405.png" alt="image-20220512161645405"></p><ul><li><p>因为output的路径得是绝对路径，需要安装path包</p><ul><li>依赖到node的包，建议先<strong>npm init</strong>初始化一下,会出现下面信息，填package name后一路回车就行，然后会生成<strong>package.json</strong>文件</li></ul></li><li><p>在终端输入 <strong>webpack</strong> 就能直接打包了 ，但是在开发中一般不会用webpack，一般映射为npm run build</p></li></ul><h3 id="package-json中定义启动"><a href="#package-json中定义启动" class="headerlink" title="package.json中定义启动"></a>package.json中定义启动</h3><p> <img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220512162143842.png" alt="image-20220512162143842"></p><p>package.json中的scripts的脚本在执行时，会按照一定的顺序寻找命令对应的位置。</p><ul><li><p>首先，会寻找本地的node_modules/.bin路径中对应的命令。</p></li><li><p>如果没有找到，会去全局的环境变量中寻找。</p></li><li><p>如何执行我们的build指令呢？</p></li><li><p>```coffeescript<br>npm run build</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">## css文件处理---css-loader的使用</span><br><span class="line"></span><br><span class="line">### 什么是loader？</span><br><span class="line"></span><br><span class="line">- loader是webpack中一个非常核心的概念。</span><br><span class="line">- 在我们之前的实例中，我们主要是用webpack来处理我们写的js代码，并且webpack会自动处理js之间相关的依赖。</span><br><span class="line">- 但是，在开发中我们不仅仅有基本的js代码处理，我们也需要加载css、图片，也包括一些高级的将ES6转成ES5代码，将TypeScript转成ES5代码，将scss、less转成css，将.jsx、.vue文件转成js文件等等。</span><br><span class="line">- 这时候需要 loader</span><br><span class="line"></span><br><span class="line">### css文件处理 – css-loader</span><br><span class="line"></span><br><span class="line">- 在webpack的官方中，我们可以找到如下关于样式的loader使用方法： </span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">npm install css-loader --save-dev</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F; 视频所用版本</span><br><span class="line">npm install css-loader@2.0.2 --save-dev</span><br></pre></td></tr></table></figure></li><li><p>但是，运行index.html，你会发现样式并没有生效。</p><ul><li>原因是css-loader只负责加载css文件，但是并不负责将css具体样式嵌入到文档中。</li><li>这个时候，我们还需要一个<strong>style-loader</strong>帮助我们处理。 </li></ul></li></ul><h3 id="css文件处理-–-style-loader"><a href="#css文件处理-–-style-loader" class="headerlink" title="css文件处理 – style-loader"></a>css文件处理 – style-loader</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev style-loader</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 视频所用版本</span></span><br><span class="line">npm install style-loader@<span class="number">0.23</span><span class="number">.1</span> --save-dev</span><br></pre></td></tr></table></figure><p>webpack.config.js的配置如下：</p><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220512162712316.png" alt="image-20220512162712316"></p><ul><li>注意：style-loader需要放在css-loader的前面。</li><li>疑惑：不对吧？按照我们的逻辑，在处理css文件过程中，应该是css-loader先加载css文件，再由style-loader来进行进一步的处理，为什么会将style-loader放在前面呢？</li><li>答案：这次因为webpack在读取使用的loader的过程中，是按照<strong>从右向左</strong>的顺序读取的。</li></ul><p>style-loader和css-loader作用是不同的。 </p><ul><li><code>css-loader</code>: 加载.css文件</li><li><code>style-loader</code>:使用<code>&lt;style&gt;</code>将css-loader内部样式注入到我们的HTML页面</li></ul><h3 id="less文件处理-–-less-loader"><a href="#less文件处理-–-less-loader" class="headerlink" title="less文件处理 – less-loader"></a>less文件处理 – less-loader</h3><p>require(‘./ss.less’) 引入后就会还需要安装less-loader</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev less-loader less</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 视频所用版本</span></span><br><span class="line">npm install --save-dev less-loader@<span class="number">4.1</span><span class="number">.0</span> less@<span class="number">3.9</span><span class="number">.0</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = require(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">module</span>.<span class="keyword">exports</span> = &#123;</span><br><span class="line">    entry: <span class="string">&#x27;./src/main.js&#x27;</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">        filename: <span class="string">&#x27;bundle.js&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">module</span>: &#123;</span><br><span class="line">        rules: [&#123;</span><br><span class="line">                test: /\.css$/,</span><br><span class="line">                use: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>]</span><br><span class="line">            &#125;,</span><br><span class="line">             <span class="comment">//less规则</span></span><br><span class="line">            &#123;</span><br><span class="line">                test: /\.less$/,</span><br><span class="line">                use: [&#123;</span><br><span class="line">                    loader: <span class="string">&quot;style-loader&quot;</span>, <span class="comment">// creates style nodes from JS strings</span></span><br><span class="line">                &#125;, &#123;</span><br><span class="line">                    loader: <span class="string">&quot;css-loader&quot;</span> <span class="comment">// translates CSS into CommonJS</span></span><br><span class="line">                &#125;, &#123;</span><br><span class="line">                    loader: <span class="string">&quot;less-loader&quot;</span>, <span class="comment">// compiles Less to CSS</span></span><br><span class="line">                &#125;]</span><br><span class="line">            &#125;,</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h3 id="图片文件处理-–-url-loader"><a href="#图片文件处理-–-url-loader" class="headerlink" title="图片文件处理 – url-loader"></a>图片文件处理 – url-loader</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev url-loader</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 视频所用版本</span></span><br><span class="line">npm install --save-dev url-loader@<span class="number">1.1</span><span class="number">.2</span></span><br></pre></td></tr></table></figure><ul><li>修改webpack.config.js配置文件：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加规则 </span></span><br><span class="line">&#123;</span><br><span class="line">        test: /\.(png|jpg|gif|jpeg)$/,</span><br><span class="line">        use: [&#123;</span><br><span class="line">          loader: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">              <span class="comment">//limit属性的作用，当图片小于8kb时，对图片进行base64编码</span></span><br><span class="line">            limit: <span class="number">8192</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;]</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h3 id="图片文件处理-–-file-loader"><a href="#图片文件处理-–-file-loader" class="headerlink" title="图片文件处理 – file-loader"></a>图片文件处理 – file-loader</h3><p>大于8kb的图片要用file-loader进行处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev file-loader</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 视频所用版本</span></span><br><span class="line">npm install --save-dev file-loader@<span class="number">3.0</span><span class="number">.1</span></span><br></pre></td></tr></table></figure><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220512163429623.png" alt="image-20220512163429623"></p><ul><li>我们发现webpack自动帮助我们生成一个非常长的名字</li><li>这是一个32位hash值，目的是防止名字重复</li><li>但是，真实开发中，我们可能对打包的图片名字有一定的要求</li><li>比如，将所有的图片放在一个文件夹中，跟上图片原来的名称，同时也要防止重复 </li><li>所以，我们可以在options中添加上如下选项：<br>img：文件要打包到的文件夹<br>name：获取图片原来的名字，放在该位置<br>hash:8：为了防止图片名称冲突，依然使用hash，但是我们只保留8位<br>ext：使用图片原来的扩展名 </li></ul><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220512163514276.png" alt="image-20220512163514276"></p><ul><li><p>但是，我们发现图片并没有显示出来，这是因为图片使用的路径不正确</p><ul><li>默认情况下，webpack会将生成的路径直接返回给使用者</li><li>但是，我们整个程序是打包在dist文件夹下的，所以这里我们需要在路径下再添加一个dist/ </li></ul><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220512163605266.png" alt="image-20220512163605266"></p></li></ul><h3 id="babel的使用（ES6转ES5）"><a href="#babel的使用（ES6转ES5）" class="headerlink" title="babel的使用（ES6转ES5）"></a>babel的使用（ES6转ES5）</h3><ul><li><p>如果你仔细阅读webpack打包的js文件，发现写的ES6语法并没有转成ES5，那么就意味着可能一些对ES6还不支持的浏览器没有办法很好的运行我们的代码。</p></li><li><p>在前面我们说过，如果希望将ES6的语法转成ES5，那么就需要使用babel。</p><ul><li>而在webpack中，我们直接使用babel对应的loader就可以了。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev babel-loader@<span class="number">7</span> babel-core babel-preset-es2015</span><br></pre></td></tr></table></figure><ul><li>配置webpack.config.js文件</li></ul><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220512163704574.png" alt="image-20220512163704574"></p><h3 id="webpack配置vue"><a href="#webpack配置vue" class="headerlink" title="webpack配置vue"></a>webpack配置vue</h3><ul><li>注：因为我们后续是在实际项目中也会使用vue的，所以并不是开发时依赖,不用加-dev</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue --save</span><br></pre></td></tr></table></figure><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220512163912259.png" alt="image-20220512163912259"></p><p><strong>Vue不同版本构建</strong>，后续具体讲解runtime-only和runtime-compiler的区别</p><p>修改webpack.config.js的配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">    extensions: [<span class="string">&#x27;.js&#x27;</span>, <span class="string">&#x27;.css&#x27;</span>, <span class="string">&#x27;.vue&#x27;</span>],</span><br><span class="line">    <span class="comment">// 可以省略扩展名， 比如引入vue文件&#x27;./vue/App.vue&#x27; 可以写成&#x27;./vue/App&#x27;</span></span><br><span class="line">    <span class="comment">// alias: 别名</span></span><br><span class="line">    alias: &#123;</span><br><span class="line">      <span class="string">&#x27;vue$&#x27;</span>: <span class="string">&#x27;vue/dist/vue.esm.js&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br></pre></td></tr></table></figure><h2 id="el和template区别"><a href="#el和template区别" class="headerlink" title="el和template区别"></a>el和template区别</h2><ul><li>那么，el和template模板的关系是什么呢？</li><li>在我们之前的学习中，我们知道el用于指定<strong>Vue要管理的DOM</strong>，可以帮助解析其中的指令、事件监听等等。</li><li>而如果Vue实例中同时指定了template，那么<strong>template模板的内容</strong>会替换掉<strong>挂载的对应el的模板</strong>。 </li><li>这样做有什么好处呢？</li><li>这样做之后我们就不需要在以后的开发中再次操作index.html，只需要在template中写入对应的标签即可</li></ul><h3 id="Vue的终极使用方案–-vue文件封装处理"><a href="#Vue的终极使用方案–-vue文件封装处理" class="headerlink" title="Vue的终极使用方案– .vue文件封装处理"></a>Vue的终极使用方案– .vue文件封装处理</h3><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220512164342940.png" alt="image-20220512164342940"></p><ul><li><p>但是，这个时候这个文件可以被正确的加载吗？</p><ul><li><p>必然不可以，这种特殊的文件以及特殊的格式，必须有人帮助我们处理。</p></li><li><p>谁来处理呢？<strong>vue-loader（加载）</strong>以及<strong>vue-template-compiler（编译）</strong>。 </p></li><li><p>安装vue-loader和vue-template-compiler </p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  npm install vue-loader vue-template-compiler --save-dev</span><br><span class="line"></span><br><span class="line">修改webpack.config.js的配置文件：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">&#123;</span><br><span class="line">        test: /\.vue$/,</span><br><span class="line">        use: [<span class="string">&#x27;vue-loader&#x27;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>会出现报错原因 应该是loader版本原因，在package.json里面修改一下版本号</p></li></ul><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220512164544641.png" alt="image-20220512164544641"></p><h3 id="plugin的使用"><a href="#plugin的使用" class="headerlink" title="plugin的使用"></a>plugin的使用</h3><ul><li><p>loader和plugin区别</p><ul><li>loader主要用于转换某些类型的模块，它是一个转换器。</li><li>plugin是插件，它是对webpack本身的扩展，是一个扩展器。 </li></ul></li><li><p>plugin的使用过程：</p><ul><li>步骤一：通过npm安装需要使用的plugins(某些webpack已经内置的插件不需要安装)</li><li>步骤二：在webpack.config.js中的plugins中配置插件。</li></ul></li></ul><h3 id="添加版权的Plugin"><a href="#添加版权的Plugin" class="headerlink" title="添加版权的Plugin"></a>添加版权的Plugin</h3><ul><li>该插件名字叫BannerPlugin，属于webpack自带的插件。</li></ul><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220512165115606.png" alt="image-20220512165115606"></p><h3 id="js压缩的Plugin"><a href="#js压缩的Plugin" class="headerlink" title="js压缩的Plugin"></a>js压缩的Plugin</h3><ul><li>在项目发布之前，我们必然需要对js等文件进行压缩处理<ul><li>这里，我们就对打包的js文件进行压缩</li><li>我们使用一个第三方的插件uglifyjs-webpack-plugin，并且版本号指定1.1.1，和CLI2保持一致</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install uglifyjs-webpack-plugin@<span class="number">1.1</span><span class="number">.1</span> --save-dev</span><br></pre></td></tr></table></figure><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220512170140248.png" alt="image-20220512170140248"></p><h3 id="webpack配置文件的分离"><a href="#webpack配置文件的分离" class="headerlink" title="webpack配置文件的分离"></a>webpack配置文件的分离</h3><ul><li>webpack根据开发和生成环境一般可以将配置文件拆分，拆分dev和prod两种环境</li><li>我们在根目录下创建build文件夹，并创建三个配置文件，分别是：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">|- /build</span><br><span class="line">    |- base.config.js  公共配置</span><br><span class="line">    |- dev.config.js   开发配置</span><br><span class="line">    |- prod.config.js  生产配置</span><br></pre></td></tr></table></figure><p>细看<a href="https://blog.csdn.net/qq_23073811/article/details/118940864">https://blog.csdn.net/qq_23073811/article/details/118940864</a></p><h2 id="本地服务器"><a href="#本地服务器" class="headerlink" title="本地服务器"></a>本地服务器</h2><ul><li>webpack提供了一个可选的本地开发服务器，这个本地服务器基于node.js搭建，内部使用express框架，可以实现我们想要的让浏览器自动刷新显示我们修改后的结果。</li><li>不过它是一个单独的模块，在webpack中使用之前需要先安装它</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev webpack-dev-server@<span class="number">2.9</span><span class="number">.1</span></span><br></pre></td></tr></table></figure><ul><li> devserver也是作为webpack中的一个选项，选项本身可以设置如下属性</li><li> contentBase：为哪一个文件夹提供本地服务，默认是根文件夹，我们这里要填写./dist<br>port：端口号<br>inline：页面实时刷新<br>historyApiFallback：在SPA页面中，依赖HTML5的history模式</li></ul><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220512171010749.png" alt="image-20220512171010749"></p><h1 id="Vue-Cli"><a href="#Vue-Cli" class="headerlink" title="Vue Cli"></a>Vue Cli</h1><ul><li><p>CLI是Command-Line Interface, 翻译为<strong>命令行界面,</strong> 但是<strong>俗称脚手架.</strong></p></li><li><p><strong>使用 vue-cli 可以快速搭建Vue开发环境以及对应的webpack配置.</strong> </p></li><li><p>什么是NPM呢</p><ul><li>NPM的全称是Node Package Manager</li><li>是一个NodeJS包管理和分发工具，已经成为了非官方的发布Node模块（包）的标准。</li></ul></li></ul><p><strong>cnpm安装</strong></p><ul><li>由于国内直接使用 npm 的官方镜像是非常慢的，这里推荐使用淘宝 NPM 镜像。</li><li>你可以使用淘宝定制的 cnpm (gzip 压缩支持) 命令行工具代替默认的 npm:</li><li>npm install -g cnpm –registry=<a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a></li></ul><p>Cli是基于webpack静态资源打包框架</p><ul><li>安装Vue脚手架</li></ul><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">npm</span> install -g @vue/cli</span><br></pre></td></tr></table></figure><ul><li> Vue CLI2初始化项目</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue <span class="keyword">init</span> webpack my-project</span><br></pre></td></tr></table></figure><ul><li>Vue CLI3初始化项目</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue <span class="keyword">create</span> my<span class="operator">-</span>project</span><br></pre></td></tr></table></figure><h2 id="Vue-CLI2-0构建过程"><a href="#Vue-CLI2-0构建过程" class="headerlink" title="Vue CLI2.0构建过程"></a>Vue CLI2.0构建过程</h2><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220517102327678.png" alt="image-20220517102327678"></p><h3 id="目录结构详解"><a href="#目录结构详解" class="headerlink" title="目录结构详解"></a>目录结构详解</h3><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220517105209635.png" alt="image-20220517105209635"></p><h3 id="Runtime-Compiler和Runtime-only的区别"><a href="#Runtime-Compiler和Runtime-only的区别" class="headerlink" title="Runtime-Compiler和Runtime-only的区别"></a>Runtime-Compiler和Runtime-only的区别</h3><ul><li>简单总结<ul><li>如果在之后的开发中，你依然使用template，就需要选择Runtime-Compiler</li><li>如果你之后的开发中，使用的是.vue文件夹开发，那么可以选择Runtime-only </li></ul></li></ul><h3 id="vue程序运行过程"><a href="#vue程序运行过程" class="headerlink" title="vue程序运行过程"></a>vue程序运行过程</h3><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220517105654321.png" alt="image-20220517105654321"></p><ul><li>总结<ul><li><strong>Runtime-Compiler：</strong><ul><li>template -&gt; ast -&gt; render -&gt; vdom -&gt; 真实DOM</li></ul></li><li><strong>Runtime-only：</strong>(1.性能更高 2.下面的代码量更少)</li><li>render -&gt; vdom -&gt; UI</li></ul></li></ul><h3 id="render函数的使用"><a href="#render函数的使用" class="headerlink" title="render函数的使用"></a>render函数的使用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span></span><br><span class="line"> </span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span> <span class="comment">// 消息提示的环境配置，设置为开发环境或者生产环境</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* eslint-disable no-new */</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">// runtime-compiler</span></span><br><span class="line"><span class="comment">new Vue(&#123;</span></span><br><span class="line"><span class="comment">  el: &#x27;#app&#x27;,</span></span><br><span class="line"><span class="comment">  components: &#123; App &#125;,</span></span><br><span class="line"><span class="comment">  template: &#x27;&lt;App/&gt;&#x27;,</span></span><br><span class="line"><span class="comment">&#125;)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">// const cpn = &#123; // 组件</span></span><br><span class="line"><span class="comment">//   template: &#x27;&lt;div&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt;&#x27;,</span></span><br><span class="line"><span class="comment">//   data() &#123;</span></span><br><span class="line"><span class="comment">//     return &#123;</span></span><br><span class="line"><span class="comment">//       message: &#x27;我是组件message&#x27;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 也可以用下面这个方案 runtime-only</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span> (<span class="params">createElement</span>) </span>&#123; <span class="comment">// createElement是一个函数</span></span><br><span class="line">    <span class="comment">// 1.使用方式一: createElement(&#x27;标签&#x27;, &#123;标签的属性&#125;, [&#x27;内容&#x27;])</span></span><br><span class="line">    <span class="comment">// 1.1 基本使用</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// return createElement(&#x27;h2&#x27;, &#123;</span></span><br><span class="line">    <span class="comment">//   class: &#x27;box&#x27;</span></span><br><span class="line">    <span class="comment">// &#125;,</span></span><br><span class="line">    <span class="comment">// [&#x27;Hello World&#x27;])</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 1.2 嵌套render函数</span></span><br><span class="line">    <span class="comment">// return createElement(&#x27;h2&#x27;, &#123;</span></span><br><span class="line">    <span class="comment">//     class: &#x27;box&#x27;</span></span><br><span class="line">    <span class="comment">//   &#125;,</span></span><br><span class="line">    <span class="comment">//   [&#x27;Hello World&#x27;, createElement(&#x27;button&#x27;, [&#x27;按钮&#x27;])])</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 2.传入组件对象:</span></span><br><span class="line">    <span class="comment">// return createElement(cpn)</span></span><br><span class="line">    <span class="keyword">return</span> createElement(App)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="npm-run-build"><a href="#npm-run-build" class="headerlink" title="npm run build"></a>npm run build</h3><h3 id=""><a href="#" class="headerlink" title=""></a><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220517110245937.png" alt="image-20220517110245937"></h3><h3 id="npm-run-dev"><a href="#npm-run-dev" class="headerlink" title="npm run dev"></a>npm run dev</h3><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220517110307442.png" alt="image-20220517110307442"></p><h3 id="修改配置：webpack-base-conf-js起别名"><a href="#修改配置：webpack-base-conf-js起别名" class="headerlink" title="修改配置：webpack.base.conf.js起别名"></a>修改配置：webpack.base.conf.js起别名</h3><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220517110351224.png" alt="image-20220517110351224"></p><h2 id="Vue-Cli3-0"><a href="#Vue-Cli3-0" class="headerlink" title="Vue Cli3.0"></a>Vue Cli3.0</h2><ul><li>vue-cli 3 与 2 版本有很大区别</li><li>vue-cli 3 是基于 webpack 4 打造，vue-cli 2 还是 webapck 3</li><li>vue-cli 3 的设计原则是“0配置”，移除的配置文件根目录下的，build和config等目录</li><li>vue-cli 3 提供了 vue ui 命令，提供了可视化配置，更加人性化</li><li>移除了static文件夹，新增了public文件夹，并且index.html移动到public中 </li></ul><h3 id="vue-cli3-0-构建过程"><a href="#vue-cli3-0-构建过程" class="headerlink" title="vue cli3.0 构建过程"></a>vue cli3.0 构建过程</h3><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220517110704894.png" alt="image-20220517110704894"></p><h4 id="UI方面的配置"><a href="#UI方面的配置" class="headerlink" title="UI方面的配置"></a>UI方面的配置</h4><ul><li>启动配置服务器：vue ui</li></ul><h4 id="自定义配置：起别名"><a href="#自定义配置：起别名" class="headerlink" title="自定义配置：起别名"></a>自定义配置：起别名</h4><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220517110817209.png" alt="image-20220517110817209"></p><h4 id="箭头函数找this"><a href="#箭头函数找this" class="headerlink" title="箭头函数找this"></a>箭头函数找this</h4><p>往本身最近的上一层来找</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">      <span class="function"><span class="title">aaa</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">// window</span></span><br><span class="line">          &#125;)</span><br><span class="line"> </span><br><span class="line">          <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">// window</span></span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">// window</span></span><br><span class="line">          &#125;)</span><br><span class="line"> </span><br><span class="line">          <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">// obj</span></span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    obj.aaa()</span><br></pre></td></tr></table></figure><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><h3 id="后端路由阶段"><a href="#后端路由阶段" class="headerlink" title="后端路由阶段"></a>后端路由阶段</h3><ul><li>早期的网站开发整个HTML页面是由服务器来渲染的.</li><li>服务器直接生产渲染好对应的HTML页面, 返回给客户端进行展示. </li><li>但是, 一个网站, 这么多页面服务器如何处理呢?</li><li>一个页面有自己对应的网址, 也就是URL.</li><li>URL会发送到服务器, 服务器会通过正则对该URL进行匹配, 并且最后交给一个Controlle进行处理.</li><li>Controller进行各种处理, 最终生成HTML或者数据, 返回给前端.</li><li>这就完成了一个IO操作. </li><li>上面的这种操作, 就是后端路由.</li><li>当我们页面中需要请求不同的路径内容时, 交给服务器来进行处理, 服务器渲染好整个页面, 并且将页面返回给客户顿.</li><li>这种情况下渲染好的页面, 不需要单独加载任何的js和css, 可以直接交给浏览器展示, 这样也有利于SEO的优化. </li></ul><p>后端路由的缺点:</p><ul><li>一种情况是整个页面的模块由后端人员来编写和维护的.</li><li>另一种情况是前端开发人员如果要开发页面, 需要通过PHP和Java等语言来编写页面代码.</li><li>而且通常情况下HTML代码和数据以及对应的逻辑会混在一起, 编写和维护都是非常糟糕的事情.</li></ul><h3 id="前端路由阶段"><a href="#前端路由阶段" class="headerlink" title="前端路由阶段"></a>前端路由阶段</h3><ul><li>前后端分离阶段：</li><li>随着Ajax的出现, 有了前后端分离的开发模式.</li><li>后端只提供API来返回数据, 前端通过Ajax获取数据, 并且可以通过JavaScript将数据渲染到页面中.</li><li>这样做最大的优点就是前后端责任的清晰, 后端专注于数据上, 前端专注于交互和可视化上.</li><li>并且当移动端(iOS/Android)出现后, 后端不需要进行任何处理, 依然使用之前的一套API即可.</li><li>目前很多的网站依然采用这种模式开发. </li></ul><h3 id="单页面富应用阶段"><a href="#单页面富应用阶段" class="headerlink" title="单页面富应用阶段"></a><strong>单页面富应用阶段</strong></h3><ul><li>其实SPA最主要的特点就是在前后端分离的基础上加了一层前端路由.</li></ul><h3 id="前端路由核心"><a href="#前端路由核心" class="headerlink" title="前端路由核心"></a>前端路由核心</h3><ul><li>改变URL，但是页面不进行整体的刷新。</li></ul><h2 id="前端路由的规则"><a href="#前端路由的规则" class="headerlink" title="前端路由的规则"></a>前端路由的规则</h2><h3 id="URL的hash"><a href="#URL的hash" class="headerlink" title="URL的hash"></a>URL的hash</h3><ul><li>URL的hash<ul><li>URL的hash也就是锚点(#), 本质上是改变window.location的href属性.</li><li>我们可以通过直接赋值location.hash来改变href, 但是页面不发生刷新 </li></ul></li></ul><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220517153601809.png" alt="image-20220517153601809"></p><h3 id="HTML5的history模式：pushState"><a href="#HTML5的history模式：pushState" class="headerlink" title="HTML5的history模式：pushState"></a>HTML5的history模式：pushState</h3><ul><li>history接口是HTML5新增的, 它有五种模式改变URL而不刷新页面.</li><li>history.<strong>pushState</strong>() </li></ul><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220517155837195.png" alt="image-20220517155837195"></p><h3 id="HTML5的history模式：replaceState"><a href="#HTML5的history模式：replaceState" class="headerlink" title="HTML5的history模式：replaceState"></a>HTML5的history模式：<strong>replaceState</strong></h3><ul><li> history.<strong>replaceState</strong>()</li></ul><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220517155905486.png" alt="image-20220517155905486"></p><h3 id="HTML5的history模式：go"><a href="#HTML5的history模式：go" class="headerlink" title="HTML5的history模式：go"></a>HTML5的history模式：go</h3><ul><li>history.<strong>go</strong>()</li></ul><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220517155935331.png" alt="image-20220517155935331"></p><ul><li>补充</li><li>因为 history.back() 等价于 history.go(-1)</li><li>history.forward() 则等价于 history.go(1)</li><li>这三个接口等同于浏览器界面的前进后退。 </li></ul><h2 id="vue-route"><a href="#vue-route" class="headerlink" title="vue-route"></a>vue-route</h2><ul><li>vue-router是基于路由和组件的<ul><li>路由用于设定访问路径, 将路径和组件映射起来.</li><li>在vue-router的单页面应用中, 页面的路径的改变就是组件的切换.</li></ul></li></ul><h3 id="安装和使用vue-router"><a href="#安装和使用vue-router" class="headerlink" title="安装和使用vue-router"></a>安装和使用vue-router</h3><ul><li>步骤一: 安装vue-router </li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">npm</span> <span class="selector-tag">install</span> <span class="selector-tag">vue-router</span> <span class="selector-tag">--save</span></span><br></pre></td></tr></table></figure><ul><li>步骤二: 在模块化工程中使用它(因为是一个插件, 所以可以通过Vue.use()来安装路由功能) </li></ul><p>第一步：<strong>导入</strong>路由对象，并且调用 <strong>Vue.use(VueRouter)</strong></p><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220517160237976.png" alt="image-20220517160237976"></p><p>第二步：创建路由实例，并且传入路由映射配置</p><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220517160331131.png" alt="image-20220517160331131"></p><p>第三步：在<strong>Vue实例</strong>中<strong>挂载</strong>创建的<strong>路由实例</strong></p><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220517160416016.png" alt="image-20220517160416016"></p><p>使用vue-router的步骤:</p><ul><li><p>第一步: 创建路由组件</p><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220517160703947.png" alt="image-20220517160703947"></p></li></ul><p>第二步: 配置路由映射: 组件和路径映射关系</p><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220517160956809.png" alt="image-20220517160956809"></p><ul><li>第三步: 使用路由: 通过<router-link>和<router-view></li></ul><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220517161022121.png" alt="image-20220517161022121"></p><ul><li><router-link>: 该标签是一个vue-router中已经内置的组件, 它会被渲染成一个<a>标签.</li><li><router-view>: 该标签会根据当前的路径, 动态渲染出不同的组件. </li><li>网页的其他内容, 比如顶部的标题/导航, 或者底部的一些版权信息等会和<router-view>处于同一个等级.</li><li>在路由切换时, 切换的是<router-view>挂载的组件, 其他内容不会发生改变.</li></ul><h3 id="路由的默认路径"><a href="#路由的默认路径" class="headerlink" title="路由的默认路径"></a>路由的默认路径</h3><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220517161156358.png" alt="image-20220517161156358"></p><ul><li>配置解析:<ul><li>我们在routes中又配置了一个映射.</li><li>path配置的是根路径: /</li><li><strong>redirect是重定向,</strong> 也就是我们将根路径重定向到/home的路径下, 这样就可以得到我们想要的结果了. </li></ul></li></ul><h3 id="HTML5的History模式"><a href="#HTML5的History模式" class="headerlink" title="HTML5的History模式"></a>HTML5的History模式</h3><ul><li>我们前面说过改变路径的方式有两种:<ul><li>URL的hash</li><li>HTML5的history</li><li>默认情况下, 路径的改变使用的URL的hash.</li></ul></li><li>如果希望使用HTML5的history模式, 非常简单, 进行如下配置即可: </li></ul><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220517161534219.png" alt="image-20220517161534219"></p><p>hash的url是带# 而history是不带的</p><h3 id="router-link补充"><a href="#router-link补充" class="headerlink" title="router-link补充"></a>router-link补充</h3><p><router-link>还有一些其他属性:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&#x27;/home&#x27;</span> <span class="attr">tag</span>=<span class="string">&#x27;li&#x27;</span> <span class="attr">replace</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong>属性: to,</strong> 用于指定跳转的路径. </li><li>tag: tag可以指定<router-link>之后渲染成什么组件, 比如上面的代码会被渲染成一个<li>元素, 而不是<a></li><li>replace: replace不会留下history记录, 所以指定replace的情况下, 后退键返回不能返回到上一个页面中</li><li>active-class: 当<router-link>对应的路由匹配成功时, 会自动给当前元素设置一个router-link-active的class, 设置active-class可以修改默认的名称.</li><li>在进行高亮显示的导航菜单或者底部tabbar时, 会使用到该类.</li><li>但是通常不会修改类的属性, 会直接使用默认的router-link-active即可.</li></ul><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220517161923241.png" alt="image-20220517161923241"></p><h3 id="修改linkActiveClass"><a href="#修改linkActiveClass" class="headerlink" title="修改linkActiveClass"></a>修改linkActiveClass</h3><ul><li>该class具体的名称也可以通过router实例的属性进行修改</li></ul><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220517162129848.png" alt="image-20220517162129848"></p><ul><li>exact-active-class 类似于active-class,</li><li>只是在精准匹配下才会出现的class.</li><li>后面看到嵌套路由时, 我们再看下这个属性.</li></ul><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220517162140769.png" alt="image-20220517162140769"></p><h3 id="路由代码跳转"><a href="#路由代码跳转" class="headerlink" title="路由代码跳转"></a>路由代码跳转</h3><ul><li>router里的index.js </li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置路由相关的信息</span></span><br><span class="line"><span class="comment">// 导入路由对象</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">&#x27;../components/Home&#x27;</span></span><br><span class="line"><span class="keyword">import</span> About <span class="keyword">from</span> <span class="string">&#x27;../components/About&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 1.通过Vue.use(插件), 安装插件</span></span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 2.创建VueRouter对象</span></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="comment">// redirect重定向</span></span><br><span class="line">    redirect: <span class="string">&#x27;/home&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">    component: Home</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">    component: About</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"><span class="comment">// 创建路由实例，并且传入路由映射配置</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  <span class="comment">// 配置路由和组件之间的应用关系</span></span><br><span class="line">  routes,</span><br><span class="line">  mode: <span class="string">&#x27;history&#x27;</span>,</span><br><span class="line">  linkActiveClass: <span class="string">&#x27;active&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 3.将router对象传入到Vue实例</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure><ul><li>App.vue</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是APP组件<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用路由 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;router-link to=&quot;/home&quot; tag=&quot;button&quot; replace active-class=&quot;active&quot;&gt;首页&lt;/router-link&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;router-link to=&quot;/about&quot; tag=&quot;button&quot; replace active-class=&quot;active&quot;&gt;关于&lt;/router-link&gt;--&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/home&quot;</span> <span class="attr">tag</span>=<span class="string">&quot;button&quot;</span> <span class="attr">replace</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/about&quot;</span> <span class="attr">tag</span>=<span class="string">&quot;button&quot;</span> <span class="attr">replace</span>&gt;</span>关于<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- // 通过代码的方式修改路由 vue-router --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;button @click=&quot;homeClick&quot;&gt;首页&lt;/button&gt;</span></span><br><span class="line"><span class="comment">    &lt;button @click=&quot;aboutClick&quot;&gt;关于&lt;/button&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  name: <span class="string">&#x27;App&#x27;</span>,</span></span><br><span class="line">  methods: &#123;</span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">homeClick</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 通过代码的方式修改路由 vue-router</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// push =&gt; pushState</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// this.$router.push(&#x27;/home&#x27;)</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.$router.replace(<span class="string">&#x27;/home&#x27;</span>)</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&#x27;homeClick&#x27;</span>);</span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">aboutClick</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// this.$router.push(&#x27;/about&#x27;)</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.$router.replace(<span class="string">&#x27;/about&#x27;</span>)</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&#x27;aboutClick&#x27;</span>);</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="comment">/*.router-link-active &#123;*/</span></span></span><br><span class="line"><span class="css">    <span class="comment">/*color: #f00;*/</span></span></span><br><span class="line"><span class="css">  <span class="comment">/*&#125;*/</span></span></span><br><span class="line"> </span><br><span class="line"><span class="css">  <span class="selector-class">.active</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">color</span>: <span class="selector-id">#f00</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h3><ul><li>在某些情况下，一个页面的path路径可能是不确定的，比如我们进入用户界面时，希望是如下的路径：</li><li>/user/aaaa或/user/bbbb</li><li>除了有前面的/user之外，后面还跟上了用户的ID</li><li>这种path和Component的匹配关系，我们称之为动态路由(也是路由传递数据的一种方式)。 </li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- app.vue --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 动态拼接 使用v-bind --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&quot;&#x27;/user/&#x27;+userId&quot;</span>&gt;</span>用户<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  name: <span class="string">&quot;App&quot;</span>,</span></span><br><span class="line">  components: &#123;&#125;,</span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">      userId: <span class="string">&quot;zhangsan&quot;</span></span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- router.js --&gt;</span></span><br><span class="line">const routes = [</span><br><span class="line">    ...</span><br><span class="line">    &#123;</span><br><span class="line">        path:&#x27;/user/:id&#x27;,</span><br><span class="line">        component:User</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- user.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>$route.params.id:&#123;&#123;$route.params.id&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 即可拿到路由携带过来的数据 --&gt;</span></span><br></pre></td></tr></table></figure><h3 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h3><ul><li><p>首先, 我们知道路由中通常会定义很多不同的页面.</p></li><li><p>这个页面最后被打包在哪里呢? 一般情况下, 是放在一个js文件中.</p></li><li><p>但是, 页面这么多放在一个js文件中, 必然会造成这个页面非常的大.</p></li><li><p>如果我们一次性从服务器请求下来这个页面, 可能需要花费一定的时间, 甚至用户的电脑上还出现了短暂空白的情况.</p></li><li><p>如何避免这种情况呢? 使用路由懒加载就可以了.</p></li><li><p>路由懒加载做了什么?</p><ul><li>路由懒加载的主要作用就是将路由对应的组件打包成一个个的js代码块.</li><li>只有在这个路由被访问到的时候, 才加载对应的组件</li></ul></li></ul><p><strong>实现</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在ES6中, 我们可以有更加简单的写法来组织Vue异步组件和Webpack的代码分割.</span></span><br><span class="line"><span class="keyword">const</span> Home = <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;../components/Home.vue&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="路由嵌套"><a href="#路由嵌套" class="headerlink" title="路由嵌套"></a>路由嵌套</h3><ul><li>嵌套路由是一个很常见的功能<ul><li>比如在home页面中, 我们希望通过/home/news和/home/message访问一些内容.</li><li>一个路径映射一个组件, 访问这两个路径也会分别渲染两个组件.</li></ul></li></ul><h3 id="嵌套路由实现"><a href="#嵌套路由实现" class="headerlink" title="嵌套路由实现"></a>嵌套路由实现</h3><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220517165914323.png" alt="image-20220517165914323"><br><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220517170056439.png" alt="image-20220517170056439"></p><h4 id="嵌套默认路径"><a href="#嵌套默认路径" class="headerlink" title="嵌套默认路径"></a>嵌套默认路径</h4><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220517170137425.png" alt="image-20220517170137425"></p><h3 id="传递参数的方式"><a href="#传递参数的方式" class="headerlink" title="传递参数的方式"></a>传递参数的方式</h3><ul><li>传递参数主要有两种类型:</li><li>params和query</li><li>params的类型:<br>配置路由格式: /router/:id<br>传递的方式: 在path后面跟上对应的值<br>传递后形成的路径: /router/123, /router/abc</li><li>query的类型:<br>配置路由格式: /router, 也就是普通配置<br>传递的方式: 对象中使用query的key作为传递方式<br>传递后形成的路径: /router?id=123, /router?id=abc</li></ul><h4 id="传递参数方式一-router-link"><a href="#传递参数方式一-router-link" class="headerlink" title="传递参数方式一:     router-link"></a>传递参数方式一:     router-link</h4><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220517170819234.png" alt="image-20220517170819234"></p><h4 id="传递参数方式二-JavaScript代码"><a href="#传递参数方式二-JavaScript代码" class="headerlink" title="传递参数方式二: JavaScript代码"></a>传递参数方式二: JavaScript代码</h4><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220517170900191.png" alt="image-20220517170900191"></p><h4 id="获取参数"><a href="#获取参数" class="headerlink" title="获取参数"></a>获取参数</h4><ul><li>获取参数通过$route对象获取的.<ul><li>在使用了 vue-router 的应用中，路由对象会被注入每个组件中，赋值为 this.$route ，并且当路由切换时，路由对象会被更新。 </li></ul></li></ul><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220517171125297.png" alt="image-20220517171125297"></p> 来获取里面的值<h4 id="route和-router是有区别的"><a href="#route和-router是有区别的" class="headerlink" title="$route和$router是有区别的"></a>$route和$router是有区别的</h4><ul><li>$route和$router是有区别的<ul><li>$router为VueRouter实例，想要导航到不同URL，则使用$router.push方法</li><li>$route为当前router跳转对象里面可以获取name、path、query、params等 </li></ul></li></ul><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220517171358484.png" alt="image-20220517171358484"></p><h2 id="导航守卫"><a href="#导航守卫" class="headerlink" title="导航守卫"></a>导航守卫</h2><ul><li>我们来考虑一个需求: 在一个SPA应用中, 如何改变网页的标题呢?</li><li>网页标题是通过<title>来显示的, 但是SPA只有一个固定的HTML, 切换不同的页面时, 标题并不会改变.</li><li>但是我们可以通过JavaScript来修改<title>的内容.window.document.title = ‘新的标题’.</li></ul><p>在Vue中不建议操作虚拟dom</p><ul><li>什么是导航守卫?<ul><li>vue-router提供的导航守卫主要用来监听监听路由的进入和离开的.</li><li>vue-router提供了beforeEach和afterEach的钩子函数, 它们会在路由即将改变前和改变后触发. </li></ul></li></ul><h3 id="导航守卫使用"><a href="#导航守卫使用" class="headerlink" title="导航守卫使用"></a>导航守卫使用</h3><ul><li>我们可以利用beforeEach来完成标题的修改.<ul><li>首先, 我们可以在钩子当中定义一些标题, 可以利用meta来定义</li><li>其次, 利用导航守卫,修改我们的标题. </li></ul></li></ul><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220517232239138.png" alt="image-20220517232239138"></p><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220517232343668.png" alt="image-20220517232343668"></p><p>结合使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 进入路由前方法勾子</span></span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(to, <span class="string">&#x27;前置第一个参数&#x27;</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">from</span>, <span class="string">&#x27;前置第二个参数&#x27;</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(next, <span class="string">&#x27;前置第三个参数&#x27;</span>)</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    to 目标路由</span></span><br><span class="line"><span class="comment">    from 源路由</span></span><br><span class="line"><span class="comment">    next 跳转到下一个路由</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="comment">//这里暂时用local、storange来简单模拟验证权限</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">window</span>.localstorange.getItem(<span class="string">&quot;token&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">// 如果存在，则直接跳转到对应路由</span></span><br><span class="line">     next();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果不存在，则跳转到登录页</span></span><br><span class="line">    next(<span class="string">&#x27;/login&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局路由改变后钩子</span></span><br><span class="line">router.afterEach(<span class="function">(<span class="params">to, <span class="keyword">from</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//将滚动条恢复到最顶端</span></span><br><span class="line">  <span class="built_in">window</span>.scrollTo(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="导航守卫补充"><a href="#导航守卫补充" class="headerlink" title="导航守卫补充"></a>导航守卫补充</h3><ul><li>补充一:如果是后置钩子, 也就是afterEach, 不需要主动调用next()函数.</li><li>补充二: 上面我们使用的导航守卫, 被称之为全局守卫（beforeEach、afterEach).<br>路由独享的守卫（beforeEnter）.</li><li>组件内的守卫（beforeRouterEnter、beforeRouterUpdate、beforeRouterLeave）. </li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path: &#x27;/about&#x27;,</span><br><span class="line">    component: About,</span><br><span class="line">    meta: &#123;</span><br><span class="line">      title: &#x27;关于&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">    // 2.路由独享的守卫</span><br><span class="line">    beforeEnter: (to, from, next) =&gt; &#123;</span><br><span class="line">      console.log(&#x27;about beforeEnter&#x27;);</span><br><span class="line">      next()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  name: <span class="string">&quot;Home&quot;</span>,</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">      name: <span class="string">&quot;yyy&quot;</span>,</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">beforeRouteEnter</span>(<span class="params">to, <span class="keyword">from</span>, next</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 在渲染该组件的对应路由被 confirm 前调用</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 不！能！获取组件实例 `this`</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 因为当守卫执行前，组件实例还没被创建</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// console.log(to);</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// console.log(from);</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">// undefined</span></span></span><br><span class="line"><span class="javascript">    next(<span class="function">(<span class="params">vm</span>) =&gt;</span> &#123; <span class="comment">// 通过传一个回调给 next来访问组件实例</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(vm.name);</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">beforeRouteUpdate</span>(<span class="params">to, <span class="keyword">from</span>, next</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 在当前路由改变，但是该组件被复用时调用</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 可以访问组件实例 `this`</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">&quot;beforeRouteUpdate&quot;</span>);</span></span><br><span class="line">    next();</span><br><span class="line">  &#125;,</span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">beforeRouteLeave</span>(<span class="params">to, <span class="keyword">from</span>, next</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 导航离开该组件的对应路由时调用</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 可以访问组件实例 `this`</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.$route.path);</span></span><br><span class="line">    next();</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h2><ul><li>keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。</li><li>它们有两个非常重要的属性:</li><li><strong>include</strong> - 字符串或正则表达，只有匹配的组件会被缓存</li><li><strong>exclude</strong> - 字符串或正则表达式，任何匹配的组件都不会被缓存 </li><li>router-view 也是一个组件，如果直接被包在 keep-alive 里面，所有路径匹配到的视图组件都会被缓存</li><li><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220517233243882.png" alt="image-20220517233243882"></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> &lt;!-- 在vue中我们可以使用keepalive来进行组件缓存 --&gt;</span><br><span class="line">   &lt;keep-alive exclude=<span class="string">&quot;Profile,User&quot;</span>&gt;</span><br><span class="line">     &lt;router-view /&gt;</span><br><span class="line">   &lt;/keep-alive&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在&lt;script&gt;里面</span></span><br><span class="line"><span class="comment">// 这两个函数, 只有该组件被保持了状态使用了keep-alive时, 才是有效的</span></span><br><span class="line"> <span class="function"><span class="title">activated</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">   <span class="comment">// 活跃状态</span></span><br><span class="line">   <span class="built_in">this</span>.$router.push(<span class="built_in">this</span>.path);</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">&quot;activated&quot;</span>);</span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="function"><span class="title">deactivated</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">&quot;deactivated&quot;</span>);</span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="comment">// 离开当前路由页面时调用</span></span><br><span class="line"> <span class="function"><span class="title">beforeRouteLeave</span>(<span class="params">to, <span class="keyword">from</span>, next</span>)</span> &#123;</span><br><span class="line">   <span class="comment">// 首页中使用path属性记录离开时的路径，在beforeRouteLeave中记录</span></span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">this</span>.$route.path);</span><br><span class="line">   <span class="built_in">this</span>.path = <span class="built_in">this</span>.$route.path;</span><br><span class="line">   next();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>可以通过create周期函数来进行验证 看看是否出现重复渲染</p><h3 id="文件路径问题"><a href="#文件路径问题" class="headerlink" title="文件路径问题"></a>文件路径问题</h3><ul><li>可以起别名，在dom中需要加 ~ ，其他地方不需要</li></ul><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220517234616151.png" alt="image-20220517234616151"></p><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220517234625860.png" alt="image-20220517234625860"></p><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220517234636131.png" alt="image-20220517234636131"></p><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><ul><li>Promise到底是做什么的呢？<ul><li><strong>Promise是异步编程的一种解决方案。</strong></li></ul></li></ul><p>那什么时候我们会来处理异步事件呢？</p><ul><li>一种很常见的场景应该就是<strong>网络请求</strong>了。</li></ul><h2 id="Promise基本使用"><a href="#Promise基本使用" class="headerlink" title="Promise基本使用"></a>Promise基本使用</h2><h3 id="定时器的异步事件"><a href="#定时器的异步事件" class="headerlink" title="定时器的异步事件"></a>定时器的异步事件</h3><ul><li><p>这里，我们用一个定时器来模拟异步事件：</p><ul><li>假设下面的data是从网络上1秒后请求的数据</li><li>console.log就是我们的处理方式。</li></ul><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220518090249174.png" alt="image-20220518090249174"></p></li></ul><ul><li>我们先来认认真真的读一读这个程序到底做了什么？</li><li>new Promise很明显是创建一个Promise对象</li><li>小括号中((resolve, reject) =&gt; {})也很明显就是一个函数，而且我们这里用的是之前刚刚学习过的箭头函数。</li><li>但是resolve, reject它们是什么呢？</li><li>我们先知道一个事实：在创建Promise时，传入的这个箭头函数是固定的（一般我们都会这样写）</li><li>resolve和reject它们两个也是函数，通常情况下，我们会根据请求数据的成功和失败来决定调用哪一个。</li><li>成功还是失败？<ul><li>如果是成功的，那么通常我们会调用resolve(messsage)，这个时候，我们后续的then会被回调。</li><li>如果是失败的，那么通常我们会调用reject(error)，这个时候，我们后续的catch会被回调。</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// resolve(&#x27;Hello Vuejs&#x27;)</span></span><br><span class="line">      reject(<span class="string">&#x27;error message&#x27;</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">    <span class="comment">// 不想同时写then和catch的话 then里面可以直接传入两个函数 data,err</span></span><br><span class="line">  &#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">  &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="comment">//ES6 箭头函数的应用</span></span><br><span class="line"><span class="comment">// err=&gt;简化了catch</span></span><br></pre></td></tr></table></figure><h3 id="Promise三种状态和另外处理形式"><a href="#Promise三种状态和另外处理形式" class="headerlink" title="Promise三种状态和另外处理形式"></a>Promise三种状态和另外处理形式</h3><ul><li><strong>pending</strong>：等待状态，比如正在进行网络请求，或者定时器没有到时间。</li><li><strong>fulfill</strong>：满足状态，当我们主动回调了resolve时，就处于该状态，并且会回调.then()</li><li><strong>reject</strong>：拒绝状态，当我们主动回调了reject时，就处于该状态，并且会回调.catch() </li></ul><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220518090615966.png" alt="image-20220518090615966"></p><h2 id="Promise链式调用"><a href="#Promise链式调用" class="headerlink" title="Promise链式调用"></a>Promise链式调用</h2><h3 id="Promise链式调用-1"><a href="#Promise链式调用-1" class="headerlink" title="Promise链式调用"></a>Promise链式调用</h3><ul><li>我们在看Promise的流程图时，发现无论是then还是catch都可以返回一个Promise对象。</li><li>所以，我们的代码其实是可以进行链式调用的</li><li>这里我们直接通过Promise包装了一下新的数据，将Promise对象返回了</li><li>Promise.resovle()：将数据包装成Promise对象，并且在内部回调resolve()函数</li><li>Promise.reject()：将数据包装成Promise对象，并且在内部回调reject()函数 <img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220518090856289.png" alt="image-20220518090856289" style="zoom: 80%;" /></li></ul><p>链式操作简化代码 包含失败抛出异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">      setTimeout(() =&gt; &#123;</span><br><span class="line">        resolve(<span class="string">&#x27;aaa&#x27;</span>)</span><br><span class="line">      &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;).then(res =&gt; &#123;</span><br><span class="line">      <span class="comment">// 1.自己处理10行代码</span></span><br><span class="line">      console.log(res, <span class="string">&#x27;第一层的10行处理代码&#x27;</span>);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// reject失败的简写</span></span><br><span class="line">      <span class="comment">// return Promise.reject(&#x27;error message&#x27;)</span></span><br><span class="line">      <span class="comment">// 失败error的其他写法 手动抛出异常</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="string">&#x27;error message&#x27;</span></span><br><span class="line">    &#125;).then(res =&gt; &#123;</span><br><span class="line">      console.log(res, <span class="string">&#x27;第二层的10行处理代码&#x27;</span>);</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">return</span> Promise.resolve(res + <span class="string">&#x27;222&#x27;</span>)</span><br><span class="line">    &#125;).then(res =&gt; &#123;</span><br><span class="line">      console.log(res, <span class="string">&#x27;第三层的10行处理代码&#x27;</span>);</span><br><span class="line">    &#125;).<span class="keyword">catch</span>(err =&gt; &#123;</span><br><span class="line">      console.log(err);</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><ul><li>官方解释：Vuex 是一个专为 Vue.js 应用程序开发的<strong>状态管理模式</strong></li><li>它采用 <strong>集中式存储管理</strong> 应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</li><li>Vuex 也集成到 Vue 的官方调试工具 <strong>devtools extension</strong>，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。 </li></ul><h3 id="单界面的状态管理"><a href="#单界面的状态管理" class="headerlink" title="单界面的状态管理"></a>单界面的状态管理</h3><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220518091455913.png" alt="image-20220518091455913"></p><ul><li> 这图片中的三种东西，怎么理解呢？</li><li>State：不用多说，就是我们的状态。（你姑且可以当做就是data中的属性）</li><li>View：视图层，可以针对State的变化，显示不同的信息。（这个好理解吧？）</li><li>Actions：这里的Actions主要是用户的各种操作：点击、输入等等，会导致状态的改变。</li></ul><p>例子</p><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220518093151556.png" alt="image-20220518093151556"></p><ul><li>counter需要某种方式被记录下来，也就是我们的State。</li><li>counter目前的值需要被显示在界面中，也就是我们的View部分。</li><li>界面发生某些操作时（我们这里是用户的点击，也可以是用户的input），需要去更新状态，也就是我们的Actions 这不就是上面的流程图了吗？</li></ul><h3 id="多界面状态管理"><a href="#多界面状态管理" class="headerlink" title="多界面状态管理"></a>多界面状态管理</h3><ul><li><p>Vuex就是为我们提供这个大管家的工具。 </p></li><li><p>全局单例模式（大管家）</p><ul><li>我们现在要做的就是将共享的状态抽取出来，交给我们的大管家，统一进行管理。</li><li>之后，你们每个试图，按照我<strong>规定好</strong>的规定，进行访问和修改等操作。</li><li>这就是Vuex背后的基本思想。 </li></ul><p><img src= "/img/loading1.gif" data-lazy-src="https://img-blog.csdnimg.cn/20210731154729306.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIzMDczODEx,size_16,color_FFFFFF,t_70" alt="img"></p></li></ul><h3 id="Vuex基本使用"><a href="#Vuex基本使用" class="headerlink" title="Vuex基本使用"></a>Vuex基本使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vuex --save</span><br></pre></td></tr></table></figure><p>vuex.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="comment">// 1.安装插件</span></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 2.创建对象 new Vuex.Store</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    <span class="comment">// 这5个对象一般都是固定的</span></span><br><span class="line">    state: &#123; <span class="comment">//保存状态</span></span><br><span class="line">        counter: <span class="number">1000</span></span><br><span class="line">    &#125;,</span><br><span class="line">    mutations: &#123; <span class="comment">// 方法 修改state唯一途径 同步操作</span></span><br><span class="line">        <span class="function"><span class="title">increment</span>(<span class="params">state</span>)</span> &#123; <span class="comment">// 默认就有个state参数，不用通过this.state</span></span><br><span class="line">            state.counter++</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">decrement</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">            state.counter--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    actions: &#123; <span class="comment">// 如果有异步操作在这里写 比如网络请求</span></span><br><span class="line"> </span><br><span class="line">    &#125;,</span><br><span class="line">    getters: &#123;</span><br><span class="line"> </span><br><span class="line">    &#125;,</span><br><span class="line">    modules: &#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 3.导出store对象</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure><h4 id="挂载到Vue实例中"><a href="#挂载到Vue实例中" class="headerlink" title="挂载到Vue实例中"></a>挂载到Vue实例中</h4><p>main.js代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store&#x27;</span></span><br><span class="line"> </span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 其他组件就能通过 $store 获取到store</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  store,</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><p>我们来对使用步骤，做一个简单的小节：</p></li><li><p>1.提取出一个公共的store对象，用于保存在多个组件中共享的状态</p></li><li><p>2.将store对象放置在new Vue对象中，这样可以保证在所有的组件中都可以使用到</p></li><li><p>3.在其他组件中使用store对象中保存的状态即可<br>通过this.$store.state.属性的方式来访问状态<br>通过this.$store.commit(‘mutation中方法’)来修改状态 </p></li><li><p>注意事项：</p><ul><li><strong>我们通过提交mutation的方式，而非直接改变store.state.count。</strong></li><li>这是因为Vuex可以更明确的追踪状态的变化，所以不要直接改变store.state.count的值。 </li></ul></li></ul><h2 id="Vuex核心概念"><a href="#Vuex核心概念" class="headerlink" title="Vuex核心概念"></a>Vuex核心概念</h2><ul><li>State</li><li>Getters</li><li>Mutation</li><li>Action</li><li>Module</li></ul><h2 id="State"><a href="#State" class="headerlink" title="State"></a>State</h2><h3 id="State单一状态树"><a href="#State单一状态树" class="headerlink" title="State单一状态树"></a>State单一状态树</h3><ul><li><p>Vuex提出使用单一状态树, 什么是单一状态树呢？</p><ul><li>英文名称是Single Source of Truth，也可以翻译成单一数据源。 </li></ul></li><li><p>Vuex也使用了单一状态树来管理应用层级的全部状态。</p></li><li><p>单一状态树能够让我们最直接的方式找到某个状态的片段，而且在之后的维护和调试过程中，也可以非常方便的管理和维护。 </p></li></ul><h2 id="Getters"><a href="#Getters" class="headerlink" title="Getters"></a>Getters</h2><p>有时候，我们需要从store中获取一些state变异后的状态，比如下面的Store中</p><p><strong><em>\</em>注意，getter 在通过属性访问时是作为 Vue 的响应式系统的一部分缓存其中的**</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  <span class="comment">// 这五个一般都是固定的，是对象</span></span><br><span class="line">  state: &#123; <span class="comment">//保存状态</span></span><br><span class="line">    counter: <span class="number">1000</span>,</span><br><span class="line">    students: [&#123;</span><br><span class="line">        id: <span class="number">110</span>,</span><br><span class="line">        name: <span class="string">&#x27;why&#x27;</span>,</span><br><span class="line">        age: <span class="number">18</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        id: <span class="number">111</span>,</span><br><span class="line">        name: <span class="string">&#x27;kobe&#x27;</span>,</span><br><span class="line">        age: <span class="number">24</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        id: <span class="number">112</span>,</span><br><span class="line">        name: <span class="string">&#x27;james&#x27;</span>,</span><br><span class="line">        age: <span class="number">30</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        id: <span class="number">113</span>,</span><br><span class="line">        name: <span class="string">&#x27;curry&#x27;</span>,</span><br><span class="line">        age: <span class="number">10</span></span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line"> </span><br><span class="line">  &#125;,</span><br><span class="line">  getters: &#123; <span class="comment">// 可以认为是 store 的计算属性</span></span><br><span class="line">    <span class="comment">// getters里面的方法 也会有state参数</span></span><br><span class="line">    <span class="function"><span class="title">powerCounter</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> state.counter * state.counter</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 找出多于20岁的学生 </span></span><br><span class="line">    <span class="comment">// filter(回调函数(当前元素的值))</span></span><br><span class="line">    <span class="function"><span class="title">more20stu</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> state.students.filter(<span class="function"><span class="params">s</span> =&gt;</span> s.age &gt; <span class="number">20</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Getters作为参数和传递参数"><a href="#Getters作为参数和传递参数" class="headerlink" title="Getters作为参数和传递参数"></a>Getters作为参数和传递参数</h3><ul><li>如果我们已经有了一个获取所有年龄大于20岁学生列表的getters, 那么代码可以这样来写 </li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 找出大于20岁学生的个数</span></span><br><span class="line">    <span class="function"><span class="title">more20stuLength</span>(<span class="params">state, getters</span>)</span> &#123; <span class="comment">// Getters 也可以接受其他 getters 作为第二个参数：</span></span><br><span class="line">      <span class="comment">//  return state.students.filter(s =&gt; s.age &gt; 20).length</span></span><br><span class="line">      <span class="keyword">return</span> getters.more20stu.length</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>其中就可以重复调用里面的函数了</p><ul><li>getters默认是不能传递参数的, 如果希望传递参数, 那么只能让getters本身返回另一个函数.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">getter:&#123;</span><br><span class="line">    <span class="comment">// 找出年龄大于参数age的学生</span></span><br><span class="line">    <span class="function"><span class="title">moreAgeStu</span>(<span class="params">state</span>)</span> &#123; <span class="comment">// getters传递参数 只能让getters本身返回另一个函数.</span></span><br><span class="line">      <span class="comment">// return function (age) &#123;</span></span><br><span class="line">      <span class="comment">//   return state.students.filter(s =&gt; s.age &gt; age)</span></span><br><span class="line">      <span class="comment">// &#125;</span></span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="params">age</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> state.students.filter(<span class="function"><span class="params">s</span> =&gt;</span> s.age &gt; age)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//应用 可以传参</span></span><br><span class="line"> &lt;h2&gt;&#123;&#123; $store.getters.moreAgeStu(<span class="number">12</span>) &#125;&#125;&lt;/h2&gt;</span><br></pre></td></tr></table></figure><h2 id="Mutation"><a href="#Mutation" class="headerlink" title="Mutation"></a>Mutation</h2><h3 id="Mutation状态更新"><a href="#Mutation状态更新" class="headerlink" title="Mutation状态更新"></a>Mutation状态更新</h3><ul><li> Vuex的store状态的更新唯一方式：提交Mutation</li><li>Mutation主要包括两部分：<ul><li>字符串的<strong>事件类型（type）</strong></li><li>一个<strong>回调函数（handler）</strong>,该回调函数的第一个参数就是state。</li></ul></li></ul><p><img src= "/img/loading1.gif" data-lazy-src="https://img-blog.csdnimg.cn/20210801143013427.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIzMDczODEx,size_16,color_FFFFFF,t_70" alt="img"></p><ul><li>通过mutation更新 </li></ul><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220518095418683.png" alt="image-20220518095418683"></p><h3 id="Mutation传递参数"><a href="#Mutation传递参数" class="headerlink" title="Mutation传递参数"></a>Mutation传递参数</h3><ul><li><p>在通过mutation更新数据的时候, 有可能我们希望携带一些</p><p>额外的参数</p><ul><li>参数被称为是mutation的<strong>载荷(Payload)</strong></li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">mutations:&#123;</span><br><span class="line">     <span class="comment">// 特殊的提交封装  当作对象来进行使用</span></span><br><span class="line">    <span class="function"><span class="title">incrementCount</span>(<span class="params">state, payload</span>)</span> &#123;</span><br><span class="line">      <span class="comment">// console.log(count);</span></span><br><span class="line">      state.counter += payload.count</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//应用 带type风格的</span></span><br><span class="line"> <span class="function"><span class="title">addCount</span>(<span class="params">count</span>)</span> &#123;</span><br><span class="line">      <span class="comment">// payload: 负载</span></span><br><span class="line">      <span class="comment">// 1.普通的提交封装 这样写的 mutations里的 incrementCount(state, count) 的count 就是count</span></span><br><span class="line">      <span class="comment">// this.$store.commit(&#x27;incrementCount&#x27;, count) // 单个参数</span></span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 2.特殊的提交封装 mutations里的 incrementCount(state, count) 的count 是一个对象 写成payload比较合适，通过payload.count取</span></span><br><span class="line">      <span class="built_in">this</span>.$store.commit(&#123;</span><br><span class="line">        type: <span class="string">&quot;incrementCount&quot;</span>,</span><br><span class="line">        count,</span><br><span class="line">      &#125;);</span><br><span class="line">     <span class="comment">//不带type风格的</span></span><br><span class="line">      <span class="keyword">const</span> stu = &#123; <span class="attr">id</span>: <span class="number">114</span>, <span class="attr">name</span>: <span class="string">&quot;alan&quot;</span>, <span class="attr">age</span>: <span class="number">35</span> &#125;;</span><br><span class="line">      <span class="built_in">this</span>.$store.commit(<span class="string">&quot;addStudent&quot;</span>, stu);</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><h3 id="Mutation响应规则"><a href="#Mutation响应规则" class="headerlink" title="Mutation响应规则"></a>Mutation响应规则</h3><ul><li><p>Vuex的store中的state是响应式的, 当state中的数据发生改变时, Vue组件会自动更新.</p></li><li><p>这就要求我们必须遵守一些Vuex对应的规则:</p><ul><li>提前在store中初始化好所需的属性.</li><li>当给state中的对象添加新属性时, 使用下面的方式:<ul><li>方式一: 使用<strong>Vue.set</strong>(obj, ‘newProp’, 123)</li><li>方式二: 用新对象给旧对象重新赋值 </li></ul></li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123; <span class="comment">//保存状态</span></span><br><span class="line">    <span class="comment">// state里面都属性初始化后 每个属性对应一个dep 监听属性变化 dep观察者模式</span></span><br><span class="line">    info: &#123;</span><br><span class="line">      name: <span class="string">&#x27;kobe&#x27;</span>, <span class="comment">// Dep -&gt; [Watcher]</span></span><br><span class="line">      age: <span class="number">40</span>, <span class="comment">// Dep -&gt; [Watcher]</span></span><br><span class="line">      height: <span class="number">1.98</span> <span class="comment">// Dep -&gt; [Watcher]</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    mutations: &#123;</span><br><span class="line">        <span class="function"><span class="title">updateInfo</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">          <span class="comment">// 可以响应式</span></span><br><span class="line">          state.info.name = <span class="string">&#x27;coderwhy&#x27;</span></span><br><span class="line">          <span class="comment">// 不能响应式</span></span><br><span class="line">          <span class="comment">// state.info[&#x27;address&#x27;] = &#x27;洛杉矶&#x27; // 我的可以响应？？？视频中的不可以</span></span><br><span class="line">          Vue.set(state.info, <span class="string">&#x27;address&#x27;</span>, <span class="string">&#x27;洛杉矶&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">          <span class="comment">// delete state.info.age  // “delete+某个属性”该方式做不到响应式</span></span><br><span class="line">          <span class="comment">// Vue.delete(state.info, &#x27;age&#x27;) // Vue.delete() 响应式</span></span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Mutation常量类型-–-概念"><a href="#Mutation常量类型-–-概念" class="headerlink" title="Mutation常量类型 – 概念"></a>Mutation常量类型 – 概念</h3><p>  我们来考虑下面的问题:</p><ul><li>在mutation中, 我们定义了很多事件类型(也就是其中的方法名称).</li><li>当我们的项目增大时, Vuex管理的状态越来越多, 需要更新状态的情况越来越多, 那么意味着Mutation中的方法越来越多.</li><li>方法过多, 使用者需要花费大量的经历去记住这些方法, 甚至是多个文件间来回切换, 查看方法名称, 甚至如果不是复制的时候, 可能还会出现写错的情况.</li></ul><p>如何避免上述的问题呢?</p><ul><li><p>在各种Flux实现中, 一种很常见的方案就是使用<strong>常量</strong>替代Mutation<strong>事件的类型.</strong></p></li><li><p>我们可以将这些常量放在一个单独的文件中, 方便管理以及让整个app所有的事件类型一目了然.</p></li><li><p>具体怎么做呢?</p><ul><li>我们可以创建一个文件: mutation-types.js, 并且在其中定义我们的常量.</li><li>定义常量时, 我们可以使用ES2015中的风格, 使用一个常量来作为函数的名称. </li></ul></li></ul><h3 id="Mutation常量类型-–-代码"><a href="#Mutation常量类型-–-代码" class="headerlink" title="Mutation常量类型 – 代码"></a>Mutation常量类型 – 代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//建立 mutations-type.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> INCREMENT = <span class="string">&#x27;increment&#x27;</span>  <span class="comment">//向外导出一个属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//store下index.js</span></span><br><span class="line"><span class="comment">// import INCREMENT from &#x27;./mutations-types&#x27;// 不能这样导入，只能是export default</span></span><br><span class="line"><span class="comment">// export导出，导入需要加 &#123;&#125;</span></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  INCREMENT</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&#x27;./mutations-types&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">     <span class="comment">// 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名</span></span><br><span class="line">    [INCREMENT](state) &#123;</span><br><span class="line">      state.counter++</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">    </span><br><span class="line"><span class="comment">//App.vue</span></span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> HelloVuex <span class="keyword">from</span> <span class="string">&quot;./components/HelloVuex&quot;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> &#123; INCREMENT &#125; <span class="keyword">from</span> <span class="string">&quot;./store/mutations-types&quot;</span>;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">&quot;App&quot;</span>,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="comment">// 在这里提交方法对应的mutation 的方法名</span></span><br><span class="line">    <span class="function"><span class="title">addition</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.$store.commit(INCREMENT);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h3 id="Mutation同步函数"><a href="#Mutation同步函数" class="headerlink" title="Mutation同步函数"></a>Mutation同步函数</h3><p> 通常情况下, Vuex要求我们Mutation中的方法必须是同步方法.</p><ul><li>主要的原因是当我们使用devtools时, 可以devtools可以帮助我们捕捉mutation的快照.</li><li>但是如果是异步操作, 那么devtools将不能很好的追踪这个操作什么时候会被完成. </li></ul><p>注意！！！  不能在mutation使用异步处理，因为会追踪不到</p><h2 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h2><h3 id="Action的基本定义"><a href="#Action的基本定义" class="headerlink" title="Action的基本定义"></a>Action的基本定义</h3><ul><li><p>我们强调, 不要再Mutation中进行异步操作.</p><ul><li>但是某些情况, 我们确实希望在Vuex中进行一些异步操作, 比如网络请求, 必然是异步的.这个时候怎么处理呢?</li><li>Action类似于Mutation, 但是是用来代替Mutation进行异步操作的.</li></ul></li></ul><p>Action的基本使用代码如下:</p><p><img src= "/img/loading1.gif" data-lazy-src="https://img-blog.csdnimg.cn/20210801171139543.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIzMDczODEx,size_16,color_FFFFFF,t_70" alt="img"></p><ul><li><strong>context是什么? context是和store对象具有相同方法和属性的对象.</strong></li><li>也就是说, 我们可以通过context去进行commit相关的操作, 也可以获取context.state等.</li><li>我们定义了actions, 然后又在actions中去进行commit, 这不是脱裤放屁吗?</li><li>事实上并不是这样, 如果在Vuex中有异步操作, 那么我们就可以在actions中完成了. </li></ul><h3 id="Action的分发"><a href="#Action的分发" class="headerlink" title="Action的分发"></a>Action的分发</h3><p>在Vue组件中, 如果我们调用action中的方法, 那么就需要使用dispatch</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用  </span></span><br><span class="line"><span class="function"><span class="title">updateInfo</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="comment">// this.$store.commit(&#x27;updateInfo&#x27;)  // 这样没有经过actions</span></span><br><span class="line">      <span class="comment">// 异步修改信息 actions</span></span><br><span class="line">      <span class="comment">// this.$store.dispatch(&#x27;aUpdateInfo&#x27;,&quot;我是携带的信息&quot;);// 携带一个参数</span></span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 通知外面已经改成功了 -&gt; commit调用之后就算成功，利用对象的方法回调</span></span><br><span class="line">      <span class="built_in">this</span>.$store.dispatch(<span class="string">&#x27;aUpdateInfo&#x27;</span>, &#123;</span><br><span class="line">        message: <span class="string">&#x27;我是携带的信息&#x27;</span>,</span><br><span class="line">        success: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">&#x27;里面已经完成了&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      &#125;,</span><br><span class="line">          </span><br><span class="line">          </span><br><span class="line"><span class="comment">//vuex相关代码</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    mutations:&#123;</span><br><span class="line">         <span class="function"><span class="title">updateInfo</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">              state.info.name = <span class="string">&#x27;coderwhy&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    actions:&#123;</span><br><span class="line">          <span class="comment">// 默认参数 context: 上下文 现在先理解成store</span></span><br><span class="line">         <span class="function"><span class="title">aUpdateInfo</span>(<span class="params">context, payload</span>)</span> &#123;</span><br><span class="line">              <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                context.commit(<span class="string">&#x27;updateInfo&#x27;</span>)</span><br><span class="line">                <span class="built_in">console</span>.log(payload.message);</span><br><span class="line">                payload.success() <span class="comment">// 调用回调 告诉外面已经成功</span></span><br><span class="line">              &#125;, <span class="number">1000</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Action返回的Promise"><a href="#Action返回的Promise" class="headerlink" title="Action返回的Promise"></a>Action返回的Promise</h3><p>优化异步请求</p><ul><li>前面我们学习ES6语法的时候说过, Promise经常用于异步操作.<ul><li>在Action中, 我们可以将异步操作放在一个Promise中, 并且在成功或者失败后, 调用对应的resolve或reject. </li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vuex代码</span></span><br><span class="line">actions:&#123;</span><br><span class="line">     <span class="comment">// Action返回的Promise</span></span><br><span class="line">    <span class="function"><span class="title">aUpdateInfo</span>(<span class="params">context, payload</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          context.commit(<span class="string">&#x27;updateInfo&#x27;</span>);</span><br><span class="line">          <span class="built_in">console</span>.log(payload);</span><br><span class="line">          <span class="comment">//调用成功返回回调 返回整个promise函数</span></span><br><span class="line">          resolve(<span class="string">&#x27;1111111&#x27;</span>)</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">      &#125;) <span class="comment">// then()在App.vue里面写</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//App.vue</span></span><br><span class="line"><span class="function"><span class="title">updateInfo</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="comment">// 之前写的不够优雅 回调消息与携带信息混在一起，现在用Promise封装再用resolve调用</span></span><br><span class="line">      <span class="built_in">this</span>.$store.dispatch(<span class="string">&quot;aUpdateInfo&quot;</span>, <span class="string">&quot;我是携带的信息&quot;</span>).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;里面完成了提交&quot;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(res);</span><br><span class="line">      &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h2><h3 id="认识Module"><a href="#认识Module" class="headerlink" title="认识Module"></a>认识Module</h3><p>​    Module是模块的意思, 为什么在Vuex中我们要使用模块呢?</p><ul><li>Vue使用单一状态树,那么也意味着很多状态都会交给Vuex来管理.</li><li>当应用变得非常复杂时,store对象就有可能变得相当臃肿.</li><li>为了解决这个问题, Vuex允许我们将store分割成模块(Module), 而每个模块拥有自己的state、mutations、actions、getters等</li></ul><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220518102622132.png" alt="image-20220518102622132"></p><p> 局部module rootState是原module里面的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  <span class="comment">// 组件里面通过$store.state.a.name获取属性</span></span><br><span class="line">  state: &#123;</span><br><span class="line">    name: <span class="string">&#x27;zhangsan&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 官网state写法</span></span><br><span class="line">  <span class="comment">// state: () =&gt; (&#123;</span></span><br><span class="line">  <span class="comment">// &#125;),</span></span><br><span class="line">  <span class="comment">// 使用 this.$store.commit() 提交</span></span><br><span class="line">  mutations: &#123;</span><br><span class="line">    <span class="function"><span class="title">updateName</span>(<span class="params">state, payload</span>)</span> &#123;</span><br><span class="line">      state.name = payload</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// $store.getters.fullname调用</span></span><br><span class="line">  getters: &#123;</span><br><span class="line">    <span class="function"><span class="title">fullname</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> state.name + <span class="string">&#x27;11111&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">fullname2</span>(<span class="params">state, getters</span>)</span> &#123; <span class="comment">// 使用其他getters</span></span><br><span class="line">      <span class="keyword">return</span> getters.fullname + <span class="string">&#x27;2222&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// rootState 可以使用大的state里面的值  这里这里这里</span></span><br><span class="line">    <span class="function"><span class="title">fullname3</span>(<span class="params">state, getters, rootState</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> getters.fullname2 + rootState.counter</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// this.$store.dispatch() 提交</span></span><br><span class="line">  actions: &#123;</span><br><span class="line">    <span class="comment">// 这里的 context 不是store对象了 而是这个module对应的mutations</span></span><br><span class="line">    <span class="function"><span class="title">aUpdateName</span>(<span class="params">context</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(context);</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        context.commit(<span class="string">&#x27;updateName&#x27;</span>, <span class="string">&#x27;wangwu&#x27;</span>)</span><br><span class="line">      &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="项目结构组织"><a href="#项目结构组织" class="headerlink" title="项目结构组织"></a>项目结构组织</h2><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20220518111628292.png" alt="image-20220518111628292"></p><p>将vuex里面的部分文件都抽离出来</p><ul><li>index.js</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> Vue from <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Vuex from <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> mutations from <span class="string">&#x27;./mutations&#x27;</span></span><br><span class="line"><span class="keyword">import</span> actions from <span class="string">&#x27;./actions&#x27;</span></span><br><span class="line"><span class="keyword">import</span> getters from <span class="string">&#x27;./getters&#x27;</span></span><br><span class="line"><span class="keyword">import</span> moduleA from <span class="string">&#x27;./modules/moduleA&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 1.安装插件</span></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 2.创建对象 new Vuex.Store</span></span><br><span class="line"><span class="comment">// state 一般不会抽出去 而是写在这个文件</span></span><br><span class="line"><span class="keyword">const</span> state = &#123;</span><br><span class="line">  counter: <span class="number">1000</span>,</span><br><span class="line">  students: [&#123;</span><br><span class="line">      id: <span class="number">110</span>,</span><br><span class="line">      name: <span class="string">&#x27;why&#x27;</span>,</span><br><span class="line">      age: <span class="number">18</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      id: <span class="number">111</span>,</span><br><span class="line">      name: <span class="string">&#x27;kobe&#x27;</span>,</span><br><span class="line">      age: <span class="number">24</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      id: <span class="number">112</span>,</span><br><span class="line">      name: <span class="string">&#x27;james&#x27;</span>,</span><br><span class="line">      age: <span class="number">30</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      id: <span class="number">113</span>,</span><br><span class="line">      name: <span class="string">&#x27;curry&#x27;</span>,</span><br><span class="line">      age: <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  info: &#123;</span><br><span class="line"> </span><br><span class="line">    name: <span class="string">&#x27;kobe&#x27;</span>, <span class="comment">// Dep -&gt; [Watcher]</span></span><br><span class="line">    age: <span class="number">40</span>, <span class="comment">// Dep -&gt; [Watcher]</span></span><br><span class="line">    height: <span class="number">1.98</span> <span class="comment">// Dep -&gt; [Watcher]</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  <span class="comment">// 这五个一般都是固定的，是对象</span></span><br><span class="line">  state, <span class="comment">//保存状态</span></span><br><span class="line">  mutations, <span class="comment">// 方法 修改state唯一途径 同步操作</span></span><br><span class="line">  actions, <span class="comment">// 如果有异步操作在这里写 比如网络请求</span></span><br><span class="line">  getters,</span><br><span class="line"> </span><br><span class="line">  modules: &#123;</span><br><span class="line">    a: moduleA</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 3.导出store对象</span></span><br><span class="line">export <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure><h1 id="网络模块封装"><a href="#网络模块封装" class="headerlink" title="网络模块封装"></a>网络模块封装</h1><ul><li>选择一: 传统的Ajax是基于XMLHttpRequest(XHR)<ul><li>为什么不用它呢?<ul><li>非常好解释, 配置和调用方式等非常混乱.</li><li>编码起来看起来就非常蛋疼.</li><li>所以真实开发中很少直接使用, 而是使用jQuery-Ajax </li></ul></li></ul></li></ul><p>选择二: 在前面的学习中, 我们经常会使用jQuery-Ajax</p><ul><li><p>相对于传统的Ajax非常好用.</p></li><li><p>为什么不选择它呢?</p><ul><li>完全没有必要为了用网络请求就引用这个重量级的框架 </li><li>Vue的代码才1w+行.</li><li>jQuery的代码1w+行.</li><li>那么, 就意味着为了方便我们进行一个网络请求, 特意引用一个jQuery, 你觉得合理吗?</li><li>首先, 我们先明确一点: 在Vue的整个开发中都是不需要使用jQuery了.</li></ul></li><li><p>选择四: 在说明不再继续更新和维护vue-resource的同时, 作者还推荐了一个框架: axios为什么不用它呢?</p></li><li><p>axios有非常多的优点, 并且用起来也非常方便.</p></li></ul><h2 id="jsonp封装"><a href="#jsonp封装" class="headerlink" title="jsonp封装"></a>jsonp封装</h2><ul><li>在前端开发中, 我们一种常见的网络请求方式就是JSONP<ul><li>使用JSONP最主要的原因往往是为了解决跨域访问的问题.</li></ul></li><li>SONP的原理是什么呢?<ul><li>JSONP的核心在于通过<script>标签的src来帮助我们请求数据.</li><li>原因是我们的项目部署在domain1.com服务器上时, 是不能直接访问domain2.com服务器上的资料的.</li><li>这个时候, 我们利用<script>标签的src帮助我们去服务器请求到数据, 将数据当做一个javascript的函数来执行, 并且执行的过程中传入我们需要的json.</li><li>所以, 封装jsonp的核心就在于我们监听window上的jsonp进行回调时的名称.</li></ul></li></ul><h3 id="JSONP封装"><a href="#JSONP封装" class="headerlink" title="JSONP封装"></a>JSONP封装</h3><p><img src= "/img/loading1.gif" data-lazy-src="https://img-blog.csdnimg.cn/2021080413040086.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIzMDczODEx,size_16,color_FFFFFF,t_70" alt="img"><br><img src= "/img/loading1.gif" data-lazy-src="https://img-blog.csdnimg.cn/20210804130410779.png" alt="img"></p><h2 id="认识axios"><a href="#认识axios" class="headerlink" title="认识axios"></a>认识axios</h2><ul><li><p>功能特点:</p><ul><li>在浏览器中发送 XMLHttpRequests 请求</li><li>在 node.js 中发送 http请求</li><li>支持 Promise API</li><li>拦截请求和响应</li><li>转换请求和响应数据</li><li>等等 </li></ul><p> <strong><em>\</em>axios=ajax+promise**</strong></p></li></ul><h3 id="axiox请求方式"><a href="#axiox请求方式" class="headerlink" title="axiox请求方式"></a>axiox请求方式</h3><p>支持多种请求方式:</p><ul><li>axios(config)</li><li>axios.request(config)</li><li>axios.get(url[, config])</li><li>axios.delete(url[, config])</li><li>axios.head(url[, config])</li><li>axios.post(url[, data[, config]])</li><li>axios.put(url[, data[, config]])</li><li>axios.patch(url[, data[, config]]) </li></ul><h3 id="axios发送基本请求"><a href="#axios发送基本请求" class="headerlink" title="axios发送基本请求"></a>axios发送基本请求</h3><ul><li>安装axios</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install axios --save</span><br></pre></td></tr></table></figure><ul><li>main.js代码 </li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 1.axios的基本使用 axios(config)</span></span><br><span class="line">axios(&#123;</span><br><span class="line">  url: <span class="string">&#x27;http://123.207.32.32:8000/home/multidata&#x27;</span>, <span class="comment">// 项目接口</span></span><br><span class="line">  <span class="comment">// 默认是get请求 可以用method指定</span></span><br><span class="line">  <span class="comment">// method: &#x27;post&#x27;</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123; <span class="comment">// 获取返回的数据</span></span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">axios(&#123;</span><br><span class="line">  <span class="comment">//  url:&#x27;http://123.207.32.32:8000/home/data?type=sell&amp;page=1&#x27;</span></span><br><span class="line">  <span class="comment">// 参数除了可以直接拼接在url，也可以用params</span></span><br><span class="line">  url: <span class="string">&#x27;http://123.207.32.32:8000/home/data&#x27;</span>,</span><br><span class="line">  <span class="comment">// 专门针对get请求的参数拼接</span></span><br><span class="line">  params: &#123;</span><br><span class="line">    type: <span class="string">&#x27;pop&#x27;</span>,</span><br><span class="line">    page: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="发送并发请求"><a href="#发送并发请求" class="headerlink" title="发送并发请求"></a>发送并发请求</h3><ul><li>有时候, 我们可能需求同时发送两个请求<ul><li>使用axios.all, 可以放入多个请求的数组.</li><li>axios.all([]) 返回的结果是一个数组，使用 axios.spread 可将数组 [res1,res2] 展开为 res1, res2 </li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2.axios发送并发请求(同时发多个请求,同时到达之后才能往下写代码)</span></span><br><span class="line"><span class="comment">// axios.all([axios(),axios()]).then(reslut=&gt;&#123;&#125;)</span></span><br><span class="line">axios.all([axios(&#123;</span><br><span class="line">  url: <span class="string">&#x27;http://123.207.32.32:8000/home/multidata&#x27;</span></span><br><span class="line">&#125;), axios(&#123;</span><br><span class="line">  url: <span class="string">&#x27;http://123.207.32.32:8000/home/data&#x27;</span>,</span><br><span class="line">  params: &#123;</span><br><span class="line">    type: <span class="string">&#x27;sell&#x27;</span>,</span><br><span class="line">    page: <span class="number">5</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)]).then(<span class="function"><span class="params">results</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(results);</span><br><span class="line">  <span class="built_in">console</span>.log(results[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">console</span>.log(results[<span class="number">1</span>]);</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// .then()也可以写成  axios.spread可以将请求数据区分开来</span></span><br><span class="line">axios.all([axios(&#123;</span><br><span class="line">  url: <span class="string">&#x27;http://123.207.32.32:8000/home/multidata&#x27;</span></span><br><span class="line">&#125;), axios(&#123;</span><br><span class="line">  url: <span class="string">&#x27;http://123.207.32.32:8000/home/data&#x27;</span>,</span><br><span class="line">  params: &#123;</span><br><span class="line">    type: <span class="string">&#x27;sell&#x27;</span>,</span><br><span class="line">    page: <span class="number">5</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)]).then(axios.spread(<span class="function">(<span class="params">res1, res2</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res1);</span><br><span class="line">  <span class="built_in">console</span>.log(res2);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h3><ul><li>在上面的示例中, 我们的BaseURL是固定的<ul><li>事实上, 在开发中可能很多参数都是固定的.</li><li>这个时候我们可以进行一些抽取, 也可以利用axiox的全局配置</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3.使用全局的axios和对应的配置在进行网络请求</span></span><br><span class="line">axios.defaults.baseURL = <span class="string">&#x27;http://123.207.32.32:8000&#x27;</span></span><br><span class="line">axios.defaults.timeout = <span class="number">5000</span> <span class="comment">// 超时</span></span><br><span class="line"> </span><br><span class="line">axios.all([axios(&#123;</span><br><span class="line">  url: <span class="string">&#x27;/home/multidata&#x27;</span></span><br><span class="line">&#125;), axios(&#123;</span><br><span class="line">  url: <span class="string">&#x27;/home/data&#x27;</span>,</span><br><span class="line">  params: &#123;</span><br><span class="line">    type: <span class="string">&#x27;sell&#x27;</span>,</span><br><span class="line">    page: <span class="number">5</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)]).then(axios.spread(<span class="function">(<span class="params">res1, res2</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 使用 axios.spread 可将数组 [res1,res2] 展开为 res1, res2</span></span><br><span class="line">  <span class="built_in">console</span>.log(res1);</span><br><span class="line">  <span class="built_in">console</span>.log(res2);</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><h3 id="常见的配置选项"><a href="#常见的配置选项" class="headerlink" title="常见的配置选项"></a>常见的配置选项</h3><ul><li>请求地址<ul><li>url: ‘/user’, </li></ul></li><li>请求类型<ul><li>method: ‘get’,</li></ul></li><li>请根路径<ul><li>baseURL: ‘<a href="http://www.mt.com/api&#39;">http://www.mt.com/api&#39;</a>,</li></ul></li><li>请求前的数据处理<ul><li>transformRequest:[function(data){}],</li></ul></li><li>请求后的数据处理<ul><li>transformResponse: [function(data){}],</li></ul></li><li>自定义的请求头<ul><li>headers:{‘x-Requested-With’:’XMLHttpRequest’},</li></ul></li><li>URL查询对象<ul><li>params:{ id: 12 }, </li></ul></li><li>请求后的数据处理<ul><li>transformResponse: [function(data){}],</li></ul></li><li>自定义的请求头<ul><li>headers:{‘x-Requested-With’:’XMLHttpRequest’},</li></ul></li><li>URL查询对象<ul><li>params:{ id: 12 }, </li></ul></li><li>查询对象序列化函数<ul><li>paramsSerializer: function(params){ }</li></ul></li><li>request body<ul><li>data: { key: ‘aa’},</li></ul></li><li>超时设置s<ul><li>timeout: 1000,</li></ul></li><li>跨域是否带Token<ul><li>withCredentials: false,</li></ul></li><li>自定义请求处理<ul><li>adapter: function(resolve, reject, config){},</li></ul></li><li>身份验证信息<ul><li>auth: { uname: ‘’, pwd: ‘12’},</li></ul></li><li>响应的数据格式 json / blob /document /arraybuffer / text / stream<ul><li>responseType: ‘json’,</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get方法参数放parmas，post方法参数放request body 请求体的data </span><br></pre></td></tr></table></figure><h3 id="axios实例"><a href="#axios实例" class="headerlink" title="axios实例"></a>axios实例</h3><p>为什么要创建axios的实例呢?</p><ul><li>当我们从axios模块中导入对象时, 使用的实例是默认的实例.</li><li>当给该实例设置一些默认配置时, 这些配置就被固定下来了.</li><li>但是后续开发中, 某些配置可能会不太一样.</li><li>比如某些请求需要使用特定的baseURL或者timeout或者content-Type等.</li><li>这个时候, 我们就可以创建新的实例, 并且传入属于该实例的配置信息. </li></ul><p>方便应对多个开发</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为什么要创建axios实例？有些请求的配置可能会不同，大项目会有多个服务器，服务器的ip不同,baseURL也就不同</span></span><br><span class="line">axios.defaults.baseURL = <span class="string">&#x27;http://222.111.33.33:8000&#x27;</span></span><br><span class="line">axios.defaults.timeout = <span class="number">10000</span></span><br><span class="line"> </span><br><span class="line">axios(&#123;</span><br><span class="line">  url: <span class="string">&#x27;http://123.207.32.32:8000/category&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 4.创建对应的axios的实例</span></span><br><span class="line"><span class="keyword">const</span> instance1 = axios.create(&#123;</span><br><span class="line">  baseURL: <span class="string">&#x27;http://123.207.32.32:8000&#x27;</span>,</span><br><span class="line">  timeout: <span class="number">5000</span></span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line">instance1(&#123;</span><br><span class="line">  url: <span class="string">&#x27;/home/multidata&#x27;</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line">instance1(&#123;</span><br><span class="line">  url: <span class="string">&#x27;/home/data&#x27;</span>,</span><br><span class="line">  params: &#123;</span><br><span class="line">    type: <span class="string">&#x27;pop&#x27;</span>,</span><br><span class="line">    page: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instance2 = axios.create(&#123;</span><br><span class="line">  baseURL: <span class="string">&#x27;http://222.111.33.33:8000&#x27;</span>,</span><br><span class="line">  timeout: <span class="number">10000</span>,</span><br><span class="line">  headers: &#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="axios封装"><a href="#axios封装" class="headerlink" title="axios封装"></a>axios封装</h3><ul><li><strong>request封装v1.0</strong> 使用回调，返回数据</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// request.js</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// request封装v1.0 使用回调，返回数据</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config, success, failure</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1.创建axios的实例</span></span><br><span class="line">  <span class="keyword">const</span> instance = axios.create(&#123;</span><br><span class="line">    baseURL: <span class="string">&#x27;http://123.207.32.32:8000&#x27;</span>,</span><br><span class="line">    timeout: <span class="number">5000</span></span><br><span class="line">  &#125;)</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 发送真正的网络请求</span></span><br><span class="line">  instance(config)</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// console.log(res);</span></span><br><span class="line">      success(res);</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// console.log(err);</span></span><br><span class="line">      failure(err)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 5.封装request模块</span></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  request</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&quot;./network/request&quot;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// request封装v1.0 的调用</span></span><br><span class="line">request(&#123;</span><br><span class="line">  url: <span class="string">&#x27;/home/multidata&#x27;</span></span><br><span class="line">&#125;, <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><strong>request封装v2.0</strong> 直接传一个config 再从里面取success,failure</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// request.js</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// request封装v2.0 直接传一个config 再从里面取success,failure</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1.创建axios的实例</span></span><br><span class="line">  <span class="keyword">const</span> instance = axios.create(&#123;</span><br><span class="line">    baseURL: <span class="string">&#x27;http://123.207.32.32:8000&#x27;</span>,</span><br><span class="line">    timeout: <span class="number">5000</span></span><br><span class="line">  &#125;)</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 发送真正的网络请求</span></span><br><span class="line">  instance(config.baseConfig)</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// console.log(res);</span></span><br><span class="line">      config.success(res);</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// console.log(err);</span></span><br><span class="line">      config.failure(err)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="comment">// request封装v2.0 的调用</span></span><br><span class="line">request(&#123;</span><br><span class="line">  baseConfig: &#123;</span><br><span class="line">    url:<span class="string">&#x27;/home/multidata&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  success: <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">  &#125;,</span><br><span class="line">  failure: <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><strong>request封装v3.0</strong> 使用Promise</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// request.js</span></span><br><span class="line"><span class="comment">// request封装v3.0 使用Promise</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 1.创建axios的实例</span></span><br><span class="line">    <span class="keyword">const</span> instance = axios.create(&#123;</span><br><span class="line">      baseURL: <span class="string">&#x27;http://123.207.32.32:8000&#x27;</span>,</span><br><span class="line">      timeout: <span class="number">5000</span></span><br><span class="line">    &#125;)</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 发送真正的网络请求</span></span><br><span class="line">    instance(config)</span><br><span class="line">      .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        resolve(res)</span><br><span class="line">      &#125;)</span><br><span class="line">      .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        reject(err)</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line">request(&#123;</span><br><span class="line">  url: <span class="string">&#x27;/home/multidata&#x27;</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>request封装v4.0</strong> 直接return instance(config) 因为它这个本身就是一个Promise</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// request.js</span></span><br><span class="line"><span class="comment">// request封装v4.0 直接return instance(config) 因为它这个本身就是一个Promise</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1.创建axios的实例</span></span><br><span class="line">    <span class="keyword">const</span> instance = axios.create(&#123;</span><br><span class="line">        baseURL: <span class="string">&#x27;http://123.207.32.32:8000&#x27;</span>,</span><br><span class="line">        timeout: <span class="number">5000</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 2.发送真正的网络请求</span></span><br><span class="line">    <span class="keyword">return</span> instance(config) <span class="comment">// 本身的返回值就是个promise</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js </span></span><br><span class="line"><span class="comment">//  request封装v3.0 / v4.0的调用</span></span><br><span class="line">request(&#123;</span><br><span class="line">  url: <span class="string">&#x27;/home/multidata&#x27;</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// console.log(err);</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><h3 id="如何使用拦截器？"><a href="#如何使用拦截器？" class="headerlink" title="如何使用拦截器？"></a>如何使用拦截器？</h3><ul><li>axios提供了拦截器，用于我们在发送每次请求或者得到相应后，进行对应的处理。</li></ul><h3 id="拦截器中都做什么呢？"><a href="#拦截器中都做什么呢？" class="headerlink" title="拦截器中都做什么呢？"></a>拦截器中都做什么呢？</h3><ul><li><p>请求拦截中错误拦截较少，通常都是配置相关的拦截</p><ul><li>可能的错误比如请求超时，可以将页面跳转到一个错误页面中。</li></ul></li><li><p>响应拦截中完成的事情：</p><ul><li>响应的成功拦截中，主要是对数据进行过滤</li></ul></li><li><p>代码：</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// request.js </span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1.创建axios的实例</span></span><br><span class="line">  <span class="keyword">const</span> instance = axios.create(&#123;</span><br><span class="line">    baseURL: <span class="string">&#x27;http://123.207.32.32:8000&#x27;</span>,</span><br><span class="line">    timeout: <span class="number">5000</span></span><br><span class="line">  &#125;)</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 2.axios的拦截器</span></span><br><span class="line">  <span class="comment">// 2.1.请求拦截的作用 成功/失败</span></span><br><span class="line">  instance.interceptors.request.use(<span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// console.log(config);</span></span><br><span class="line">    <span class="comment">// 1.比如config中的一些信息不符合服务器的要求</span></span><br><span class="line">    <span class="comment">// 2.比如每次发送网络请求时, 都希望在界面中显示一个请求的图标</span></span><br><span class="line">    <span class="comment">// 3.某些网络请求(比如登录(token)), 必须携带一些特殊的信息</span></span><br><span class="line">    <span class="comment">// 得把config再返回</span></span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">  &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// console.log(err);</span></span><br><span class="line">  &#125;)</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 2.2.响应拦截 成功/失败</span></span><br><span class="line">  instance.interceptors.response.use(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// console.log(res);</span></span><br><span class="line">    <span class="keyword">return</span> res.data</span><br><span class="line">  &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.发送真正的网络请求</span></span><br><span class="line">    <span class="keyword">return</span> instance(config) <span class="comment">// 本身的返回值就是个promise</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// main.js</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  request封装v3.0 / v4.0的调用</span></span><br><span class="line">    request(&#123;</span><br><span class="line">      url: <span class="string">&#x27;/home/multidata&#x27;</span></span><br><span class="line">    &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(res);</span><br><span class="line">    &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// console.log(err);</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Vue 知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> ES6 </tag>
            
            <tag> Webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>知识碎片  SpringMVC、 Servlet 、序列和反序列</title>
      <link href="2021/03/08/%E7%9F%A5%E8%AF%86%E7%A2%8E%E7%89%87-SpringMVC%E3%80%81-Servlet-%E3%80%81%E5%BA%8F%E5%88%97%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97/"/>
      <url>2021/03/08/%E7%9F%A5%E8%AF%86%E7%A2%8E%E7%89%87-SpringMVC%E3%80%81-Servlet-%E3%80%81%E5%BA%8F%E5%88%97%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="springMVC"><a href="#springMVC" class="headerlink" title="springMVC"></a><strong>springMVC</strong></h1><h2 id="1、springmvc工作原理图"><a href="#1、springmvc工作原理图" class="headerlink" title="1、springmvc工作原理图"></a>1、springmvc工作原理图</h2><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/1121080-20190509202147059-745656946.jpg"></p><h2 id="2、springmvc工作流程"><a href="#2、springmvc工作流程" class="headerlink" title="2、springmvc工作流程"></a>2、springmvc工作流程</h2><p>1、 用户向服务端发送一次请求，这个请求会先到前端控制器DispatcherServlet(也叫中央控制器)。<br>2、DispatcherServlet接收到请求后会调用HandlerMapping处理器映射器。由此得知，该请求该由哪个Controller来处理（并未调用Controller，只是得知）<br>3、DispatcherServlet调用HandlerAdapter处理器适配器，告诉处理器适配器应该要去执行哪个Controller<br>4、HandlerAdapter处理器适配器去执行Controller并得到ModelAndView(数据和视图)，并层层返回给DispatcherServlet<br>5、DispatcherServlet将ModelAndView交给ViewReslover视图解析器解析，然后返回真正的视图。<br>6、DispatcherServlet将模型数据填充到视图中<br>7、DispatcherServlet将结果响应给用户</p><h2 id="3、组件说明"><a href="#3、组件说明" class="headerlink" title="3、组件说明"></a>3、组件说明</h2><ul><li>DispatcherServlet：前端控制器，也称为中央控制器，它是整个请求响应的控制中心，组件的调用由它统一调度。</li><li>HandlerMapping：处理器映射器，它根据用户访问的 URL 映射到对应的后端处理器 Handler。也就是说它知道处理用户请求的后端处理器，但是它并不执行后端处理器，而是将处理器告诉给中央处理器。</li><li>HandlerAdapter：处理器适配器，它调用后端处理器中的方法，返回逻辑视图 ModelAndView 对象。</li><li>ViewResolver：视图解析器，将 ModelAndView 逻辑视图解析为具体的视图（如 JSP）。</li><li>Handler：后端处理器，对用户具体请求进行处理，也就是我们编写的 Controller 类。</li></ul><h2 id="4、-接口说明"><a href="#4、-接口说明" class="headerlink" title="4、 接口说明"></a>4、 接口说明</h2><p>HandlerMapping接口 – 处理请求的映射<br>HandlerMapping接口的实现类：<br>SimpleUrlHandlerMapping 通过配置文件，把一个URL映射到Controller<br>DefaultAnnotationHandlerMapping 通过注解，把一个URL映射到Controller类上</p><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/c6b474c8-91fa-3009-a0e9-c868ca52baf2.jpg"></p><p>HandlerAdapter接口 – 处理请求的映射<br>AnnotationMethodHandlerAdapter类，通过注解，把一个URL映射到Controller类的方法上</p><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/8475318e-d2e2-3dd2-81e9-036090f0aad1-16556034249644.jpg"></p><p>Controller接口 – 控制器<br>由于我们使用了@Controller注解，添加了@Controller注解注解的类就可以担任控制器（Action）的职责,</p><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/67b19bd0-e44c-311a-8d05-80d013cf44ae.jpg" alt="67b19bd0-e44c-311a-8d05-80d013cf44ae"></p><h2 id="5、为什么要选springMVC"><a href="#5、为什么要选springMVC" class="headerlink" title="5、为什么要选springMVC"></a>5、为什么要选springMVC</h2><p>Spring MVC是当前最优秀的MVC框架，自从Spring 2.5版本发布后，由于支持注解配置，易用性有了大幅度的提高。Spring 3.0更加完善，<strong>实现了对Struts 2的超越</strong>。现在越来越多的开发团队选择了<strong>Spring MVC</strong>。</p><p><strong>Struts2</strong>也是非常优秀的MVC构架，优点非常多比如良好的结构，拦截器的思想，丰富的功能。但这里想说的是缺点，Struts2由于采用了==值栈==、OGNL表达式、struts2标签库等，会导致应用的==性能下降==，应避免使用这些功能。而Struts2的多层拦截器、多实例action性能都很好。</p><h1 id="Servlet工作原理"><a href="#Servlet工作原理" class="headerlink" title="Servlet工作原理"></a>Servlet工作原理</h1><p>介绍：Servlet是sun公司提供的一门用于开发动态web资源的技术。</p><p>​       Sun公司在其API中提供了一个servlet接口，用户若想用发一个动态web资源(即开发一个Java程序向浏览器输出数据)，需要完成以下2个步骤：<br>　　1、编写一个<strong>Java类</strong>，实现<strong>servlet</strong>接口。<br>　　2、把开发好的Java类部署到web服务器中。<br>　　按照一种约定俗成的称呼习惯，通常我们也把<strong>实现了servlet接口的java程序</strong>，称之为Servlet.</p><h2 id="Servlet的运行过程"><a href="#Servlet的运行过程" class="headerlink" title="Servlet的运行过程"></a>Servlet的运行过程</h2><p>Servlet程序是由WEB服务器调用，web服务器收到客户端的Servlet访问请求后：<br>　　①Web服务器首先<strong>检查</strong>是否已经==装载并创建了该Servlet的实例对象==。如果是，则直接执行第④步，否则，执行第②步。<br>　　②装载并创建该Servlet的一个实例对象。<br>　　③调用Servlet实例对象的**init()**方法。<br>　　④创建一个用于封装HTTP请求消息的HttpServletRequest对象和一个代表HTTP响应消息的HttpServletResponse对象，然后调用Servlet的service()方法并将请求和响应对象作为参数传递进去。<br>　　⑤WEB应用程序被停止或重新启动之前，Servlet引擎将卸载Servlet，并在卸载之前调用Servlet的destroy()方法。 </p><h2 id="Servlet接口实现类"><a href="#Servlet接口实现类" class="headerlink" title="Servlet接口实现类"></a>Servlet接口实现类</h2><p>　   Servlet接口SUN公司定义了两个默认实现类，分别为：<strong>GenericServlet</strong>、<strong>HttpServlet</strong>。</p><p>　　HttpServlet指能够处理HTTP请求的servlet，它在原有Servlet接口上添加了==一些与HTTP协议处理方法==，它比Servlet接口的功能更为强大。因此开发人员在编写Servlet时，通常应继承这个类，而避免直接去实现Servlet接口。<br>　　HttpServlet在实现Servlet接口时，==覆写了service方法==，该方法体内的代码会自动判断用户的请求方式，如为<strong>GET请求</strong>，则调用HttpServlet的<strong>doGet</strong>方法，如为<strong>Post</strong>请求，则调用<strong>doPost</strong>方法。因此，开发人员在编写Servlet时，通常只需要覆写doGet或doPost方法，而不要去覆写service方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloServlet</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">super</span>();  </span><br><span class="line">    &#125;  </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">super</span>.destroy(); <span class="comment">// Just puts &quot;destroy&quot; string in log  </span></span><br><span class="line">    &#125;  </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span>  </span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ServletException, IOException </span>&#123;  </span><br><span class="line">  </span><br><span class="line">          </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span>  </span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ServletException, IOException </span>&#123;  </span><br><span class="line"></span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;servlet init&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h2 id="关于servlet并发问题"><a href="#关于servlet并发问题" class="headerlink" title="关于servlet并发问题"></a>关于servlet并发问题</h2><h3 id="Servlet的线程安全问题"><a href="#Servlet的线程安全问题" class="headerlink" title="Servlet的线程安全问题"></a>Servlet的线程安全问题</h3><p>   　当多个客户端并发访问同一个Servlet时，web服务器会为每一个客户端的访问请求创建一个线程，并在这个线程上调用Servlet的service方法，因此service方法内如果访问了同一个资源的话，就有可能引发线程安全问题。例如下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletDemo3</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>;   <span class="comment">//当存在有公共变量的时候，会发现并发期间数据不能够一致的问题</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span>  </span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ServletException, IOException </span>&#123;  </span><br><span class="line">          </span><br><span class="line">        i++;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            Thread.sleep(<span class="number">1000</span>*<span class="number">4</span>);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">        response.getWriter().write(i+<span class="string">&quot;&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span>  </span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ServletException, IOException </span>&#123;  </span><br><span class="line">        doGet(request, response);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h3 id="Servlet解决方法"><a href="#Servlet解决方法" class="headerlink" title="Servlet解决方法"></a>Servlet解决方法</h3><blockquote><p>如果直接引用<strong>synchronized</strong> (<strong>this</strong>) 进行锁对象的话，可能会导致多线程访问的时候会出现堵塞情况，处理不了高并发的问题</p></blockquote><p>​       <strong>让Servlet去实现一个SingleThreadModel接口，如果某个Servlet实现了==SingleThreadModel==接口，那么Servlet引擎将以单线程模式来调用其service方法。</strong><br>　　查看Sevlet的API可以看到，SingleThreadModel接口中没有定义任何方法和常量。</p><blockquote><p>在Java中，把没有定义任何方法和常量的接口称之为标记接口</p></blockquote><p>​       经常看到的一个最典型的标记接口就是”<strong>Serializable</strong>“，这个接口也是没有定义任何方法和常量的，标记接口在Java中有什么用呢？主要作用就是给某个对象打上一个标志，告诉JVM，这个对象可以做什么，比如实现了”<strong>Serializable</strong>“接口的类的对象就可以被序列化，还有一个”Cloneable”接口，这个也是一个标记接口，在默认情况下，Java中的对象是不允许被克隆的，就像现实生活中的人一样，不允许克隆，但是只要实现了”Cloneable”接口，那么对象就可以被克隆了。</p><p>​      但是实现了SingleThreadModel接口并<strong>不能真正解决的Servlet的线程安全问题</strong>，因为Servlet的引擎会创建多个Servlet的实例对象，而真正意义上解决多线程安全问题是指一个<strong>Servlet实例对象被多线程同时调用</strong>的问题。事实上，在Servlet API 2.4中，已经将SingleThreadModel标记为Deprecated（过时的）那么防止线程安全的问题就是避免使用<strong>实例变量</strong>，采用<strong>局部变量</strong>的形式。</p><h1 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h1><blockquote><p>序列说白了就是方便传输，传输时要拆解为二进制 ，传完后再重组，序列化能保证重组的准确性</p></blockquote><h2 id="序列化定义"><a href="#序列化定义" class="headerlink" title="序列化定义"></a>序列化定义</h2><p><strong>序列化</strong>：<code>Java</code>中的序列化机制能够将一个实例对象信息写入到一个字节流中（<strong>只序列化对象的属性值，而不会去序列化方法</strong>），序列化后的对象可用于网络传输，或者持久化到数据库、磁盘中。</p><p><strong>反序列化</strong>：需要对象的时候，再通过字节流中的信息来重构一个相同的对象。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><ul><li>一个对象序列化的接口，一个类只有实现了==Serializable==接口，它的对象才是==可序列化==的。因此如果要序列化某些类的对象，这些类就必须实现Serializable接口。而实际上，==Serializable是一个空接口==，==没有什么具体内容==，它的目的只是简单的标识一个类的对象可以被序列化。</li><li>String<code>已经内部实现了</code>Serializable</li></ul><h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><ol><li>比如说你的内存不够用了，那计算机就要将内存里面的一部分对象==暂时==的保存到硬盘中，等到要用的时候再读入到内存中，硬盘的那部分存储空间就是所谓的==虚拟内存==。在比如过你要将某个特定的对象保存到文件中，我隔几天在把它拿出来用，那么这时候就要实现Serializable接口</li><li>在进行java的Socket编程的时候，你有时候可能要传输某一类的对象，那么也就要实现Serializable接口；最常见的你传输一个字符串，它是JDK里面的类，也实现了Serializable接口，所以可以在网络上传输。</li></ol><h2 id="serialVersionUID-关键字"><a href="#serialVersionUID-关键字" class="headerlink" title="serialVersionUID 关键字"></a>serialVersionUID 关键字</h2><p>示例代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public final class String</span><br><span class="line">    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    &#x2F;** The value is used for character storage. *&#x2F;</span><br><span class="line">    private final char value[];</span><br><span class="line">    </span><br><span class="line">    &#x2F;** Cache the hash code for the string *&#x2F;</span><br><span class="line">    private int hash; &#x2F;&#x2F; Default to 0</span><br><span class="line"></span><br><span class="line">    &#x2F;** use serialVersionUID from JDK 1.0.2 for interoperability *&#x2F;</span><br><span class="line">    private static final long serialVersionUID &#x3D; -6849794470754667710L; &#x2F;&#x2F;这里有序列化id</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="serialVersionUID-作用"><a href="#serialVersionUID-作用" class="headerlink" title="serialVersionUID 作用"></a>serialVersionUID 作用</h2><p>因为序列化对象时，如果不显示的设置<code>serialVersionUID</code>，Java在序列化时会根据对象属性==自动==的生成一个<code>serialVersionUID</code>，再进行==存储或用作网络传输==。</p><p>在反序列化时，会根据对象属性自动再生成一个新的<code>serialVersionUID</code>，和序列化时生成的<code>serialVersionUID</code>进行==比对==，两个<code>serialVersionUID</code>相同则==反序列化==成功，否则就会抛异常。</p><p>而当显示的设置<code>serialVersionUID</code>后，Java在==序列化和反序列化==对象时，生成的<code>serialVersionUID</code>都为我们设定的<code>serialVersionUID</code>，这样就保证了==反序列化==的成功。</p><h2 id="transient-关键字"><a href="#transient-关键字" class="headerlink" title="transient 关键字"></a>transient 关键字</h2><p>序列化对象时如果希望哪个属性不被序列化，则用<code>transient</code>关键字修饰即可</p><p>可以看到字段<code>name</code>的值没有被保存到磁盘中，一旦变量被<code>transient</code>修饰，变量将不再是对象持久化的一部分，该变量内容在序列化后==无法获得访问==。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> String name; <span class="comment">//transient 在这里进行修饰</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Java序列化前的结果: User(name=fufu, age=<span class="number">18</span>)</span><br><span class="line">Java反序列化的结果:User(name=<span class="keyword">null</span>, age=<span class="number">18</span>)</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>一个静态变量不管是否被<code>transient</code>修饰，均不能被序列化。 因为<code>static</code>修饰的属性是属于类，而非对象。</p>]]></content>
      
      
      <categories>
          
          <category> Java 知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣习题 105. 从前序与中序遍历序列构造二叉树 解析</title>
      <link href="2021/02/03/%E5%8A%9B%E6%89%A3%E4%B9%A0%E9%A2%98-105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91-%E8%A7%A3%E6%9E%90/"/>
      <url>2021/02/03/%E5%8A%9B%E6%89%A3%E4%B9%A0%E9%A2%98-105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91-%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="力扣-105"><a href="#力扣-105" class="headerlink" title="力扣 105"></a>力扣 105</h1><h2 id="Q：从前序与中序遍历序列构造二叉树"><a href="#Q：从前序与中序遍历序列构造二叉树" class="headerlink" title="Q：从前序与中序遍历序列构造二叉树"></a>Q：从前序与中序遍历序列构造二叉树</h2><h2 id="1-解题"><a href="#1-解题" class="headerlink" title="1. 解题"></a>1. 解题</h2><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2. 解题思路"></a>2. 解题思路</h3><ul><li>通过前序遍历的数组找到树的根节点</li><li>通过中序遍历的数组找到左右子树</li><li>使用遍历手段或者HaspMap键值对来实现找根过程</li></ul><h3 id="3-相关图解"><a href="#3-相关图解" class="headerlink" title="3. 相关图解"></a>3. 相关图解</h3><ul><li><p>第一步初始化<br><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20210203154853182.png"></p></li><li><p>第二步通过前序遍历找到树根，划分左右子树，通过HashMap找到中序遍历里面的树根<br><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20210203155913663.png"></p></li><li><p>移动位置，然后同时找到相对的地方进行递归</p></li></ul><h3 id="3-代码分析"><a href="#3-代码分析" class="headerlink" title="3. 代码分析"></a>3. 代码分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> sun.reflect.generics.tree.Tree;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">tree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        TreeNode() &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">            <span class="keyword">this</span>.left = left;</span><br><span class="line">            <span class="keyword">this</span>.right = right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> preOrder 前序遍历数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inOrder  中序遍历数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preOrder, <span class="keyword">int</span>[] inOrder)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inOrder.length; i++) &#123;</span><br><span class="line">            map.put(inOrder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> buildTreeHelper(preOrder,<span class="number">0</span>,preOrder.length,inOrder,<span class="number">0</span>,inOrder.length,map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> preOrder 前序遍历数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> p_start 前序开始位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> p_end 前序结束位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inOrder 中序遍历数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i_start 中序开始位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i_end 中序结束位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map 键值对</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> root 树根</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTreeHelper</span><span class="params">(<span class="keyword">int</span>[] preOrder, <span class="keyword">int</span> p_start, <span class="keyword">int</span> p_end,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">int</span>[] inOrder, <span class="keyword">int</span> i_start, <span class="keyword">int</span> i_end,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    HashMap&lt;Integer, Integer&gt; map)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p_start == p_end) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> root_val = preOrder[p_start];</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(root_val);</span><br><span class="line">        <span class="keyword">int</span> root_index = map.get(root_val);</span><br><span class="line">        <span class="keyword">int</span> moveNum = root_index - i_start;</span><br><span class="line">        root.left = buildTreeHelper(preOrder, p_start+<span class="number">1</span>, p_start+moveNum+<span class="number">1</span>, inOrder, i_start, root_index, map);</span><br><span class="line">        root.right = buildTreeHelper(preOrder, p_start+moveNum+<span class="number">1</span>, p_end, inOrder, root_index+<span class="number">1</span>, i_end, map);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历数组</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printTree</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        System.out.print(root.val + <span class="string">&quot;  &quot;</span>);</span><br><span class="line">        printTree(root.left);</span><br><span class="line">        printTree(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] preOrder = &#123;<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="number">15</span>,<span class="number">7</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] inOrder = &#123;<span class="number">9</span>,<span class="number">3</span>,<span class="number">15</span>,<span class="number">20</span>,<span class="number">7</span>&#125;;</span><br><span class="line">        TreeNode root = buildTree(preOrder,inOrder);</span><br><span class="line"></span><br><span class="line">        printTree(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>1.优化多次使用for循环进行查找根操作</li><li>2.内部时间复杂度可以进一步优化</li><li>3.通过hashMap来快速存储，做到快速定位</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> LC </tag>
            
            <tag> 算法与数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试</title>
      <link href="2021/02/01/firstpost/"/>
      <url>2021/02/01/firstpost/</url>
      
        <content type="html"><![CDATA[<h1 id="第一次发布"><a href="#第一次发布" class="headerlink" title="第一次发布"></a>第一次发布</h1><ul><li>test</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test</span><br><span class="line">    <span class="comment">//ddd</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
