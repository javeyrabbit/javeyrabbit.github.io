<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>知识碎片  SpringMVC、 Servlet 、序列和反序列</title>
      <link href="2021/03/08/%E7%9F%A5%E8%AF%86%E7%A2%8E%E7%89%87-SpringMVC%E3%80%81-Servlet-%E3%80%81%E5%BA%8F%E5%88%97%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97/"/>
      <url>2021/03/08/%E7%9F%A5%E8%AF%86%E7%A2%8E%E7%89%87-SpringMVC%E3%80%81-Servlet-%E3%80%81%E5%BA%8F%E5%88%97%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="springMVC"><a href="#springMVC" class="headerlink" title="springMVC"></a><strong>springMVC</strong></h1><h2 id="1、springmvc工作原理图"><a href="#1、springmvc工作原理图" class="headerlink" title="1、springmvc工作原理图"></a>1、springmvc工作原理图</h2><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/1121080-20190509202147059-745656946.jpg"></p><h2 id="2、springmvc工作流程"><a href="#2、springmvc工作流程" class="headerlink" title="2、springmvc工作流程"></a>2、springmvc工作流程</h2><p>1、 用户向服务端发送一次请求，这个请求会先到前端控制器DispatcherServlet(也叫中央控制器)。<br>2、DispatcherServlet接收到请求后会调用HandlerMapping处理器映射器。由此得知，该请求该由哪个Controller来处理（并未调用Controller，只是得知）<br>3、DispatcherServlet调用HandlerAdapter处理器适配器，告诉处理器适配器应该要去执行哪个Controller<br>4、HandlerAdapter处理器适配器去执行Controller并得到ModelAndView(数据和视图)，并层层返回给DispatcherServlet<br>5、DispatcherServlet将ModelAndView交给ViewReslover视图解析器解析，然后返回真正的视图。<br>6、DispatcherServlet将模型数据填充到视图中<br>7、DispatcherServlet将结果响应给用户</p><h2 id="3、组件说明"><a href="#3、组件说明" class="headerlink" title="3、组件说明"></a>3、组件说明</h2><ul><li>DispatcherServlet：前端控制器，也称为中央控制器，它是整个请求响应的控制中心，组件的调用由它统一调度。</li><li>HandlerMapping：处理器映射器，它根据用户访问的 URL 映射到对应的后端处理器 Handler。也就是说它知道处理用户请求的后端处理器，但是它并不执行后端处理器，而是将处理器告诉给中央处理器。</li><li>HandlerAdapter：处理器适配器，它调用后端处理器中的方法，返回逻辑视图 ModelAndView 对象。</li><li>ViewResolver：视图解析器，将 ModelAndView 逻辑视图解析为具体的视图（如 JSP）。</li><li>Handler：后端处理器，对用户具体请求进行处理，也就是我们编写的 Controller 类。</li></ul><h2 id="4、-接口说明"><a href="#4、-接口说明" class="headerlink" title="4、 接口说明"></a>4、 接口说明</h2><p>HandlerMapping接口 – 处理请求的映射<br>HandlerMapping接口的实现类：<br>SimpleUrlHandlerMapping 通过配置文件，把一个URL映射到Controller<br>DefaultAnnotationHandlerMapping 通过注解，把一个URL映射到Controller类上</p><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/c6b474c8-91fa-3009-a0e9-c868ca52baf2.jpg"></p><p>HandlerAdapter接口 – 处理请求的映射<br>AnnotationMethodHandlerAdapter类，通过注解，把一个URL映射到Controller类的方法上</p><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/8475318e-d2e2-3dd2-81e9-036090f0aad1-16556034249644.jpg"></p><p>Controller接口 – 控制器<br>由于我们使用了@Controller注解，添加了@Controller注解注解的类就可以担任控制器（Action）的职责,</p><p><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/67b19bd0-e44c-311a-8d05-80d013cf44ae.jpg" alt="67b19bd0-e44c-311a-8d05-80d013cf44ae"></p><h2 id="5、为什么要选springMVC"><a href="#5、为什么要选springMVC" class="headerlink" title="5、为什么要选springMVC"></a>5、为什么要选springMVC</h2><p>Spring MVC是当前最优秀的MVC框架，自从Spring 2.5版本发布后，由于支持注解配置，易用性有了大幅度的提高。Spring 3.0更加完善，<strong>实现了对Struts 2的超越</strong>。现在越来越多的开发团队选择了<strong>Spring MVC</strong>。</p><p><strong>Struts2</strong>也是非常优秀的MVC构架，优点非常多比如良好的结构，拦截器的思想，丰富的功能。但这里想说的是缺点，Struts2由于采用了==值栈==、OGNL表达式、struts2标签库等，会导致应用的==性能下降==，应避免使用这些功能。而Struts2的多层拦截器、多实例action性能都很好。</p><h1 id="Servlet工作原理"><a href="#Servlet工作原理" class="headerlink" title="Servlet工作原理"></a>Servlet工作原理</h1><p>介绍：Servlet是sun公司提供的一门用于开发动态web资源的技术。</p><p>​       Sun公司在其API中提供了一个servlet接口，用户若想用发一个动态web资源(即开发一个Java程序向浏览器输出数据)，需要完成以下2个步骤：<br>　　1、编写一个<strong>Java类</strong>，实现<strong>servlet</strong>接口。<br>　　2、把开发好的Java类部署到web服务器中。<br>　　按照一种约定俗成的称呼习惯，通常我们也把<strong>实现了servlet接口的java程序</strong>，称之为Servlet.</p><h2 id="Servlet的运行过程"><a href="#Servlet的运行过程" class="headerlink" title="Servlet的运行过程"></a>Servlet的运行过程</h2><p>Servlet程序是由WEB服务器调用，web服务器收到客户端的Servlet访问请求后：<br>　　①Web服务器首先<strong>检查</strong>是否已经==装载并创建了该Servlet的实例对象==。如果是，则直接执行第④步，否则，执行第②步。<br>　　②装载并创建该Servlet的一个实例对象。<br>　　③调用Servlet实例对象的**init()**方法。<br>　　④创建一个用于封装HTTP请求消息的HttpServletRequest对象和一个代表HTTP响应消息的HttpServletResponse对象，然后调用Servlet的service()方法并将请求和响应对象作为参数传递进去。<br>　　⑤WEB应用程序被停止或重新启动之前，Servlet引擎将卸载Servlet，并在卸载之前调用Servlet的destroy()方法。 </p><h2 id="Servlet接口实现类"><a href="#Servlet接口实现类" class="headerlink" title="Servlet接口实现类"></a>Servlet接口实现类</h2><p>　   Servlet接口SUN公司定义了两个默认实现类，分别为：<strong>GenericServlet</strong>、<strong>HttpServlet</strong>。</p><p>　　HttpServlet指能够处理HTTP请求的servlet，它在原有Servlet接口上添加了==一些与HTTP协议处理方法==，它比Servlet接口的功能更为强大。因此开发人员在编写Servlet时，通常应继承这个类，而避免直接去实现Servlet接口。<br>　　HttpServlet在实现Servlet接口时，==覆写了service方法==，该方法体内的代码会自动判断用户的请求方式，如为<strong>GET请求</strong>，则调用HttpServlet的<strong>doGet</strong>方法，如为<strong>Post</strong>请求，则调用<strong>doPost</strong>方法。因此，开发人员在编写Servlet时，通常只需要覆写doGet或doPost方法，而不要去覆写service方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloServlet</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">super</span>();  </span><br><span class="line">    &#125;  </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">super</span>.destroy(); <span class="comment">// Just puts &quot;destroy&quot; string in log  </span></span><br><span class="line">    &#125;  </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span>  </span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ServletException, IOException </span>&#123;  </span><br><span class="line">  </span><br><span class="line">          </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span>  </span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ServletException, IOException </span>&#123;  </span><br><span class="line"></span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;servlet init&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h2 id="关于servlet并发问题"><a href="#关于servlet并发问题" class="headerlink" title="关于servlet并发问题"></a>关于servlet并发问题</h2><h3 id="Servlet的线程安全问题"><a href="#Servlet的线程安全问题" class="headerlink" title="Servlet的线程安全问题"></a>Servlet的线程安全问题</h3><p>   　当多个客户端并发访问同一个Servlet时，web服务器会为每一个客户端的访问请求创建一个线程，并在这个线程上调用Servlet的service方法，因此service方法内如果访问了同一个资源的话，就有可能引发线程安全问题。例如下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletDemo3</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>;   <span class="comment">//当存在有公共变量的时候，会发现并发期间数据不能够一致的问题</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span>  </span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ServletException, IOException </span>&#123;  </span><br><span class="line">          </span><br><span class="line">        i++;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            Thread.sleep(<span class="number">1000</span>*<span class="number">4</span>);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">        response.getWriter().write(i+<span class="string">&quot;&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span>  </span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ServletException, IOException </span>&#123;  </span><br><span class="line">        doGet(request, response);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h3 id="Servlet解决方法"><a href="#Servlet解决方法" class="headerlink" title="Servlet解决方法"></a>Servlet解决方法</h3><blockquote><p>如果直接引用<strong>synchronized</strong> (<strong>this</strong>) 进行锁对象的话，可能会导致多线程访问的时候会出现堵塞情况，处理不了高并发的问题</p></blockquote><p>​       <strong>让Servlet去实现一个SingleThreadModel接口，如果某个Servlet实现了==SingleThreadModel==接口，那么Servlet引擎将以单线程模式来调用其service方法。</strong><br>　　查看Sevlet的API可以看到，SingleThreadModel接口中没有定义任何方法和常量。</p><blockquote><p>在Java中，把没有定义任何方法和常量的接口称之为标记接口</p></blockquote><p>​       经常看到的一个最典型的标记接口就是”<strong>Serializable</strong>“，这个接口也是没有定义任何方法和常量的，标记接口在Java中有什么用呢？主要作用就是给某个对象打上一个标志，告诉JVM，这个对象可以做什么，比如实现了”<strong>Serializable</strong>“接口的类的对象就可以被序列化，还有一个”Cloneable”接口，这个也是一个标记接口，在默认情况下，Java中的对象是不允许被克隆的，就像现实生活中的人一样，不允许克隆，但是只要实现了”Cloneable”接口，那么对象就可以被克隆了。</p><p>​      但是实现了SingleThreadModel接口并<strong>不能真正解决的Servlet的线程安全问题</strong>，因为Servlet的引擎会创建多个Servlet的实例对象，而真正意义上解决多线程安全问题是指一个<strong>Servlet实例对象被多线程同时调用</strong>的问题。事实上，在Servlet API 2.4中，已经将SingleThreadModel标记为Deprecated（过时的）那么防止线程安全的问题就是避免使用<strong>实例变量</strong>，采用<strong>局部变量</strong>的形式。</p><h1 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h1><blockquote><p>序列说白了就是方便传输，传输时要拆解为二进制 ，传完后再重组，序列化能保证重组的准确性</p></blockquote><h2 id="序列化定义"><a href="#序列化定义" class="headerlink" title="序列化定义"></a>序列化定义</h2><p><strong>序列化</strong>：<code>Java</code>中的序列化机制能够将一个实例对象信息写入到一个字节流中（<strong>只序列化对象的属性值，而不会去序列化方法</strong>），序列化后的对象可用于网络传输，或者持久化到数据库、磁盘中。</p><p><strong>反序列化</strong>：需要对象的时候，再通过字节流中的信息来重构一个相同的对象。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><ul><li>一个对象序列化的接口，一个类只有实现了==Serializable==接口，它的对象才是==可序列化==的。因此如果要序列化某些类的对象，这些类就必须实现Serializable接口。而实际上，==Serializable是一个空接口==，==没有什么具体内容==，它的目的只是简单的标识一个类的对象可以被序列化。</li><li>String<code>已经内部实现了</code>Serializable</li></ul><h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><ol><li>比如说你的内存不够用了，那计算机就要将内存里面的一部分对象==暂时==的保存到硬盘中，等到要用的时候再读入到内存中，硬盘的那部分存储空间就是所谓的==虚拟内存==。在比如过你要将某个特定的对象保存到文件中，我隔几天在把它拿出来用，那么这时候就要实现Serializable接口</li><li>在进行java的Socket编程的时候，你有时候可能要传输某一类的对象，那么也就要实现Serializable接口；最常见的你传输一个字符串，它是JDK里面的类，也实现了Serializable接口，所以可以在网络上传输。</li></ol><h2 id="serialVersionUID-关键字"><a href="#serialVersionUID-关键字" class="headerlink" title="serialVersionUID 关键字"></a>serialVersionUID 关键字</h2><p>示例代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public final class String</span><br><span class="line">    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    &#x2F;** The value is used for character storage. *&#x2F;</span><br><span class="line">    private final char value[];</span><br><span class="line">    </span><br><span class="line">    &#x2F;** Cache the hash code for the string *&#x2F;</span><br><span class="line">    private int hash; &#x2F;&#x2F; Default to 0</span><br><span class="line"></span><br><span class="line">    &#x2F;** use serialVersionUID from JDK 1.0.2 for interoperability *&#x2F;</span><br><span class="line">    private static final long serialVersionUID &#x3D; -6849794470754667710L; &#x2F;&#x2F;这里有序列化id</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="serialVersionUID-作用"><a href="#serialVersionUID-作用" class="headerlink" title="serialVersionUID 作用"></a>serialVersionUID 作用</h2><p>因为序列化对象时，如果不显示的设置<code>serialVersionUID</code>，Java在序列化时会根据对象属性==自动==的生成一个<code>serialVersionUID</code>，再进行==存储或用作网络传输==。</p><p>在反序列化时，会根据对象属性自动再生成一个新的<code>serialVersionUID</code>，和序列化时生成的<code>serialVersionUID</code>进行==比对==，两个<code>serialVersionUID</code>相同则==反序列化==成功，否则就会抛异常。</p><p>而当显示的设置<code>serialVersionUID</code>后，Java在==序列化和反序列化==对象时，生成的<code>serialVersionUID</code>都为我们设定的<code>serialVersionUID</code>，这样就保证了==反序列化==的成功。</p><h2 id="transient-关键字"><a href="#transient-关键字" class="headerlink" title="transient 关键字"></a>transient 关键字</h2><p>序列化对象时如果希望哪个属性不被序列化，则用<code>transient</code>关键字修饰即可</p><p>可以看到字段<code>name</code>的值没有被保存到磁盘中，一旦变量被<code>transient</code>修饰，变量将不再是对象持久化的一部分，该变量内容在序列化后==无法获得访问==。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> String name; <span class="comment">//transient 在这里进行修饰</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Java序列化前的结果: User(name=fufu, age=<span class="number">18</span>)</span><br><span class="line">Java反序列化的结果:User(name=<span class="keyword">null</span>, age=<span class="number">18</span>)</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>一个静态变量不管是否被<code>transient</code>修饰，均不能被序列化。 因为<code>static</code>修饰的属性是属于类，而非对象。</p>]]></content>
      
      
      <categories>
          
          <category> Java 知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣习题 105. 从前序与中序遍历序列构造二叉树 解析</title>
      <link href="2021/02/03/%E5%8A%9B%E6%89%A3%E4%B9%A0%E9%A2%98-105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91-%E8%A7%A3%E6%9E%90/"/>
      <url>2021/02/03/%E5%8A%9B%E6%89%A3%E4%B9%A0%E9%A2%98-105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91-%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="力扣-105"><a href="#力扣-105" class="headerlink" title="力扣 105"></a>力扣 105</h1><h2 id="Q：从前序与中序遍历序列构造二叉树"><a href="#Q：从前序与中序遍历序列构造二叉树" class="headerlink" title="Q：从前序与中序遍历序列构造二叉树"></a>Q：从前序与中序遍历序列构造二叉树</h2><h2 id="1-解题"><a href="#1-解题" class="headerlink" title="1. 解题"></a>1. 解题</h2><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2. 解题思路"></a>2. 解题思路</h3><ul><li>通过前序遍历的数组找到树的根节点</li><li>通过中序遍历的数组找到左右子树</li><li>使用遍历手段或者HaspMap键值对来实现找根过程</li></ul><h3 id="3-相关图解"><a href="#3-相关图解" class="headerlink" title="3. 相关图解"></a>3. 相关图解</h3><ul><li><p>第一步初始化<br><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20210203154853182.png"></p></li><li><p>第二步通过前序遍历找到树根，划分左右子树，通过HashMap找到中序遍历里面的树根<br><img src= "/img/loading1.gif" data-lazy-src="https://luworkspace-1309238427.cos.ap-guangzhou.myqcloud.com/img/image-20210203155913663.png"></p></li><li><p>移动位置，然后同时找到相对的地方进行递归</p></li></ul><h3 id="3-代码分析"><a href="#3-代码分析" class="headerlink" title="3. 代码分析"></a>3. 代码分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> sun.reflect.generics.tree.Tree;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">tree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        TreeNode() &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">            <span class="keyword">this</span>.left = left;</span><br><span class="line">            <span class="keyword">this</span>.right = right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> preOrder 前序遍历数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inOrder  中序遍历数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preOrder, <span class="keyword">int</span>[] inOrder)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inOrder.length; i++) &#123;</span><br><span class="line">            map.put(inOrder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> buildTreeHelper(preOrder,<span class="number">0</span>,preOrder.length,inOrder,<span class="number">0</span>,inOrder.length,map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> preOrder 前序遍历数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> p_start 前序开始位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> p_end 前序结束位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inOrder 中序遍历数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i_start 中序开始位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i_end 中序结束位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map 键值对</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> root 树根</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTreeHelper</span><span class="params">(<span class="keyword">int</span>[] preOrder, <span class="keyword">int</span> p_start, <span class="keyword">int</span> p_end,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">int</span>[] inOrder, <span class="keyword">int</span> i_start, <span class="keyword">int</span> i_end,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    HashMap&lt;Integer, Integer&gt; map)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p_start == p_end) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> root_val = preOrder[p_start];</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(root_val);</span><br><span class="line">        <span class="keyword">int</span> root_index = map.get(root_val);</span><br><span class="line">        <span class="keyword">int</span> moveNum = root_index - i_start;</span><br><span class="line">        root.left = buildTreeHelper(preOrder, p_start+<span class="number">1</span>, p_start+moveNum+<span class="number">1</span>, inOrder, i_start, root_index, map);</span><br><span class="line">        root.right = buildTreeHelper(preOrder, p_start+moveNum+<span class="number">1</span>, p_end, inOrder, root_index+<span class="number">1</span>, i_end, map);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历数组</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printTree</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        System.out.print(root.val + <span class="string">&quot;  &quot;</span>);</span><br><span class="line">        printTree(root.left);</span><br><span class="line">        printTree(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] preOrder = &#123;<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="number">15</span>,<span class="number">7</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] inOrder = &#123;<span class="number">9</span>,<span class="number">3</span>,<span class="number">15</span>,<span class="number">20</span>,<span class="number">7</span>&#125;;</span><br><span class="line">        TreeNode root = buildTree(preOrder,inOrder);</span><br><span class="line"></span><br><span class="line">        printTree(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>1.优化多次使用for循环进行查找根操作</li><li>2.内部时间复杂度可以进一步优化</li><li>3.通过hashMap来快速存储，做到快速定位</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> LC </tag>
            
            <tag> 算法与数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试</title>
      <link href="2021/02/01/firstpost/"/>
      <url>2021/02/01/firstpost/</url>
      
        <content type="html"><![CDATA[<h1 id="第一次发布"><a href="#第一次发布" class="headerlink" title="第一次发布"></a>第一次发布</h1><ul><li>test</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test</span><br><span class="line">    <span class="comment">//ddd</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
